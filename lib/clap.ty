import ty
import ty.token (next, peek)
import ty.lex (peekc, getc)
import ty.parse (expr)
import argparse (opt, flag)
import os

function lispCase(s) {
    s.matches(/(?:^[[:lower:]]+)|(?:[[:upper:]][[:lower:]]*)/)
     .join('-')
     .lower()
}

class Args {
    parse(argv = os.args) {
        let opts = self.info()
        let args = []

        let version = self.version()

        for o in opts {
            if o.constraint == Bool {
                args.push(flag(short: o.short, long: o.long, help: o.help))
            } else {
                args.push(opt(short: o.short, long: o.long, help: o.help, convert: o.?conv, post: o.constraint))
            }
        }

        let result = argparse.make(*args, version: version)(argv)

        tuple(**%{o.name: result[o.short] ?? result[o.long] for o in opts})
    }
}

pub macro clap! {
    let name = peek(0).id

    next()

    while peekc().match?(/\s/) {
        getc()
    }

    let version = if peekc() == 'v' {
        getc()

        let v = ''
        
        while !peekc().match?(/\s/) {
            v += getc()
        }

        v
    }

    next()

    let args = []

    while peek(0).type != '}' {
        let help = if peek(0).type == 'comment' {
            next()
            peek(-1).comment
        }

        let name = peek(0).id

        next()
        next()

        let constraint = ty.eval(expr(0))
        let conv = constraint
        let short = name[0]
        let long = lispCase(name)

        while peek(0).type == ',' {
            next()

            let attr = peek(0)
            next()

            match attr.id {
                'conv' => {
                    next()
                    conv = ty.eval(expr(0))
                },

                'short' => {
                    next()
                    short = match ty.eval(expr(0)) { None => nil, x => x }
                },

                'long' => {
                    next()
                    long = match ty.eval(expr(0)) { None => nil, x => x }
                }
            }
        }

        args.push({name, constraint, help, conv, short, long})
    }

    let info = ty.Func(name: 'info', params: [], body: ty.Return(ty.Value(args)))
    let version = ty.Func(name: 'version', params: [], body: ty.Return(ty.Value(version)))

    next()

    ty.Class(name: name, methods: [info, version], super: ty.Id(name: 'Args', module: 'clap'))
}
