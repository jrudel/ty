import bit
import math

tag MatchError;

tag None {
     map()     { None }
     flatMap() { None }
}

tag Some {
    map(f) {
        Some(f(self))
    }

    flatMap(f) {
        f(self)
    }

    from(x) {
        match x {
            nil => None,
            _   => Some(x)
        }
    }
}

tag Ok {
     map(f) {
          Ok(f(self))
     }

     flatMap(f) {
          f(self)
     }
}

tag Err {
     map()     { self }
     flatMap() { self }
}

class Object {
    init(%props) {
        for k, v in props {
            member(self, k, v)
        }
    }

    is?(c) {
        subclass?(type(self), c)
    }

    drill(path) {
        let x = self

        for i in path {
            x = x[i]
        }

        return x
    }

    members() {
        members(self)
    }

    |(other) {
        c -> (c :: self) || (c :: other)
    }

    &(other) {
        c -> (c :: self) && (c :: other)
    }

    :>(other) {
        x -> (self(x) :: other)
    }

    <.>(other) {
        x -> self(other(x))
    }

    __match__(other) {
        self == other
    }

    __question__() {
        (x -> x == nil) | self
    }

    __str__() {
        str(self)
    }

    __fmt__(fmt) {
        str(self)
    }
}

class Class {
    |(other) {
        c -> (c :: self) || (c :: other)
    }

    &(other) {
        c -> (c :: self) && (c :: other)
    }

    __match__(other) {
        type(other) != Class && other.is?(self)
    }
}

class Function : Iter {
    init() {
        id
    }

    flip() {
        (a, b) -> self(b, a)
    }

    bind(x) {
        bindMethod(self, x)
    }

    apply(x, *ys) {
        apply(self, x, *ys)
    }

    __match__(x) {
        self(x)
    }

    |>(f) {
        x -> f(self(x))
    }

    __next__() {
        Some(self())
    }
}

class Array : Iterable {
    init(*xs) {
        xs
    }

    shape() {
        let s = []
        let x = self
        while x :: Array {
            s.push(#x)
            x = x[0]
        }
        return s
    }

    indices() {
        for x, i in self {
            if x :: Array {
                for idx in x.indices() {
                    yield if idx :: Array { [i] + idx } else { [i, idx] }
                }
            } else {
                yield i
            }
        }
    }

    sorted?() {
        for i in 1..#self {
            if self[i - 1] > self[i] {
                return false
            }
        }

        return true
    }

    cycle() {
        let i = 0
        while true {
            yield self[i++ % #self]
        }
    }

    str() {
        self.map(str).sum()
    }

    list() {
        self
    }

    mean(f = id) {
        match self {
            [] => nil,
            _  => self.map(f |> float).sum() / self.len()
        }
    }

    median() {
        match self {
            []                => nil,
            xs : xs.sorted?() => xs[#xs / 2],
            xs                => self.sort()[#self / 2]
        }
    }

    coalesce() {
        for x in self if x != nil {
            return x
        }
    }

    argmax(f = id) {
        if #self == 0 { return nil }

        let i, max = 0, f(self[0])

        for j in 1..#self {
            let y = f(self[j])
            if y > max {
                i, max = j, y
            }
        }

        return i
    }

    __iter__() {
        let i = 0
        return Generator(function () {
            if i < self.len() { return self[i++] }
        })
    }

    __subscript__(T) {
        if self == Array {
            return xs -> (xs :: Array) && xs.all?(x -> x :: T)
        } else {
            return self[T]
        }
    }
}

class Dict : Iterable {
    init(ks, vs) {
        if ks && vs {
            return { k: v for [k, v] in ks.zip(vs) }
        } else {
            return {}
        }
    }

    map(f) {
        return { k: f(v) for k, v in self }
    }

    kmap(f, combine) {
        let new = {}
        for k, v in self {
            let key = f(k)
            if new.has?(key) {
                new[key] = combine(new[key], v)
            } else {
                new[key] = v
            }
        }
        return new
    }

    __iter__() {
        return self.keys().zip(self.values()).__iter__()
    }
}

class String : Iterable {
    init(x) {
        return str(x)
    }

    int(base: Int = 10) {
        return int(self, base)
    }

    repeat(n) {
        return if n != nil {
            let b = blob()
            for _ in ..n { b.push(self) }
            b.str()
        } else {
            Generator(-> self)
        }
    }

    reverse() {
        return self.chars().reverse!().sum() ?? ''
    }

    num?() {
        return self.match?(/^\d+(?:\.\d+)?$/)
    }

    lower?() {
        return self == self.lower()
    }

    upper?() {
        return self == self.upper()
    }

    searchr(pattern) {
        for (let off = self.len() - 1; off >= 0; --off) {
            if let $i = self.search(pattern, off) {
                return i
            }
        }
    }

    strip() {
        return self.comb(/^\s+|\s+$/)
    }

    __iter__() {
        for c in self.chars() {
            yield c
        }
    }

    __fmt__(s) {
        match int(s) {
            nil       => self,
            n : n > 0 => self.padRight(n),
            n : n < 0 => self.padLeft(-n)
        }
    }
}

class Int {
    init(x)  {
        int(x ?? 0)
    }

    ^(b)    { bit.XOR(self, b)        }
    .&.(b)  { bit.AND(self, b)        }
    .|.(b)  { bit.OR(self, b)         }
    <<(b)   { bit.shiftLeft(self, b)  }
    >>(b)   { bit.shiftRight(self, b) }
    **(b)   { math.pow(self, b)       }

    upto(b: Int) {
        while self <= b {
            yield self++
        }
    }

    str(base: Int = 10) {
        let digits = '0123456789ABCDEF'

        if base == 10 { return str(self) }

        let s = ''
        let k = abs(self)

        while k != 0 || #s == 0 {
            s = digits[k % base] + s
            k /= base
        }

        if self < 0 { '-' + s } else { s }
    }

    downto(b: Int) {
        Generator(function () {
            if self >= b { self-- }
        })
    }

    count(k: Int = 1) {
        while true {
            yield self
            self += k
        }
    }

    negate() {
        -self
    }

    sub(n) {
        self - n
    }

    add(n) {
        self + n
    }

    mul(n) {
        self * n
    }

    in?(r: Range) {
        r ? self
    }

    pred() {
        self - 1
    }

    succ() {
        self + 1
    }

    zero?() {
        self == 0
    }

    nonZero?() {
        self != 0
    }

    positive?() {
        self > 0
    }

    negative?() {
        self < 0
    }
}

class Float {
    init(x) {
        float(x)
    }

    **(b: Int | Float) {
        return math.pow(self, b)
    }

    negate() {
        return -self
    }

    sub(n) {
        return self - n
    }

    add(n) {
        return self + n
    }

    mul(n) {
        return self * n
    }
}

class Blob : Iterable {
    init(*args) {
        let b = blob()
        for arg in args { b.push(arg) }
        return b
    }

    searchr(s) {
        for (let off = self.size() - 1; off >= 0; --off) {
            if let $i = self.search(off, s) {
                return i
            }
        }
    }

    __iter__() {
        let i = 0
        return Generator(function () {
            if i < self.size() {
                return self[i++]
            }
        })
    }
}

class Bool {
    init(x) {
        return bool(x)
    }

    __not__() { return !self }
}

class Regex {
    init(x) { return regex(x) }

    ~=(s) { return s.match!(self) }

    ?(s) { return s.match?(self) }

    __match__(s) {
        return (s :: String) && s.match?(self)
    }
}

class Generator : Iter {
    init(f) {
        while let Some(x) = f() {
            yield x
        }
    }

    __next__() {
        self()
    }
}

class Tag {
}

class Iterable {
    map(f) {
        return self.__iter__().map(f)
    }

    filter(f) {
        return self.__iter__().filter(f)
    }

    reverse() {
        return self.__iter__().reverse()
    }

    list() {
        return self.__iter__().list()
    }

    uniq(f) {
        return self.__iter__().uniq(f)
    }

    take(n) {
        return self.__iter__().take(n)
    }

    drop(n) {
        return self.__iter__().drop(n)
    }

    set() {
        return self.__iter__().set()
    }

    str() {
        return self.__iter__().str()
    }

    join(s) {
        return self.__iter__().join(s)
    }

    unlines() {
        return self.__iter__().unlines()
    }

    tally(f) {
        return self.__iter__().tally(f)
    }

    min(k) {
        return self.__iter__().min(k)
    }

    max(k) {
        return self.__iter__().max(k)
    }

    count(x) {
        return self.__iter__().count(x)
    }

    intersperse(x) {
        return self.__iter__().intersperse(x)
    }

    groupsOf(n, keepShort) {
        return self.__iter__().groupsOf(n, keepShort)
    }

    pad(n, x) {
        return self.__iter__().pad(n, x)
    }

    zip(*its) {
        return self.__iter__().zip(*its)
    }

    mean() {
        return self.__iter__().mean()
    }

    median() {
        return self.__iter__().median()
    }

    sum() {
        return self.__iter__().sum()
    }

    fold(a, b) {
        return self.__iter__().fold(a, b)
    }

    group(f) {
        return self.__iter__().group(f)
    }

    chain(A, B) {
        return A.__iter__().chain(B)
    }

    cycle() {
        return self.list().cycle()
    }

    repeat(n) {
        return self.__iter__().repeat(n)
    }

    all?(pred) {
        return self.__iter__().all?(pred)
    }

    interleave(xs) {
        return self.__iter__().interleave(xs)
    }

    __len__() {
        return self.__iter__().__len__()
    }

    __subscript__(i) {
        return self.__iter__().__subscript__(i)
    }
}

class Iter : Iterable {
    map(f) {
        for x in self {
            yield f(x)
        }
    }

    filter(f) {
        for x in self if f(x) {
            yield x
        }
    }

    fold(x, f) {
        if f == nil {
            f = x
            if x = self.__next__() == None {
                return nil
            }
        }

        Some(x) = x

        while let Some(y) = self.__next__() {
            x = f(x, y)
        }

        return x
    }

    __len__() {
        let n = 0

        for _ in self {
            n += 1
        }

        return n
    }

    uniq(f: Function = id) {
        let seen = {}
        for x in self {
            let y = f(x)
            if y not in seen {
                seen << y
                yield x
            }
        }
    }

    zip(*its) {
        its.map!(&__iter__)
        its.insert(0, self)
        let stop = false
        while !stop {
            let group = []
            for it in its {
                if !let Some(x) = it.__next__() {
                    stop = true
                    break
                }
                group.push(x)
            }
            if !stop {
                yield group.tuple()
            }
        }
    }

    pad(n, x) {
        let i = 0
        for x in self {
            yield x
            i += 1
        }
        while i < n {
            yield x
            i += 1
        }
    }

    group(f = id) {
        if !let Some(x) = self.__next__() {
            return Generator(_ -> None)
        }

        let g = [x]

        return Generator(function () {
            while let Some(x) = self.__next__() {
                if f(x) == f(g[-1]) {
                    g.push(x)
                } else {
                    let group = g
                    g = [x]
                    return Some(group)
                }
            }

            if g {
                let group = g
                g = nil
                return Some(group)
            } else {
                None
            }
        })
    }

    groupsOf(n: Int & n >= 0, keepShort: Bool = true) {
        return Generator(function () {
            match self.take(n).list() {
                xs: #xs == n             => Some(xs),
                xs: #xs > 0 && keepShort => Some(xs),
                _ => None
            }
        })
    }

    join(sep: String) {
        if !let Some(str ~> $s) = self.__next__() {
            return ''
        }

        let b = blob()
        b.push(s)

        while let Some(s) = self.__next__() {
            b.push(sep)
            b.push(str(s))
        }

        return b.str()
    }

    unlines() {
        return self.join("\n")
    }

    count(x) {
        let n = 0

        if x :: (Function | Regex) {
            while let Some(y) = self.__next__() {
                if x(y) { n += 1 }
            }
        } else {
            while let Some(y) = self.__next__() {
                if x == y { n += 1 }
            }
        }

        return n
    }

    interleave(ys) {
        ys = ys.__iter__()
        for x in self {
            yield x
            if let Some(y) = ys.__next__() {
                yield y
            }
        }
    }

    list() {
        [x for x in self]
    }

    reverse() {
        return ReverseIter(self)
    }

    take(n) {
        for _ in ..n {
            if let Some(x) = self.__next__() {
                yield x
            } else {
                break
            }
        }
    }

    drop(n) {
        for _ in ..n { self.__next__() }
        return self
    }

    set() {
        return { x for x in self }
    }

    str() {
        let b = blob()

        for s in self {
            b.push(str(s))
        }

        return b.str()
    }

    tally(f = id) {
        let d = {*:0}
        for x in self { d[f(x)] += 1 }
        return d
    }

    max(k = id) {
        if !let Some(x) = self.__next__() {
            return nil
        }

        let m = x
        let mKey = k(m)

        while let Some(x) = self.__next__() {
            let key = k(x)
            if key > mKey {
                m, mKey = x, key
            }
        }

        return m
    }

    min(k = id) {
        if !let Some(x) = self.__next__() {
            return nil
        }

        let m = x
        let mKey = k(m)

        while let Some(x) = self.__next__() {
            let key = k(x)
            if key < mKey {
                m, mKey = x, key
            }
        }

        return m
    }

    intersperse(sep) {
        let first = true;
        for x in self {
            if !first {
                yield sep
            }

            yield x

            first = false
        }
    }

    chainAll() {
        for it in self {
            for x in it.__iter__() {
                yield x
            }
        }
    }

    chain(*its) {
        for it in its {
            for x in it.__iter__() {
                yield x
            }
        }
    }

    cycle() {
        return self.list().cycle()
    }

    repeat(n) {
        let xs = []

        for x in self {
            yield x
            xs.push(x)
        }

        let i = 1

        while i != n {
            for x in xs { yield x }
            i += 1
        }
    }

    replicate(x, n) {
        for _ in ..n {
            yield x
        }
    }

    sum() {
        return self.list().sum()
    }

    mean() {
        return self.list().mean()
    }

    median() {
        return self.list().median()
    }

    all?(pred) {
        for x in self {
            if !pred(x) { return false }
        }

        return true
    }

    __subscript__(i) {
        for _ in ..(i - 1) {
            if self.__next__() == None { return nil }
        }

        if let Some(x) = self.__next__() {
            return x
        }
    }

    __iter__() { return self }
}

class ReverseIter : Iter {
    init(I) {
        self.xs = []
        while let Some(x) = I.__next__() {
            self.xs.push(x)
        }
    }

    __next__() {
        if self.xs {
            Some(self.xs.pop())
        } else {
            None
        }
    }
}

class Range : Iterable {
    init(a, b) {
        self.a = a
        self.b = b
    }

    low() {
        return min(self.a, self.b)
    }

    high() {
        return max(self.a, self.b) - 1
    }

    __len__() {
        return self.high() - self.low() + 1
    }

    __str__() {
        return "({self.a} .. {self.b})"
    }

    contains?(k) {
        return self ? k
    }

    __match__(x) {
        return x :: (Int | Float) & (self ? x)
    }

    has?(k) {
        return self ? k
    }

    ?(k) {
        return k >= self.low() && k <= self.high()
    }

    __iter__() {
        let a, b = self.a, self.b
        return if a < b {
            a.upto(b - 1)
        } else {
            (a - 1).downto(b)
        }
    }
}

class InclusiveRange : Range {
    __str__() {
        return "({self.a} ... {self.b})"
    }

    __iter__() {
        let a, b = self.a, self.b

        if a < b {
            a.upto(b)
        } else {
            a.downto(b)
        }
    }

    high() {
        max(self.a, self.b)
    }
}

function id(x) { x }

operator ?    5  left
operator **   10 right
operator <<   7  left
operator >>   7  left
operator ^    5  left
operator :>   5  left
