export Some, None, Ok, Err

tag Some {
     map(self, f) {
          return Some(f(self));
     }

     flatMap(self, f) {
          return f(self);
     }
}

tag None {
     map()     { return None; }
     flatMap() { return None; }
}

tag Ok {
     map(self, f) {
          return Ok(f(self));
     }

     flatMap(self, f) {
          return f(self);
     }
}

tag Err {
     map(self)     { return self; }
     flatMap(self) { return self; }
}

class Iter {
    map(I, f) {
        return MapIter(I, f);
    }

    filter(I, f) {
        return FilterIter(I, f);
    }

    list(I) {
        let xs = [];
        while let $x = I.__next__() {
            xs.push(x);
        }
        return xs;
    }

    reverse(I) {
        return ReverseIter(I);
    }
}

class ReverseIter : Iter {
    init(R, I) {
        R.xs = [];
        while let $x = I.__next__() {
            R.xs.push(x);
        }
    }

    __next__(R) {
        if (R.xs)
            return R.xs.pop();
        else
            return nil;
    }
}

class MapIter : Iter {
    init(M, I, f) {
        M.I = I;
        M.f = f;
    }

    __next__(M) {
        if let $n = M.I.__next__() {
            return M.f(n);
        }
    }
}

class FilterIter : Iter {
    init(F, I, p) {
        F.I = I;
        F.p = p;
    }

    __next__(F) {
        while let $n = F.I.__next__() {
            if (F.p(n))
                return n;
        }

        return nil;
    }
}

class RangeIter : Iter {
    init(self, a, b) {
	self.a = a;
	self.b = b;
    }

    __next__(self) {
	if (self.a < self.b) {
	    return self.a++;
	}
    }
}

class Range {
    init(self, a, b) {
	self.a = a;
	self.b = b;
    }

    low(self) {
	return self.a;
    }

    high(self) {
	return self.b;
    }

    __iter__(self) {
	return RangeIter(self.a, self.b);
    }

    list(self) {
	let xs = [];
	for x in self { xs.push(x); }
	return xs;
    }

    __str__(self) {
	return "({self.low()}..{self.high()})";
    }

    contains?(self, k) {
	return k >= self.low() && k < self.high();
    }
}

class InclusiveRange : Range {
    high(self) {
	return self.b + 1;
    }
}
