import bit

export Some, None, Ok, Err, MatchError

tag MatchError;

tag None {
     map()     { return None; }
     flatMap() { return None; }
}

tag Some {
     map(self, f) {
          return Some(f(self));
     }

     flatMap(self, f) {
          return f(self);
     }

    from(x) {
        return match x {
            nil => None,
            _   => Some(x)
        };
    }
}

tag Ok {
     map(self, f) {
          return Ok(f(self));
     }

     flatMap(self, f) {
          return f(self);
     }
}

tag Err {
     map(self)     { return self; }
     flatMap(self) { return self; }
}

class Object {
    init() {
        return object(Object);
    }
}

class Function {
    init() {
        return -> $;
    }

    flip(f) {
        return (a, b) -> f(b, a);
    }
}

class Array {
    init(*xs) {
        return xs;
    }

    sorted?(xs) {
        if (!xs) return true;
        let y = xs[0];
        for x in xs {
            if (x < y) return false;
            y = x;
        }
        return true;
    }

    cycle(xs) {
        let i = 0;
        return Generator(function () {
            return xs[i++ % xs.len()];
        });
    }
}

class Dict {
    init(ks, vs) {
        if (ks && vs) {
            return { k: v for [k, v] in ks.zip(vs) };
        } else {
            return {};
        }
    }

    map(d, f) {
        return { k: f(v) for k, v in d };
    }

    kmap(d, f) {
        return { f(k): v for k, v in d };
    }
}

class String {
    init(x) {
        return str(x);
    }

    repeat(s, n) {
        match s, n {
            $s, $n => {
                let b = blob();
                for _ in ..n { b.push(s); }
                return b.str();
            },
            _ => {
                return Generator(function () {
                    return s;
                });
            }
        }
    }
}

class Int {
    init(x)  { return int(x || 0);           }
    &(a, b)  { return bit::and(a, b);        }
    ^(a, b)  { return bit::xor(a, b);        }
    .|(a, b) { return bit::or(a, b);         }
    <<(a, b) { return bit::shiftLeft(a, b);  }
    >>(a, b) { return bit::shiftRight(a, b); }
}

class Float {
    init(x) {
        return float(x);
    }
}

class Blob {
    init() {
        return blob();
    }
}

class Bool {
    init(x) {
        return !(!x);
    }
}

class Regex {
    init(x)  { return regex(x);    }
    ~=(r, s) { return s.match!(r); }
    ?(r, s)  { return s.match?(r); }
}

class Generator : Iter {
    init(self, f) {
        self.f = f;
    }

    __next__(self) {
        return self.f();
    }
}

class Iterable {
    map(I, f) {
        return I.__iter__().map(f);
    }

    filter(I, f) {
        return I.__iter__().filter(f);
    }

    reverse(I) {
        return I.__iter__().reverse();
    }

    list(I) {
        return [x for x in I];
    }

    take(I, n) {
        return I.__iter__().take(n);
    }

    drop(I, n) {
        return I.__iter__().drop(n);
    }

    set(I) {
        return I.__iter__().set();
    }

    set(I) {
        return I.__iter__().str();
    }
}

class Iter {
    map(I, f) {
        return MapIter(I, f);
    }

    filter(I, f) {
        return FilterIter(I, f);
    }

    list(I) {
        let xs = [];
        while let $x = I.__next__() {
            xs.push(x);
        }
        return xs;
    }

    reverse(I) {
        return ReverseIter(I);
    }

    take(I, n) {
        let i = 0;
        return Generator(function () {
            if (i++ < n) {
                return I.__next__();
            }
        });
    }

    drop(I, n) {
        for _ in ..n { I.__next__(); }
        return I;
    }

    set(I) {
        return { x for x in I };
    }

    str(I) {
        let b = blob();
        for s in I { b.push(str(s)); }
        return b.str();
    }
}

class ReverseIter : Iter {
    init(R, I) {
        R.xs = [];
        while let $x = I.__next__() {
            R.xs.push(x);
        }
    }

    __next__(R) {
        if (R.xs)
            return R.xs.pop();
        else
            return nil;
    }
}

class MapIter : Iter {
    init(M, I, f) {
        M.I = I;
        M.f = f;
    }

    __next__(M) {
        if let $n = M.I.__next__() {
            return M.f(n);
        }
    }
}

class FilterIter : Iter {
    init(F, I, p) {
        F.I = I;
        F.p = p;
    }

    __next__(F) {
        while let $n = F.I.__next__() {
            if (F.p(n))
                return n;
        }

        return nil;
    }
}

class RangeIter : Iter {
    init(R, a, b) {
        R.a = a;
        R.b = b;
    }

    __next__(R) {
        if (R.a < R.b)
            return R.a++;
        else
            return nil;
    }
}

class Range : Iterable {
    init(self, a, b) {
	self.a = a;
	self.b = b;
        self.i = 0;
    }

    low(self) {
	return self.a;
    }

    high(self) {
	return self.b;
    }

    list(self) {
	let xs = [];
	for x in self { xs.push(x); }
	return xs;
    }

    __str__(self) {
	return "({self.low()}..{self.high()})";
    }

    contains?(self, k) {
	return self ? k;
    }

    has?(self, k) {
        return self ? k;
    }

    ?(self, k) {
	return k >= self.low() && k < self.high();
    }

    __iter__(self) {
        return RangeIter(self.low(), self.high());
    }
}

class InclusiveRange : Range {
    high(self) {
	return self.b + 1;
    }
}
