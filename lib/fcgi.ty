import os
import io
import bit (shiftLeft, shiftRight, AND)
import errno
import json

export FCGIApp

let FCGI_LISTENSOCK_FILENO  = 0;

let FCGI_HEADER_LEN         = 8;

let FCGI_VERSION_1          = 1;

let FCGI_BEGIN_REQUEST      = 1;
let FCGI_ABORT_REQUEST      = 2;
let FCGI_END_REQUEST        = 3;
let FCGI_PARAMS             = 4;
let FCGI_STDIN              = 5;
let FCGI_STDOUT             = 6;
let FCGI_STDERR             = 7;
let FCGI_DATA               = 8;
let FCGI_GET_VALUES         = 9;
let FCGI_GET_VALUES_RESULT  = 10;
let FCGI_UNKNOWN_TYPE       = 11;
let FCGI_MAXTYPE            = FCGI_UNKNOWN_TYPE;

let FCGI_NULL_REQUEST_ID    = 0;

let FCGI_KEEP_CONN          = 1;

let FCGI_RESPONDER          = 1;
let FCGI_AUTHORIZER         = 2;
let FCGI_FILTER             = 3;

let FCGI_REQUEST_COMPLETE   = 0;
let FCGI_CANT_MPX_CONN      = 1;
let FCGI_OVERLOADED         = 2;
let FCGI_UNKNOWN_ROLE       = 3;

let FCGI_MAX_CONNS  = "FCGI_MAX_CONNS";
let FCGI_MAX_REQS   = "FCGI_MAX_REQS";
let FCGI_MPXS_CONNS = "FCGI_MPXS_CONNS";

let statusText = %{
    200: 'OK',
    400: 'Bad Request',
    401: 'Unauthorized',
    404: 'Not Found'
}

class FCGIRecord {
    read(f) {
        let r = FCGIRecord();

        r.version = f.next();
        if r.version == nil {
            return nil;
        }

        r.type = f.next();

        r.requestID = nextShort(f);

        let contentLength = nextShort(f);
        let paddingLength = f.next();

        f.next(); /* skip the reserved byte */

        r.content = f.next(contentLength);

        f.next(paddingLength); /* skip padding bytes */

        return r;
    }

    beginRequest() {
        let b = self.content.splice(0, 8);
        self.role = (b[0] << 8) + b[1];
        self.flags = b[2];
        return self;
    }

    getParams() {
        let b = self.content;
        let ps = %{};

        while b.size() != 0 {
            let nameLength = getLength(b);
            let valueLength = getLength(b);
            let name = b.splice(0, nameLength).str();
            let value = b.splice(0, valueLength).str();
            ps[name] = value;
        }

        return self.params = ps;
    }

    readInput() {
        return self.content;
    }
}

function getLength(b) {
    if (b[0] >> 7) == 1 {
        let n = ((b[0] .&. 0x7F) << 24)
              + (b[1] << 16)
              + (b[2] << 8)
              + b[3];
        b.splice(0, 4);
        return n;
    } else {
        let n = b[0];
        b.splice(0, 1);
        return n;
    }
}

function nextShort(f) {
    let B1 = f.next();
    let B0 = f.next();
    if B1 == nil || B0 == nil {
        return nil;
    }
    return (B1 << 8) + B0;
}

function decode(s) {
    return s.sub('+', ' ')
            .sub(/%../, s -> chr(int(s.slice(1), 16)))
            .sub("\r\n", "\n")
            .sub("\r", "\n");
}

function urlDecode(s) {
    let components = s.split('&');
    let pairs = [c.split('=').map(decode) for c in components];
    return %{k: v for [k, v] in pairs};
}

class FCGIRequest {
    init(stream, body, ps) {
        @stream = stream
        self.body = body
        self.params = ps
    }

    sendHTML(html, headers=[], status=200) {
        self.sendResponse(status, html, [('Content-Type', 'text/html'), *headers])
    }

    sendJSON(x, headers=[], status=200) {
        self.sendResponse(status, json.encode(x), [('Content-Type', 'application/json'), *headers])
    }

    sendResponse(status, body='', headers=[]) {
        let buffer = blob()
        let push = buffer.push
        let exitStatus = 0

        let output = blob()

        for (k, v) in headers {
            output.push("{k}: {v}\r\n")
        }

        output.push("Status: {status} {statusText[status]}\r\n\r\n")
        output.push(body)

        let size = #output
        let offset = 0

        while size > 0xFFFF {
            push(FCGI_VERSION_1);
            push(FCGI_STDOUT);
            push(0);
            push(1);
            push(0xFF);
            push(0xFF);
            push(0);
            push(0);
            push(output.slice(offset, 0xFFFF));
            @stream.write(buffer)
            buffer.clear();

            size -= 0xFFFF
            offset += 0xFFFF
        }


        if size > 0 {
            push(FCGI_VERSION_1);
            push(FCGI_STDOUT);
            push(0);
            push(1);
            push(size >> 8);
            push(0xFF .&. size);
            push(0);
            push(0);
            push(output.slice(offset));
            @stream.write(buffer)
            buffer.clear();
        }

        push(FCGI_VERSION_1);
        push(FCGI_STDOUT);
        push(0);
        push(1);
        push(0);
        push(0);
        push(0);
        push(0);
        @stream.write(buffer)
        buffer.clear();

        push(FCGI_VERSION_1);
        push(FCGI_END_REQUEST);
        push(0);
        push(1);
        push(0);
        push(8);
        push(0);
        push(0);
        push((exitStatus >> 24) .&. 0xFF);
        push((exitStatus >> 16) .&. 0xFF);
        push((exitStatus >> 8) .&. 0xFF);
        push(exitStatus .&. 0xFF);
        push(FCGI_REQUEST_COMPLETE);
        push(0);
        push(0);
        push(0);

        @stream.write(buffer)

        @stream.close()
    }

    queryParams() {
        return urlDecode(self.params['QUERY_STRING']);
    }

    formData() {
        if self.params['CONTENT_TYPE'].match?(/^multipart\/form-data/) {
            let [_, delim] = self.body.match!(/^(.*)\r\n/);
            let pattern = regex("{delim}\\r\\n.*name=\"([^\"]+)\"\\r\\n\\r\\n((?:.|\\n)+?)(?=\\r\\n{delim})");
            let fields = self.body.matches(pattern);
            return %{ k: v for [_, k, v] in fields };
        } else if self.params['CONTENT_TYPE'].match?(/^application\/x-www-form-urlencoded/) {
            return urlDecode(self.body);
        } else {
            return urlDecode(self.params['QUERY_STRING']);
        }
    }
}

class FCGIApp {
    init(socket) {
        self.socket = socket;
    }

    waitRequest(keepTrying: Bool = false) {
        if not let ($fd, addr) = os.accept(self.socket) {
            if keepTrying && errno.get() == errno.EINTR {
                return self.waitRequest()
            } else {
                return nil
            }
        }

        let stream = io.open(fd, 'r+')

        let body = blob()
        let params = %{}

        while let $r = FCGIRecord.read(stream) {
            match r.type {
                ::FCGI_BEGIN_REQUEST => {
                    let role, flags = r.beginRequest()
                },

                ::FCGI_PARAMS => {
                    params += r.getParams()
                },

                ::FCGI_STDIN => {
                    let input = r.readInput();
                    if input.size() == 0 {
                        break;
                    } else {
                        body.push(input);
                    }
                },

                t => { print("Type = {t}") }
            }
        }

        return FCGIRequest(stream, body.str(), params);
    }

    requests() {
        while let $r = self.waitRequest() {
            yield r
        }
    }
}
