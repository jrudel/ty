export make, opt, flag

let bools = %{
	'true': true,
	'false': false,

	'on': true,
	'off': false,

	'yes': true,
	'no': false
}

function opt(short, long, pre=true, post=true, convert=id, multi=false, help='') {
    return {
        short,
        long,
        pre,
        post,
        convert,
        multi,
		help,
        type: 'o',
    }
}

function flag(short, long, help='') {
    return {
        short,
        long,
		help,
        type: 'f'
    }
}

function add(opt, result, value) {
    for o in [opt.short, opt.long].remove!(nil) {
        if opt.multi {
            result[o] = result[o] ?? []
            result[o].push(value)
        } else {
            result[o] = value
        }
    }
}

function make(*opts) {
    return function (argv) {
        let result = %{}
        let i = 0

        function next() {
            if i == #argv {
                throw "Expected argument after {argv[i - 1]}"
            }
            return argv[i++]
        }

        while i < #argv {
            let arg = next()
            match arg {
                '--' => {
                    break
                },

				_ :: ('-h' | '--help') => {
					let [flags, opts] = opts.partition(o -> o.type == 'f')

					if #opts > 0 {
						print('Options')
						print()

						let optStrings = [
							["-{opt.short}" if opt.short, "--{opt.long}" if opt.long].join(', ')
							for opt in opts
						]

						let maxWidth = optStrings.map(&len).max()

						for (opt, s) in opts.zip(optStrings) {
							print("  {s.padRight(maxWidth)}    {opt.help}")
						}

						print()
					}

					if #flags > 0 {
						print('Flags')
						print()

						let flagStrings = [
							["-{flag.short}" if flag.short, "--{flag.long}" if flag.long].join(', ')
							for flag in flags
						]

						let maxWidth = flagStrings.map(&len).max()

						for (flag, s) in flags.zip(flagStrings) {
							print("  {s.padRight(maxWidth)}    {flag.help}")
						}

						print()
					}

				},

                /^--([^=]+)$/ => {
                    if let $opt = opts.filter(o -> o.type == 'f').find(&.long |> (== _1)) {
                        if opt.long  { result << opt.long  }
                        if opt.short { result << opt.short }
                    } else {
                        throw "Unrecognized flag: {_0}"
                    }
                },
                /^--([^=]+)=(.+)/ => {
                    if let $opt = opts.filter(o -> o.type == 'o').find(&.long |> (== _1)) {
                        if !(_2 :: opt.pre) {
                            throw "Invalid value for {_1}: {_2}"
                        }
                        let value = (opt.convert)(_2)
                        if !(value :: opt.post) {
                            throw "Invalid value for {_1}: {_2}"
                        }
                        add(opt, result, value)
                    } else {
                        throw "Unrecognized option: {_1}"
                    }
                },
                /^-(.+)/ => {
                    if not let $opt = opts.find(&.short |> (== _1[0])) {
                        throw "Unrecognized option: {_0}"
                    }

                    if opt.type == 'o' {
                        let s = if #_1 == 1 {
                            next()
                        } else {
                            _1.slice(1)
                        }

                        if !(s :: opt.pre) {
                            throw "Invalid value for {opt.long ?? _1[0]}: {s}"
                        }

                        let value = (opt.convert)(s)

                        if !(value :: opt.post) {
                            throw "Invalid value for {opt.long ?? _1[0]}: {s}"
                        }

                        add(opt, result, value)
                    } else {
                        for c in _1 {
                            if let $opt = opts.filter(&.type |> (== 'f')).find(&.short |> (== c)) {
                                if opt.short { result << opt.short }
                                if opt.long  { result << opt.long  }
                            } else {
                                throw "Unrecognized flag: {c}"
                            }
                        }
                    }
                },

                _ => {
                    break
                }
            }
        }

		argv.slice!(0, i)

        return result
    }
}
