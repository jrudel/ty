import ffi as c
import cutil (wrap)
import os

let libName = 'libllhttp.so'

let HTTP_BOTH      = 0
let HTTP_REQUEST   = 1
let HTTP_RESPONSE  = 2

let F_CONNECTION_KEEP_ALIVE = 0x1
let F_CONNECTION_CLOSE = 0x2
let F_CONNECTION_UPGRADE = 0x4
let F_CHUNKED = 0x8
let F_UPGRADE = 0x10
let F_CONTENT_LENGTH = 0x20
let F_SKIPBODY = 0x40
let F_TRAILING = 0x80
let F_TRANSFER_ENCODING = 0x200

let HTTP_DELETE = 0
let HTTP_GET = 1
let HTTP_HEAD = 2
let HTTP_POST = 3
let HTTP_PUT = 4
let HTTP_CONNECT = 5
let HTTP_OPTIONS = 6
let HTTP_TRACE = 7
let HTTP_COPY = 8
let HTTP_LOCK = 9
let HTTP_MKCOL = 10
let HTTP_MOVE = 11
let HTTP_PROPFIND = 12
let HTTP_PROPPATCH = 13
let HTTP_SEARCH = 14
let HTTP_UNLOCK = 15
let HTTP_BIND = 16
let HTTP_REBIND = 17
let HTTP_UNBIND = 18
let HTTP_ACL = 19
let HTTP_REPORT = 20
let HTTP_MKACTIVITY = 21
let HTTP_CHECKOUT = 22
let HTTP_MERGE = 23
let HTTP_MSEARCH = 24
let HTTP_NOTIFY = 25
let HTTP_SUBSCRIBE = 26
let HTTP_UNSUBSCRIBE = 27
let HTTP_PATCH = 28
let HTTP_PURGE = 29
let HTTP_MKCALENDAR = 30
let HTTP_LINK = 31
let HTTP_UNLINK = 32
let HTTP_SOURCE = 33
let HTTP_PRI = 34
let HTTP_DESCRIBE = 35
let HTTP_ANNOUNCE = 36
let HTTP_SETUP = 37
let HTTP_PLAY = 38
let HTTP_PAUSE = 39
let HTTP_TEARDOWN = 40
let HTTP_GET_PARAMETER = 41
let HTTP_SET_PARAMETER = 42
let HTTP_REDIRECT = 43
let HTTP_RECORD = 44
let HTTP_FLUSH = 45

let HPE_OK = 0
let HPE_INTERNAL = 1
let HPE_STRICT = 2
let HPE_LF_EXPECTED = 3
let HPE_UNEXPECTED_CONTENT_LENGTH = 4
let HPE_CLOSED_CONNECTION = 5
let HPE_INVALID_METHOD = 6
let HPE_INVALID_URL = 7
let HPE_INVALID_CONSTANT = 8
let HPE_INVALID_VERSION = 9
let HPE_INVALID_HEADER_TOKEN = 10
let HPE_INVALID_CONTENT_LENGTH = 11
let HPE_INVALID_CHUNK_SIZE = 12
let HPE_INVALID_STATUS = 13
let HPE_INVALID_EOF_STATE = 14
let HPE_INVALID_TRANSFER_ENCODING = 15
let HPE_CB_MESSAGE_BEGIN = 16
let HPE_CB_HEADERS_COMPLETE = 17
let HPE_CB_MESSAGE_COMPLETE = 18
let HPE_CB_CHUNK_HEADER = 19
let HPE_CB_CHUNK_COMPLETE = 20
let HPE_PAUSED = 21
let HPE_PAUSED_UPGRADE = 22
let HPE_PAUSED_H2_UPGRADE = 23
let HPE_USER = 24

if not let $lib = c.dlopen(libName) {
    throw "Failed to load {libName}"
}

let llhttp_settings_t = c.struct(
  /* Possible return values 0, -1, `HPE_PAUSED` */
  /* 0 */  c.ptr, // llhttp_cb      on_message_begin;

  /* Possible return values 0, -1, HPE_USER */
  /* 1 */  c.ptr, // llhttp_data_cb on_url;
  /* 2 */  c.ptr, // llhttp_data_cb on_status;
  /* 3 */  c.ptr, // llhttp_data_cb on_header_field;
  /* 4 */  c.ptr, // llhttp_data_cb on_header_value;

  /* Possible return values:
   * 0  - Proceed normally
   * 1  - Assume that request/response has no body, and proceed to parsing the
   *      next message
   * 2  - Assume absence of body (as above) and make `llhttp_execute()` return
   *      `HPE_PAUSED_UPGRADE`
   * -1 - Error
   * `HPE_PAUSED`
   */
   /* 5 */ c.ptr, // llhttp_cb      on_headers_complete;

  /* Possible return values 0, -1, HPE_USER */
  /* 6 */ c.ptr, // llhttp_data_cb on_body;

  /* Possible return values 0, -1, `HPE_PAUSED` */
  /* 7 */ c.ptr, // llhttp_cb      on_message_complete;

  /* When on_chunk_header is called, the current chunk length is stored
   * in parser->content_length.
   * Possible return values 0, -1, `HPE_PAUSED`
   */
  /* 8 */ c.ptr, // llhttp_cb      on_chunk_header;
  /* 9 */ c.ptr, // llhttp_cb      on_chunk_complete;

  /* Information-only callbacks, return value is ignored */
  /* 10 */ c.ptr, // llhttp_cb      on_url_complete;
  /* 11 */ c.ptr, // llhttp_cb      on_status_complete;
  /* 12 */ c.ptr, // llhttp_cb      on_header_field_complete;
  /* 13 */ c.ptr // llhttp_cb      on_header_value_complete;
)

let llhttp_internal = c.struct(
  c.i32, // int32_t _index;
  c.ptr, // void* _span_pos0;
  c.ptr, // void* _span_cb0;
  c.u32, // int32_t error;
  c.ptr, // const char* reason;
  c.ptr, // const char* error_pos;
  c.ptr, // void* data;
  c.ptr, // void* _current;
  c.u64, // uint64_t content_length;
  c.u8,  // uint8_t type;
  c.u8,  // uint8_t method;
  c.u8,  // uint8_t http_major;
  c.u8,  // uint8_t http_minor;
  c.u8,  // uint8_t header_state;
  c.u8,  // uint8_t lenient_flags;
  c.u8,  // uint8_t upgrade;
  c.u8,  // uint8_t finish;
  c.u16, // uint16_t flags;
  c.u16, // uint16_t status_code;
  c.ptr  // void* settings;
)

let llhttp_init = wrap(lib, 'llhttp_init', c.void, c.ptr, c.int, c.ptr)
let llhttp_reset = wrap(lib, 'llhttp_reset', c.void, c.ptr)
let llhttp_settings_init = wrap(lib, 'llhttp_settings_init', c.void, c.ptr)
let llhttp_execute = wrap(lib, 'llhttp_execute', c.int, c.ptr, c.ptr, c.u64)
let llhttp_resume = wrap(lib, 'llhttp_execute', c.void, c.ptr)
let llhttp_method_name = wrap(lib, 'llhttp_method_name', c.ptr, c.u8)
let llhttp_errno_name = wrap(lib, 'llhttp_errno_name', c.ptr, c.int)

let llhttp_get_method = parser -> c.member(llhttp_internal, parser, 10)
let llhttp_get_flags = parser -> c.member(llhttp_internal, parser, 17)

let llhttp_content_length = parser -> {
	if llhttp_get_flags(parser) .&. F_CONTENT_LENGTH {
		c.member(llhttp_internal, parser, 8)
	}
}

let onMessageComplete = (parser) -> {
	print("Message complete")
	return 0
}

let onMessageBegin = (parser) -> {
	print("Message begin")
	return 0
}

let printData = (parser, data, len) -> {
	print("Data = '{c.as_str(data, len)}'")
	return 0
}

let onHeaderField = (parser, data, len) -> {
}

class HttpParser {
	init() {
        @requests = []
        @b = Blob()

        self.reset()

        @settings = c.new(llhttp_settings_t)
        llhttp_settings_init(@settings)

        @parser = c.new(llhttp_internal)
        llhttp_init(@parser, HTTP_BOTH, @settings)

        //c.member(llhttp_settings_t, @settings, 0, c.closure(c.cif(c.int, c.ptr), onMessageBegin))

        c.member(llhttp_settings_t, @settings, 1, c.closure(c.cif(c.int, c.ptr, c.ptr, c.u64), self.onData))
        c.member(llhttp_settings_t, @settings, 2, c.closure(c.cif(c.int, c.ptr, c.ptr, c.u64), self.onData))
        c.member(llhttp_settings_t, @settings, 3, c.closure(c.cif(c.int, c.ptr, c.ptr, c.u64), self.onData))
        c.member(llhttp_settings_t, @settings, 4, c.closure(c.cif(c.int, c.ptr, c.ptr, c.u64), self.onData))
        c.member(llhttp_settings_t, @settings, 6, c.closure(c.cif(c.int, c.ptr, c.ptr, c.u64), self.onData))

        //c.member(llhttp_settings_t, @settings, 5, c.closure(c.cif(c.int, c.ptr), onHeadersComplete))

        c.member(llhttp_settings_t, @settings, 10, c.closure(c.cif(c.int, c.ptr), self.onURLComplete))
        c.member(llhttp_settings_t, @settings, 12, c.closure(c.cif(c.int, c.ptr), self.onHeaderFieldComplete))
        c.member(llhttp_settings_t, @settings, 13, c.closure(c.cif(c.int, c.ptr), self.onHeaderValueComplete))

        c.member(llhttp_settings_t, @settings, 7, c.closure(c.cif(c.int, c.ptr), self.onMessageComplete))
	}

    reset() {
        @headers = %{}
        @url = nil
    }

	onHeaderFieldComplete(parser) {
		@headerField = @b.str()
		@b.clear()
	}

	onHeaderValueComplete(parser) {
		let headerValue = @b.str()
		@b.clear()

		match @headers[@headerField] {
			nil         => @headers[@headerField] = headerValue,
			vs :: Array => vs.push(headerValue),
			v           => @headers[@headerField] = [v, headerValue]
		}
	}

	onURLComplete(parser) {
		@url = @b.str()
		@b.clear()
	}

	onData(parser, data, len) {
		@b.push(c.as_str(data, len))
		return HPE_OK
	}

	onMessageComplete(parser) {
		let method = c.str(llhttp_method_name(llhttp_get_method(parser)))
        let body = nil

        if @b.size() > 0 {
            body, @b = @b, Blob()
        }

        @requests.push({
            method,
            url: @url
            headers: @headers,
            body
        })

        self.reset()

        return HPE_OK
	}

    push(data) {
        @err = llhttp_execute(@parser, data, data.size())
    }

    takeRequests() {
        @requests.slice!(0)
    }

    iterRequests() {
        for request in @requests {
            yield request
        }

        @requests = []
    }

	numRequests() {
		@requests.len()
	}

    error() {
        c.as_str(llhttp_errno_name(@err))
    }
}
