import ffi as c
import ty
import ty.token (next, peek)
import ty.parse (expr)

export iter, wrap, memcpy, strlen, memcmp, strcmp, memset

function wrap(lib, name, rType, *aTypes) {
    if not let $fp = c.dlsym(name, lib) {
        throw Err("Failed to load symbol '{name}'")
    }

    let interface = c.cif(rType, *aTypes)
    let argStorage = [c.new(t) for t in aTypes]

    return function (*args) {
        for arg, i in args {
            c.store(aTypes[i], argStorage[i], arg)
        }
        c.call(interface, fp, *argStorage)
    }
}

function iter(type, p, n) {
    let size = c.size(type)
    for i in ..n {
        yield c.load(type, p + i*size)
    }
}

let memcpy = wrap(nil, 'memcpy', c.ptr, c.ptr, c.ptr, c.u64)
let strlen = wrap(nil, 'strlen', c.u64, c.ptr)
let memcmp = wrap(nil, 'memcmp', c.int, c.ptr, c.ptr, c.u64)
let strcmp = wrap(nil, 'strcmp', c.int, c.ptr, c.ptr)
let memset = wrap(nil, 'memset', c.void, c.ptr, c.int, c.u64)

pub function cstr(s) {
    let p = c.alloc(s.size() + 1)

    memcpy(p, s, s.size())
    c.store(c.char, p + s.size(), 0)

    return p
}

pub macro cfun! {
    let public = peek().type == 'pub'
    if public { next() }

    let lib = expr(0)
    let rt = expr(0)

    let name = next().id

    // (
    next()

    let args = [ty.Arg(arg: lib), ty.Arg(arg: ty.String(name)), ty.Arg(arg: rt)]

    while peek().type != ')' {
        args.push(ty.Arg(arg: expr(0)))
        if peek().type == ',' {
            next()
        }
    }

    // )
    next()

    ty.Let(ty.Id(name: name), ty.Call(func: ty.Value(wrap), args: args), public: public)
}

pub macro struct! {
    let structName = next().id

    let ty.Record(struct) = expr(99)

    let init = ty.Func(
        name: 'init',
        params: [ty.Param(name: '<p>')],
        body: ty.Assign(
            ty.MemberAccess(ty.Id(name: 'self'), '<p>'),
            ty.Wtf(
                ty.Id(name: '<p>'),
                ty.Call(
                    func: ty.Id(name: 'new', module: 'c'),
                    args: [ty.Arg(arg: ty.Id(name: "{structName}_C"))]
                )
            )
        )
    )

    let get = ty.Func(
        name: 'get',
        params: [],
        body: ty.MemberAccess(ty.Id(name: 'self'), '<p>')
    )

    let structArgs = []
    let methods = []

    for entry, i in struct {
        let ty.RecordEntry({name, item}) = entry
        structArgs.push(ty.Arg(arg: item))
        methods.push(
            ty.Func(
                name: name,
                params: [ty.Gather('args')],
                body: ty.Call(
                    func: ty.Id(name: 'member', module: 'c'),
                    args: [
                        ty.Arg(arg: ty.Id(name: "{structName}_C")),
                        ty.Arg(arg: ty.MemberAccess(ty.Id(name: 'self'), '<p>')),
                        ty.Arg(arg: ty.Int(i)),
                        ty.Arg(arg: ty.Spread(ty.Id(name: 'args')))
                    ]
                )
            )
        )
    }

    ty.Multi([
        ty.Let(
            ty.Id(name: "{structName}_C"),
            ty.Call(
                func: ty.Id(name: 'struct', module: 'c'),
                args: structArgs
            )
        ),
        ty.Class(
            name: structName,
            methods: [get, init, *methods]
        )
    ])
}
