cscope 15 $HOME/ty/src -c -q 0000001680 0000357285
	@alloc.c

1 #include 
	~"alloc.h
"

2 #include 
	~"panic.h
"

4 #include 
	~<string.h
>

7 
	$alloc
(
size_t
 
n
)

9 void *
mem
 = 
	`malloc
(
n
);

10 if (
mem
 == 
NULL
) {

11 
	`panic
("out of memory");

14 return 
mem
;

15 
	}
}

	@array.c

1 #include 
	~<stdlib.h
>

2 #include 
	~<string.h
>

4 #include 
	~"value.h
"

5 #include 
	~"dict.h
"

6 #include 
	~"log.h
"

7 #include 
	~"functions.h
"

8 #include 
	~"operators.h
"

9 #include 
	~"util.h
"

10 #include 
	~"vm.h
"

12 static struct 
value
 *
	gcomparison_fn
;

15 
	$compare_by
(void const *
v1
, void const *
v2
)

17 struct 
value
 
k1
 = 
	`value_apply_callable
(
comparison_fn
, (struct value *)
v1
);

18 
	`gc_push
(&
k1
);

20 struct 
value
 
k2
 = 
	`value_apply_callable
(
comparison_fn
, (struct value *)
v2
);

21 
	`gc_push
(&
k2
);

23 int 
result
 = 
	`value_compare
(&
k1
, &
k2
);

25 
	`gc_pop
();

26 
	`gc_pop
();

28 return 
result
;

29 
	}
}

32 
	$compare_by2
(void const *
v1
, void const *
v2
)

34 struct 
value
 
v
 = 
	`vm_eval_function2
(
comparison_fn
, (struct value *)
v1
, (struct value *)
v2
);

35 
	`gc_push
(&
v
);

37 int 
result
;

39 if (
v
.
type
 == 
VALUE_INTEGER
)

40 
result
 = 
v
.
integer
;

42 
result
 = 
	`value_truthy
(&
v
) ? 1 : -1;

44 
	`gc_pop
();

46 return 
result
;

47 
	}
}

49 
inline
 static void

50 
	$shrink
(struct 
value
 *
array
)

52 if (
array
->array->
capacity
 > 8 * array->array->
count
 || (array->array->capacity - array->array->count) > 1000) {

53 
array
->array->
capacity
 = array->array->
count
;

54 if (
array
->array->
count
 == 0)

55 
	`free
(
array
->array->
items
), array->array->items = 
NULL
;

57 
	`resize
(
array
->array->
items
, array->array->
count
 * sizeof (struct 
value
));

59 
	}
}

61 static struct 
value


62 
	$array_push
(struct 
value
 *
array
, 
value_vector
 *
args
)

64 if (
args
->
count
 != 1)

65 
	`vm_panic
("the push method on arrays expects 1 argument but got %zu", 
args
->
count
);

67 
	`value_array_push
(
array
->array, 
args
->
items
[0]);

69 return 
NIL
;

70 
	}
}

72 static struct 
value


73 
	$array_insert
(struct 
value
 *
array
, 
value_vector
 *
args
)

75 if (
args
->
count
 != 2)

76 
	`vm_panic
("the insert method on arrays expects 2 arguments but got %zu", 
args
->
count
);

78 struct 
value
 
i
 = 
args
->
items
[0];

79 struct 
value
 
v
 = 
args
->
items
[1];

81 if (
i
.
type
 != 
VALUE_INTEGER
)

82 
	`vm_panic
("non-integer passed as the index to the insert method on array");

84 int 
index
 = 
i
.
integer
;

86 if (
index
 < 0)

87 
index
 += 
array
->array->
count
 + 1;

88 if (
index
 < 0 || index > 
array
->array->
count
)

89 
	`vm_panic
("array index passed to insert is out of range: %d", 
index
);

91 
	`value_array_push
(
array
->array, 
NIL
);

93 
	`memmove
(
array
->array->
items
 + 
index
 + 1, array->array->items + index, (array->array->
count
 - index - 1) * sizeof (struct 
value
));

94 
array
->array->
items
[
index
] = 
v
;

96 return *
array
;

97 
	}
}

99 static struct 
value


100 
	$array_pop
(struct 
value
 *
array
, 
value_vector
 *
args
)

102 struct 
value
 
result
;

104 if (
args
->
count
 == 0) {

105 if (
array
->array->
count
 == 0)

106 
	`vm_panic
("attempt to pop from an empty array");

107 
result
 = 
array
->array->
items
[--array->array->
count
];

108 } else if (
args
->
count
 == 1) {

109 struct 
value
 
arg
 = 
args
->
items
[0];

110 if (
arg
.
type
 != 
VALUE_INTEGER
)

111 
	`vm_panic
("the argument to pop must be an integer");

112 if (
arg
.
integer
 < 0)

113 
arg
.
integer
 += 
array
->array->
count
;

114 if (
arg
.
integer
 < 0 || arg.integer >= 
array
->array->
count
)

115 
	`vm_panic
("array index passed to pop is out of range");

116 
	`vec_pop_ith
(*
array
->array, 
arg
.
integer
, 
result
);

118 
	`vm_panic
("the pop method on arrays expects 0 or 1 argument(s) but got %zu", 
args
->
count
);

121 
	`shrink
(
array
);

123 return 
result
;

124 
	}
}

126 static struct 
value


127 
	$array_swap
(struct 
value
 *
array
, 
value_vector
 *
args
)

129 if (
args
->
count
 != 2)

130 
	`vm_panic
("array.swap() expects 2 arguments but got %zu", 
args
->
count
);

132 struct 
value
 
i
 = 
args
->
items
[0];

133 struct 
value
 
j
 = 
args
->
items
[1];

135 if (
i
.
type
 != 
VALUE_INTEGER
 || 
j
.type != VALUE_INTEGER)

136 
	`vm_panic
("the arguments to array.swap() must be integers");

138 if (
i
.
integer
 < 0)

139 
i
.
integer
 += 
array
->array->
count
;

141 if (
j
.
integer
 < 0)

142 
j
.
integer
 += 
array
->array->
count
;

144 if (
i
.
integer
 < 0 || i.integer >= 
array
->array->
count


145 || 
j
.
integer
 < 0 || j.integer >= 
array
->array->
count
) {

146 
	`vm_panic
("invalid indices passed to array.swap(): (%d, %d)", (int) 
i
.
integer
, (int) 
j
.integer);

149 struct 
value
 
tmp
 = 
array
->array->
items
[
i
.
integer
];

150 
array
->array->
items
[
i
.
integer
] = array->array->items[
j
.integer];

151 
array
->array->
items
[
j
.
integer
] = 
tmp
;

153 return *
array
;

154 
	}
}

156 static struct 
value


157 
	$array_slice_mut
(struct 
value
 *
array
, 
value_vector
 *
args
)

159 if (
args
->
count
 != 2)

160 
	`vm_panic
("array.slice!() expects 2 arguments but got %zu", 
args
->
count
);

162 struct 
value
 
start
 = 
args
->
items
[0];

163 struct 
value
 
count
 = 
args
->
items
[1];

165 if (
start
.
type
 != 
VALUE_INTEGER
)

166 
	`vm_panic
("non-integer passed as first argument to array.slice!()");

168 if (
count
.
type
 != 
VALUE_INTEGER
)

169 
	`vm_panic
("non-integer passed as second argument to array.slice!()");

171 int 
s
 = 
start
.
integer
;

172 int 
n
 = 
count
.
integer
;

174 if (
s
 < 0)

175 
s
 += 
array
->array->
count
;

176 if (
s
 < 0)

177 
	`vm_panic
("start index passed to array.slice!() is out of range");

179 
s
 = 
	`min
(s, 
array
->array->
count
);

180 
n
 = 
	`min
(n, 
array
->array->
count
 - 
s
);

182 
	`memmove
(
array
->array->
items
, array->array->items + 
s
, 
n
 * sizeof (struct 
value
));

183 
array
->array->
count
 = 
n
;

185 
	`shrink
(
array
);

187 return *
array
;

188 
	}
}

190 static struct 
value


191 
	$array_zip
(struct 
value
 *
array
, 
value_vector
 *
args
)

193 if (
args
->
count
 != 1)

194 
	`vm_panic
("array.zip() expects 1 argument but got %zu", 
args
->
count
);

196 struct 
value
 
other
 = 
args
->
items
[0];

197 if (
other
.
type
 != 
VALUE_ARRAY
)

198 
	`vm_panic
("the argument to array.zip() must be an array");

200 int 
n
 = 
	`min
(
array
->array->
count
, 
other
.array->count);

202 struct 
value
 
a
;

203 
	`gc_push
(&
a
);

205 for (int 
i
 = 0; i < 
n
; ++i) {

206 
a
 = 
	`ARRAY
(
	`value_array_new
());

207 
	`vec_push
(*
a
.
array
, array->array->
items
[
i
]);

208 
	`vec_push
(*
a
.
array
, 
other
.array->
items
[
i
]);

209 
array
->array->
items
[
i
] = 
a
;

212 
	`gc_pop
();

217 
array
->array->
count
 = 
n
;

218 
	`shrink
(
array
);

220 return *
array
;

221 
	}
}

223 static struct 
value


224 
	$array_zip_with
(struct 
value
 *
array
, 
value_vector
 *
args
)

226 if (
args
->
count
 != 2)

227 
	`vm_panic
("array.zipWith() expects 2 arguments but got %zu", 
args
->
count
);

229 struct 
value
 
f
 = 
args
->
items
[0];

230 if (!
	`CALLABLE
(
f
))

231 
	`vm_panic
("the first argument to array.zipWith() must be callable");

233 struct 
value
 
other
 = 
args
->
items
[1];

234 if (
other
.
type
 != 
VALUE_ARRAY
)

235 
	`vm_panic
("the argument to array.zip() must be an array");

237 int 
n
 = 
	`min
(
array
->array->
count
, 
other
.array->count);

239 struct 
value
 
a
;

240 
	`gc_push
(&
a
);

242 for (int 
i
 = 0; i < 
n
; ++i) {

243 
a
 = 
	`vm_eval_function2
(&
f
, &
array
->array->
items
[
i
], &
other
.array->items[i]);

244 
array
->array->
items
[
i
] = 
a
;

247 
	`gc_pop
();

252 
array
->array->
count
 = 
n
;

253 
	`shrink
(
array
);

255 return *
array
;

256 
	}
}

258 static struct 
value


259 
	$array_map_cons
(struct 
value
 *
array
, 
value_vector
 *
args
)

261 if (
args
->
count
 != 2)

262 
	`vm_panic
("array.mapCons() expects 2 arguments but got %zu", 
args
->
count
);

264 struct 
value
 
k
 = 
args
->
items
[0];

265 if (
k
.
type
 != 
VALUE_INTEGER
)

266 
	`vm_panic
("the first argument to array.mapCons() must be an integer");

268 if (
k
.
integer
 <= 0)

269 
	`vm_panic
("the first argument to array.mapCons() must be positive");

271 struct 
value
 
f
 = 
args
->
items
[1];

272 if (!
	`CALLABLE
(
f
))

273 
	`vm_panic
("the second argument to array.mapCons() must be callable");

275 int 
n
 = 
array
->array->
count
 - 
k
.
integer
 + 1;

277 struct 
value
 
sub
 = 
NIL
;

278 
	`gc_push
(&
sub
);

280 for (int 
i
 = 0; i < 
n
; ++i) {

281 
sub
 = 
	`ARRAY
(
	`value_array_new
());

282 
	`vec_push_n
(*
sub
.
array
, array->array->
items
 + 
i
, 
k
.
integer
);

283 
array
->array->
items
[
i
] = 
	`value_apply_callable
(&
f
, &
sub
);

286 
	`gc_pop
();

288 
array
->array->
count
 = 
n
;

289 
	`shrink
(
array
);

291 return *
array
;

292 
	}
}

294 static struct 
value


295 
	$array_slice
(struct 
value
 *
array
, 
value_vector
 *
args
)

297 if (
args
->
count
 != 2)

298 
	`vm_panic
("array.slice() expects 2 arguments but got %zu", 
args
->
count
);

300 struct 
value
 
start
 = 
args
->
items
[0];

301 struct 
value
 
count
 = 
args
->
items
[1];

303 if (
start
.
type
 != 
VALUE_INTEGER
)

304 
	`vm_panic
("non-integer passed as first argument to array.slice()");

306 if (
count
.
type
 != 
VALUE_INTEGER
)

307 
	`vm_panic
("non-integer passed as second argument to array.slice()");

309 int 
s
 = 
start
.
integer
;

310 int 
n
 = 
count
.
integer
;

312 if (
s
 < 0)

313 
s
 += 
array
->array->
count
;

314 if (
s
 < 0)

315 
	`vm_panic
("start index passed to array.slice() is out of range");

317 
s
 = 
	`min
(s, 
array
->array->
count
);

318 
n
 = 
	`min
(n, 
array
->array->
count
 - 
s
);

320 struct 
value
 
result
 = 
	`ARRAY
(
	`value_array_new
());

321 
	`NOGC
(
result
.
array
);

322 
	`value_array_reserve
(
result
.
array
, 
n
);

323 
	`OKGC
(
result
.
array
);

324 
	`memmove
(
result
.
array
->
items
, array->array->items + 
s
, 
n
 * sizeof (struct 
value
));

325 
result
.
array
->
count
 = 
n
;

327 return 
result
;

328 
	}
}

330 static struct 
value


331 
	$array_sort
(struct 
value
 *
array
, 
value_vector
 *
args
)

333 int 
i
;

334 int 
n
;

336 switch (
args
->
count
) {

338 
i
 = 0;

339 
n
 = 
array
->array->
count
;

342 if (
args
->
items
[1].
type
 != 
VALUE_INTEGER
)

343 
	`vm_panic
("the second argument to array.sort() must be an integer");

344 
n
 = 
args
->
items
[1].
integer
;

346 if (
args
->
items
[0].
type
 != 
VALUE_INTEGER
)

347 
	`vm_panic
("the first argument to array.sort() must be an integer");

348 
i
 = 
args
->
items
[0].
integer
;

349 if (
args
->
count
 == 1)

350 
n
 = 
array
->array->
count
 - 
i
;

353 
	`vm_panic
("array.sort() expects 0, 1, or 2 arguments but got %zu", 
args
->
count
);

356 if (
i
 < 0)

357 
i
 += 
array
->array->
count
;

359 if (
n
 < 0 || 
i
 < 0 || i + n > 
array
->array->
count
)

360 
	`vm_panic
("invalid index passed to array.sort()");

362 
	`qsort
(
array
->array->
items
 + 
i
, 
n
, sizeof (struct 
value
), 
value_compare
);

364 return *
array
;

365 
	}
}

367 static struct 
value


368 
	$array_next_permutation
(struct 
value
 *
array
, 
value_vector
 *
args
)

370 #define 
	#CMP
(
i
, 
j
) 
	`value_compare
(&
array
->array->
items
[i], &array->array->items[j])

	)

371 if (
args
->
count
 != 0)

372 
	`vm_panic
("array.nextPermutation() expects no arguments but got %zu", 
args
->
count
);

374 for (int 
i
 = 
array
->array->
count
 - 1; i > 0; --i) {

375 if (
	`CMP
(
i
 - 1, i) < 0) {

376 int 
j
 = 
i
;

377 for (int 
k
 = 
i
 + 1; k < 
array
->array->
count
; ++k)

378 if (
	`CMP
(
k
, 
j
) < 0 && CMP(k, 
i
 - 1) > 0)

379 
j
 = 
k
;

381 struct 
value
 
t
 = 
array
->array->
items
[
i
 - 1];

382 
array
->array->
items
[
i
 - 1] = array->array->items[
j
];

383 
array
->array->
items
[
j
] = 
t
;

385 
	`array_sort
(
array
, &(
value_vector
){ .
count
 = 1, .
items
 = &
	`INTEGER
(
i
) });

387 return *
array
;

391 return 
NIL
;

392 #undef 
CMP


393 
	}
}

395 static struct 
value


396 
	$array_take_while_mut
(struct 
value
 *
array
, 
value_vector
 *
args
)

398 if (
args
->
count
 != 1)

399 
	`vm_panic
("array.takeWhile!() expects 1 argument but got %zu", 
args
->
count
);

401 struct 
value
 
f
 = 
args
->
items
[0];

403 if (!
	`CALLABLE
(
f
))

404 
	`vm_panic
("non-callable predicate passed to array.takeWhile!()");

406 int 
keep
 = 0;

407 for (int 
i
 = 0; i < 
array
->array->
count
; ++i) {

408 if (
	`value_apply_predicate
(&
f
, &
array
->array->
items
[
i
]))

409 ++
keep
;

414 
array
->array->
count
 = 
keep
;

415 
	`shrink
(
array
);

417 return *
array
;

418 
	}
}

420 static struct 
value


421 
	$array_take_while
(struct 
value
 *
array
, 
value_vector
 *
args
)

423 if (
args
->
count
 != 1)

424 
	`vm_panic
("array.takeWhile!() expects 1 argument but got %zu", 
args
->
count
);

426 struct 
value
 
f
 = 
args
->
items
[0];

428 if (!
	`CALLABLE
(
f
))

429 
	`vm_panic
("non-callable predicate passed to array.takeWhile!()");

431 int 
keep
 = 0;

432 for (int 
i
 = 0; i < 
array
->array->
count
; ++i)

433 if (
	`value_apply_predicate
(&
f
, &
array
->array->
items
[
i
]))

434 ++
keep
;

438 struct 
value
 
result
 = 
	`ARRAY
(
	`value_array_new
());

439 
	`NOGC
(
result
.
array
);

440 
	`value_array_reserve
(
result
.
array
, 
keep
);

441 
	`OKGC
(
result
.
array
);

442 
	`memmove
(
result
.
array
->
items
, array->array->items, 
keep
 * sizeof (struct 
value
));

443 
result
.
array
->
count
 = 
keep
;

445 return 
result
;

446 
	}
}

448 static struct 
value


449 
	$array_drop_while_mut
(struct 
value
 *
array
, 
value_vector
 *
args
)

451 if (
args
->
count
 != 1)

452 
	`vm_panic
("array.dropWhile!() expects 1 argument but got %zu", 
args
->
count
);

454 struct 
value
 
f
 = 
args
->
items
[0];

456 if (!
	`CALLABLE
(
f
))

457 
	`vm_panic
("non-callable predicate passed to array.dropWhile!()");

459 int 
drop
 = 0;

460 for (int 
i
 = 0; i < 
array
->array->
count
; ++i)

461 if (
	`value_apply_predicate
(&
f
, &
array
->array->
items
[
i
]))

462 ++
drop
;

466 
	`memmove
(
array
->array->
items
, array->array->items + 
drop
, (array->array->
count
 - drop) * sizeof (struct 
value
));

467 
array
->array->
count
 -= 
drop
;

468 
	`shrink
(
array
);

470 return *
array
;

471 
	}
}

473 static struct 
value


474 
	$array_drop_while
(struct 
value
 *
array
, 
value_vector
 *
args
)

476 if (
args
->
count
 != 1)

477 
	`vm_panic
("array.dropWhile() expects 1 argument but got %zu", 
args
->
count
);

479 struct 
value
 
f
 = 
args
->
items
[0];

481 if (!
	`CALLABLE
(
f
))

482 
	`vm_panic
("non-callable predicate passed to array.dropWhile()");

484 int 
drop
 = 0;

485 for (int 
i
 = 0; i < 
array
->array->
count
; ++i)

486 if (
	`value_apply_predicate
(&
f
, &
array
->array->
items
[
i
]))

487 ++
drop
;

491 int 
n
 = 
array
->array->
count
 - 
drop
;

492 struct 
value
 
result
 = 
	`ARRAY
(
	`value_array_new
());

493 
	`NOGC
(
result
.
array
);

494 
	`value_array_reserve
(
result
.
array
, 
n
);

495 
	`OKGC
(
result
.
array
);

496 
	`memmove
(
result
.
array
->
items
, array->array->items + 
drop
, 
n
 * sizeof (struct 
value
));

497 
result
.
array
->
count
 = 
n
;

499 return 
result
;

500 
	}
}

502 static struct 
value


503 
	$array_uniq
(struct 
value
 *
array
, 
value_vector
 *
args
)

505 struct 
value
 *
f
 = 
NULL
;

507 if (
args
->
count
 == 1)

508 
f
 = &
args
->
items
[0];

509 else if (
args
->
count
 != 0)

510 
	`vm_panic
("array.uniq() expects 0 or 1 arguments but got %zu", 
args
->
count
);

512 if (
f
 != 
NULL
 && !
	`CALLABLE
(*f))

513 
	`vm_panic
("the argument to array.uniq() must be callable");

515 struct 
value
 
d
 = 
	`DICT
(
	`dict_new
());

516 
	`gc_push
(&
d
);

518 int 
n
 = 0;

519 for (int 
i
 = 0; i < 
array
->array->
count
; ++i) {

520 struct 
value
 
e
 = 
array
->array->
items
[
i
];

521 struct 
value
 
k
 = (
f
 == 
NULL
) ? 
e
 : 
	`vm_eval_function
(f, &e);

522 struct 
value
 *
v
 = 
	`dict_put_key_if_not_exists
(
d
.
dict
, 
k
);

523 if (
v
->
type
 == 
VALUE_NIL
) {

524 *
v
 = 
e
;

525 
array
->array->
items
[
n
++] = 
e
;

529 
	`gc_pop
();

530 
array
->array->
count
 = 
n
;

532 return *
array
;

533 
	}
}

535 static struct 
value


536 
	$array_take_mut
(struct 
value
 *
array
, 
value_vector
 *
args
)

538 if (
args
->
count
 != 1)

539 
	`vm_panic
("array.take!() expects 1 argument but got %zu", 
args
->
count
);

541 struct 
value
 
n
 = 
args
->
items
[0];

543 if (
n
.
type
 != 
VALUE_INTEGER
)

544 
	`vm_panic
("non-integer passed to array.take!()");

546 
array
->array->
count
 = 
	`min
(array->array->count, 
n
.
integer
);

547 
	`shrink
(
array
);

549 return *
array
;

550 
	}
}

552 static struct 
value


553 
	$array_take
(struct 
value
 *
array
, 
value_vector
 *
args
)

555 if (
args
->
count
 != 1)

556 
	`vm_panic
("array.take() expects 1 argument but got %zu", 
args
->
count
);

558 struct 
value
 
n
 = 
args
->
items
[0];

560 if (
n
.
type
 != 
VALUE_INTEGER
)

561 
	`vm_panic
("non-integer passed to array.take!()");

563 struct 
value
 
result
 = 
	`ARRAY
(
	`value_array_new
());

565 int 
count
 = 
	`min
(
n
.
integer
, 
array
->array->count);

567 
	`NOGC
(
result
.
array
);

568 
	`value_array_reserve
(
result
.
array
, 
count
);

569 
	`OKGC
(
result
.
array
);

571 
	`memmove
(
result
.
array
->
items
, array->array->items, 
count
 * sizeof (struct 
value
));

572 
result
.
array
->
count
 = count;

574 return 
result
;

575 
	}
}

577 static struct 
value


578 
	$array_drop_mut
(struct 
value
 *
array
, 
value_vector
 *
args
)

580 if (
args
->
count
 != 1)

581 
	`vm_panic
("array.drop!() expects 1 argument but got %zu", 
args
->
count
);

583 struct 
value
 
n
 = 
args
->
items
[0];

585 if (
n
.
type
 != 
VALUE_INTEGER
)

586 
	`vm_panic
("non-integer passed to array.drop!()");

588 int 
d
 = 
	`min
(
array
->array->
count
, 
n
.
integer
);

590 
	`memmove
(
array
->array->
items
, array->array->items + 
d
, (array->array->
count
 - d) * sizeof (struct 
value
));

591 
array
->array->
count
 -= 
d
;

592 
	`shrink
(
array
);

594 return *
array
;

595 
	}
}

597 static struct 
value


598 
	$array_drop
(struct 
value
 *
array
, 
value_vector
 *
args
)

600 if (
args
->
count
 != 1)

601 
	`vm_panic
("array.drop() expects 1 argument but got %zu", 
args
->
count
);

603 struct 
value
 
n
 = 
args
->
items
[0];

605 if (
n
.
type
 != 
VALUE_INTEGER
)

606 
	`vm_panic
("non-integer passed to array.drop!()");

608 struct 
value
 
result
 = 
	`ARRAY
(
	`value_array_new
());

610 int 
d
 = 
	`min
(
n
.
integer
, 
array
->array->
count
);

611 int 
count
 = 
array
->array->count - 
d
;

613 
	`NOGC
(
result
.
array
);

614 
	`value_array_reserve
(
result
.
array
, 
count
);

615 
	`OKGC
(
result
.
array
);

617 
	`memmove
(
result
.
array
->
items
, array->array->items + 
d
, 
count
 * sizeof (struct 
value
));

618 
result
.
array
->
count
 = count;

620 return 
result
;

621 
	}
}

623 static struct 
value


624 
	$array_sum
(struct 
value
 *
array
, 
value_vector
 *
args
)

626 if (
args
->
count
 != 0)

627 
	`vm_panic
("the sum method on arrays expects no arguments but got %zu", 
args
->
count
);

629 if (
array
->array->
count
 == 0)

630 return 
NIL
;

632 struct 
value
 
sum
, 
v
;

633 
sum
 = 
array
->array->
items
[0];

635 
	`gc_push
(&
sum
);

637 for (int 
i
 = 1; i < 
array
->array->
count
; ++i) {

638 
v
 = 
array
->array->
items
[
i
];

639 
sum
 = 
	`binary_operator_addition
(&sum, &
v
);

642 
	`gc_pop
();

644 return 
sum
;

645 
	}
}

647 static struct 
value


648 
	$array_join
(struct 
value
 *
array
, 
value_vector
 *
args
)

650 if (
args
->
count
 != 1)

651 
	`vm_panic
("array.join() expects 1 argument but got %zu", 
args
->
count
);

653 if (
array
->array->
count
 == 0)

654 return 
NIL
;

656 struct 
value
 
sep
 = 
args
->
items
[0];

657 if (
sep
.
type
 != 
VALUE_STRING
)

658 
	`vm_panic
("the argument to array.join() must be a string");

660 struct 
value
 
sum
 = 
	`builtin_str
(&(
value_vector
){ .
count
 = 1, .
items
 = &
array
->array->items[0] });

661 struct 
value
 
v
 = 
NIL
;

663 
	`gc_push
(&
sum
);

664 
	`gc_push
(&
v
);

666 for (int 
i
 = 1; i < 
array
->array->
count
; ++i) {

667 
v
 = 
	`builtin_str
(&(
value_vector
){ .
count
 = 1, .
items
 = &
array
->array->items[
i
] });

668 
sum
 = 
	`binary_operator_addition
(&sum, &
sep
);

669 
sum
 = 
	`binary_operator_addition
(&sum, &
v
);

672 
	`gc_pop
();

673 
	`gc_pop
();

675 return 
sum
;

676 
	}
}

678 static struct 
value


679 
	$array_consume_while
(struct 
value
 *
array
, 
value_vector
 *
args
)

681 if (
args
->
count
 != 2)

682 
	`vm_panic
("array.consumeWhile() expects 2 arguments but got %zu", 
args
->
count
);

684 struct 
value
 
f
 = 
args
->
items
[0];

685 struct 
value
 
p
 = 
args
->
items
[1];

687 if (!
	`CALLABLE
(
f
))

688 
	`vm_panic
("invalid source passed to array.consumeWhile()");

690 if (!
	`CALLABLE
(
p
))

691 
	`vm_panic
("invalid predicate passed to array.consumeWhile()");

693 struct 
value
 
v
 = 
NIL
;

694 
	`gc_push
(&
v
);

697 
v
 = 
	`vm_eval_function
(&
f
, 
NULL
);

698 if (
	`value_apply_predicate
(&
p
, &
v
))

699 
	`value_array_push
(
array
->array, 
v
);

704 
	`gc_pop
();

706 return *
array
;

707 
	}
}

709 static struct 
value


710 
	$array_groups_of
(struct 
value
 *
array
, 
value_vector
 *
args
)

712 if (
args
->
count
 != 1)

713 
	`vm_panic
("array.groupsOf() expects 1 argument but got %zu", 
args
->
count
);

715 struct 
value
 
size
 = 
args
->
items
[0];

716 if (
size
.
type
 != 
VALUE_INTEGER
)

717 
	`vm_panic
("the argument to array.groupsOf() must be an integer");

719 if (
size
.
integer
 <= 0)

720 
	`vm_panic
("the argument to array.groupsOf() must be positive");

722 int 
n
 = 0;

723 int 
i
 = 0;

724 while (
i
 + 
size
.
integer
 < 
array
->array->
count
) {

725 struct 
array
 *
group
 = 
	`value_array_new
();

726 
	`NOGC
(
group
);

727 
	`vec_push_n
(*
group
, 
array
->array->
items
 + 
i
, 
size
.
integer
);

728 
	`OKGC
(
group
);

729 
array
->array->
items
[
n
++] = 
	`ARRAY
(
group
);

730 
i
 += 
size
.
integer
;

733 if (
i
 != 
array
->array->
count
) {

734 struct 
array
 *
last
 = 
	`value_array_new
();

735 
	`NOGC
(
last
);

736 
	`vec_push_n
(*
last
, 
array
->array->
items
 + 
i
, array->array->
count
 - i);

737 
	`OKGC
(
last
);

738 
array
->array->
items
[
n
++] = 
	`ARRAY
(
last
);

741 
array
->array->
count
 = 
n
;

742 
	`shrink
(
array
);

744 return *
array
;

745 
	}
}

747 static struct 
value


748 
	$array_group_by
(struct 
value
 *
array
, 
value_vector
 *
args
)

750 if (
args
->
count
 != 1)

751 
	`vm_panic
("array.groupBy() expects 1 argument but got %zu", 
args
->
count
);

753 struct 
value
 
f
 = 
args
->
items
[0];

755 if (!
	`CALLABLE
(
f
))

756 
	`vm_panic
("the argument to array.groupBy() must be callable");

758 struct 
value
 
v1
, 
v2
;

759 
v1
 = 
v2
 = 
NIL
;

761 
	`gc_push
(&
v1
);

762 
	`gc_push
(&
v2
);

764 int 
len
 = 0;

765 for (int 
i
 = 0; i < 
array
->array->
count
; ++i) {

766 struct 
value
 
group
 = 
	`ARRAY
(
	`value_array_new
());

767 
	`NOGC
(
group
.
array
);

768 struct 
value
 
e
 = 
array
->array->
items
[
i
];

769 
v1
 = 
	`value_apply_callable
(&
f
, &
e
);

770 
	`value_array_push
(
group
.
array
, 
e
);

771 while (
i
 + 1 < 
array
->array->
count
) {

772 
v2
 = 
	`value_apply_callable
(&
f
, &
array
->array->
items
[
i
 + 1]);

773 if (
	`value_test_equality
(&
v1
, &
v2
))

774 
	`value_array_push
(
group
.
array
, array->array->
items
[++
i
]);

778 
	`OKGC
(
group
.
array
);

779 
array
->array->
items
[
len
++] = 
group
;

782 
	`gc_pop
();

783 
	`gc_pop
();

785 
array
->array->
count
 = 
len
;

786 
	`shrink
(
array
);

788 return *
array
;

789 
	}
}

791 static struct 
value


792 
	$array_group
(struct 
value
 *
array
, 
value_vector
 *
args
)

794 if (
args
->
count
 != 0)

795 
	`vm_panic
("array.group() expects 0 arguments but got %zu", 
args
->
count
);

797 int 
len
 = 0;

798 for (int 
i
 = 0; i < 
array
->array->
count
; ++i) {

799 struct 
value
 
group
 = 
	`ARRAY
(
	`value_array_new
());

800 
	`NOGC
(
group
.
array
);

801 
	`value_array_push
(
group
.
array
, array->array->
items
[
i
]);

802 while (
i
 + 1 < 
array
->array->
count
 && 
	`value_test_equality
(&array->array->
items
[i], &array->array->items[i + 1]))

803 
	`value_array_push
(
group
.
array
, array->array->
items
[++
i
]);

804 
	`OKGC
(
group
.
array
);

805 
array
->array->
items
[
len
++] = 
group
;

808 
array
->array->
count
 = 
len
;

809 
	`shrink
(
array
);

811 return *
array
;

812 
	}
}

814 static struct 
value


815 
	$array_intersperse
(struct 
value
 *
array
, 
value_vector
 *
args
)

817 if (
args
->
count
 != 1)

818 
	`vm_panic
("the intersperse method on arrays expects 1 argument but got %zu", 
args
->
count
);

820 struct 
value
 
v
 = 
args
->
items
[0];

822 int 
n
 = 
array
->array->
count
 - 1;

823 if (
n
 < 1)

824 return *
array
;

826 int 
newcount
 = 2 * 
n
 + 1;

827 
	`value_array_reserve
(
array
->array, 
newcount
);

828 
	`memcpy
(
array
->array->
items
 + 
n
 + 1, array->array->items + 1, n * sizeof (struct 
value
));

830 int 
lo
 = 1;

831 int 
hi
 = 
n
 + 1;

832 for (int 
i
 = 0; i < 
n
; ++i) {

833 
array
->array->
items
[
lo
++] = 
v
;

834 
array
->array->
items
[
lo
++] = array->array->items[
hi
++];

837 
array
->array->
count
 = 
newcount
;

838 return *
array
;

839 
	}
}

841 static struct 
value


842 
	$array_min
(struct 
value
 *
array
, 
value_vector
 *
args
)

844 if (
args
->
count
 != 0)

845 
	`vm_panic
("the min method on arrays expects no arguments but got %zu", 
args
->
count
);

847 if (
array
->array->
count
 == 0)

848 
	`vm_panic
("min called on empty array");

850 struct 
value
 
min
, 
v
;

851 
min
 = 
array
->array->
items
[0];

853 for (int 
i
 = 1; i < 
array
->array->
count
; ++i) {

854 
v
 = 
array
->array->
items
[
i
];

855 if (
	`value_compare
(&
v
, &
min
) < 0)

856 
min
 = 
v
;

859 return 
min
;

860 
	}
}

862 static struct 
value


863 
	$array_min_by
(struct 
value
 *
array
, 
value_vector
 *
args
)

865 if (
args
->
count
 != 1)

866 
	`vm_panic
("the minBy method on arrays expects 1 argument but got %zu", 
args
->
count
);

868 if (
array
->array->
count
 == 0)

869 
	`vm_panic
("minBy called on empty array");

871 struct 
value
 
f
 = 
args
->
items
[0];

872 if (!
	`CALLABLE
(
f
))

873 
	`vm_panic
("non-function passed to the minBy method on array");

875 struct 
value
 
min
, 
v
, 
k
, 
r
;

876 
min
 = 
array
->array->
items
[0];

878 
	`gc_push
(&
k
);

879 
	`gc_push
(&
r
);

881 
r
 = 
k
 = 
NIL
;

883 if (
f
.
type
 == 
VALUE_FUNCTION
 && f.
params
 > 1) {

884 for (int 
i
 = 1; i < 
array
->array->
count
; ++i) {

885 
v
 = 
array
->array->
items
[
i
];

886 
r
 = 
	`vm_eval_function2
(&
f
, &
v
, &
min
);

887 if ((
r
.
type
 != 
VALUE_INTEGER
 && !
	`value_truthy
(&r)) || r.
integer
 < 0)

888 
min
 = 
v
;

892 
k
 = 
	`vm_eval_function
(&
f
, &
min
);

893 for (int 
i
 = 1; i < 
array
->array->
count
; ++i) {

894 
v
 = 
array
->array->
items
[
i
];

895 
r
 = 
	`vm_eval_function
(&
f
, &
v
);

896 if (
	`value_compare
(&
r
, &
k
) < 0) {

897 
min
 = 
v
;

898 
k
 = 
r
;

903 
	`gc_pop
();

904 
	`gc_pop
();

906 return 
min
;

907 
	}
}

909 static struct 
value


910 
	$array_max
(struct 
value
 *
array
, 
value_vector
 *
args
)

912 if (
args
->
count
 != 0)

913 
	`vm_panic
("the max method on arrays expects no arguments but got %zu", 
args
->
count
);

915 if (
array
->array->
count
 == 0)

916 
	`vm_panic
("max called on empty array");

918 struct 
value
 
max
, 
v
;

919 
max
 = 
array
->array->
items
[0];

921 for (int 
i
 = 1; i < 
array
->array->
count
; ++i) {

922 
v
 = 
array
->array->
items
[
i
];

923 if (
	`value_compare
(&
v
, &
max
) > 0)

924 
max
 = 
v
;

927 return 
max
;

928 
	}
}

930 static struct 
value


931 
	$array_max_by
(struct 
value
 *
array
, 
value_vector
 *
args
)

933 if (
args
->
count
 != 1)

934 
	`vm_panic
("the maxBy method on arrays expects 1 argument but got %zu", 
args
->
count
);

936 if (
array
->array->
count
 == 0)

937 
	`vm_panic
("maxBy called on empty array");

939 struct 
value
 
f
 = 
args
->
items
[0];

940 if (!
	`CALLABLE
(
f
))

941 
	`vm_panic
("non-function passed to the maxBy method on array");

943 struct 
value
 
max
, 
v
, 
k
, 
r
;

944 
max
 = 
array
->array->
items
[0];

946 
	`gc_push
(&
k
);

947 
	`gc_push
(&
r
);

949 
k
 = 
r
 = 
NIL
;

951 if (
f
.
type
 == 
VALUE_FUNCTION
 && f.
params
 > 1) {

952 for (int 
i
 = 1; i < 
array
->array->
count
; ++i) {

953 
v
 = 
array
->array->
items
[
i
];

954 
r
 = 
	`vm_eval_function2
(&
f
, &
v
, &
max
);

955 if ((
r
.
type
 != 
VALUE_INTEGER
 && 
	`value_truthy
(&r)) || r.
integer
 > 0)

956 
max
 = 
v
;

960 
k
 = 
	`vm_eval_function
(&
f
, &
max
);

961 for (int 
i
 = 1; i < 
array
->array->
count
; ++i) {

962 
v
 = 
array
->array->
items
[
i
];

963 
r
 = 
	`vm_eval_function
(&
f
, &
v
);

964 if (
	`value_compare
(&
r
, &
k
) > 0) {

965 
max
 = 
v
;

966 
k
 = 
r
;

971 
	`gc_pop
();

972 
	`gc_pop
();

974 return 
max
;

975 
	}
}

977 static struct 
value


978 
	$array_length
(struct 
value
 *
array
, 
value_vector
 *
args
)

980 if (
args
->
count
 != 0)

981 
	`vm_panic
("array.len() expects no arguments but got %zu", 
args
->
count
);

983 return 
	`INTEGER
(
array
->array->
count
);

984 
	}
}

986 static struct 
value


987 
	$array_shuffle
(struct 
value
 *
array
, 
value_vector
 *
args
)

989 if (
args
->
count
 != 0)

990 
	`vm_panic
("the shuffle! method on arrays expects no arguments but got %zu", 
args
->
count
);

992 struct 
value
 
t
;

993 int 
n
 = 
array
->array->
count
;

994 for (int 
i
 = 
n
 - 1; i > 0; --i) {

995 int 
j
 = 
	`rand
() % (
i
 + 1);

996 
t
 = 
array
->array->
items
[
i
];

997 
array
->array->
items
[
i
] = array->array->items[
j
];

998 
array
->array->
items
[
j
] = 
t
;

1001 return *
array
;

1002 
	}
}

1004 static struct 
value


1005 
	$array_map
(struct 
value
 *
array
, 
value_vector
 *
args
)

1007 if (
args
->
count
 != 1)

1008 
	`vm_panic
("the map method on arrays expects 1 argument but got %zu", 
args
->
count
);

1010 struct 
value
 
f
 = 
args
->
items
[0];

1012 if (!
	`CALLABLE
(
f
))

1013 
	`vm_panic
("non-function passed to the map method on array");

1015 int 
n
 = 
array
->array->
count
;

1016 for (int 
i
 = 0; i < 
n
; ++i)

1017 
array
->array->
items
[
i
] = 
	`value_apply_callable
(&
f
, &array->array->items[i]);

1019 return *
array
;

1020 
	}
}

1022 static struct 
value


1023 
	$array_enumerate
(struct 
value
 *
array
, 
value_vector
 *
args
)

1025 if (
args
->
count
 != 0)

1026 
	`vm_panic
("the enumerate method on arrays expects no arguments but got %zu", 
args
->
count
);

1028 int 
n
 = 
array
->array->
count
;

1029 for (int 
i
 = 0; i < 
n
; ++i) {

1030 struct 
value
 
entry
 = 
	`ARRAY
(
	`value_array_new
());

1031 
	`NOGC
(
entry
.
array
);

1032 
	`value_array_push
(
entry
.
array
, 
	`INTEGER
(
i
));

1033 
	`value_array_push
(
entry
.
array
, array->array->
items
[
i
]);

1034 
	`OKGC
(
entry
.
array
);

1035 
array
->array->
items
[
i
] = 
entry
;

1038 return *
array
;

1039 
	}
}

1041 static struct 
value


1042 
	$array_filter
(struct 
value
 *
array
, 
value_vector
 *
args
)

1044 if (
args
->
count
 != 1)

1045 
	`vm_panic
("the filter method on arrays expects 1 argument but got %zu", 
args
->
count
);

1047 struct 
value
 
pred
 = 
args
->
items
[0];

1049 if (!
	`CALLABLE
(
pred
))

1050 
	`vm_panic
("non-predicate passed to the filter method on array");

1052 int 
n
 = 
array
->array->
count
;

1053 int 
j
 = 0;

1054 for (int 
i
 = 0; i < 
n
; ++i)

1055 if (
	`value_apply_predicate
(&
pred
, &
array
->array->
items
[
i
]))

1056 
array
->array->
items
[
j
++] = array->array->items[
i
];

1058 
array
->array->
count
 = 
j
;

1059 
	`shrink
(
array
);

1061 return *
array
;

1062 
	}
}

1064 static struct 
value


1065 
	$array_contains
(struct 
value
 *
array
, 
value_vector
 *
args
)

1067 if (
args
->
count
 != 1)

1068 
	`vm_panic
("array.contains?() expects 1 argument but got %zu", 
args
->
count
);

1070 struct 
value
 
v
 = 
args
->
items
[0];

1072 int 
n
 = 
array
->array->
count
;

1073 for (int 
i
 = 0; i < 
n
; ++i)

1074 if (
	`value_test_equality
(&
v
, &
array
->array->
items
[
i
]))

1075 return 
	`BOOLEAN
(
true
);

1077 return 
	`BOOLEAN
(
false
);

1078 
	}
}

1080 static struct 
value


1081 
	$array_search
(struct 
value
 *
array
, 
value_vector
 *
args
)

1083 if (
args
->
count
 != 1)

1084 
	`vm_panic
("array.search() expects 1 argument but got %zu", 
args
->
count
);

1086 struct 
value
 
v
 = 
args
->
items
[0];

1088 int 
n
 = 
array
->array->
count
;

1089 for (int 
i
 = 0; i < 
n
; ++i)

1090 if (
	`value_test_equality
(&
v
, &
array
->array->
items
[
i
]))

1091 return 
	`INTEGER
(
i
);

1093 return 
NIL
;

1094 
	}
}

1096 static struct 
value


1097 
	$array_each
(struct 
value
 *
array
, 
value_vector
 *
args
)

1099 if (
args
->
count
 != 1)

1100 
	`vm_panic
("the each method on arrays expects 1 argument but got %zu", 
args
->
count
);

1102 struct 
value
 
f
 = 
args
->
items
[0];

1104 if (
f
.
type
 != 
VALUE_FUNCTION
 && f.type != 
VALUE_BUILTIN_FUNCTION
 && f.type != 
VALUE_METHOD
 && f.type != 
VALUE_BUILTIN_METHOD
)

1105 
	`vm_panic
("non-function passed to the each method on array");

1107 int 
n
 = 
array
->array->
count
;

1109 for (int 
i
 = 0; i < 
n
; ++i)

1110 
	`vm_eval_function
(&
f
, &
array
->array->
items
[
i
]);

1112 return *
array
;

1113 
	}
}

1115 static struct 
value


1116 
	$array_fold_left
(struct 
value
 *
array
, 
value_vector
 *
args
)

1118 if (
args
->
count
 != 1 && args->count != 2)

1119 
	`vm_panic
("the foldLeft method on arrays expects 1 or 2 arguments but got %zu", 
args
->
count
);

1121 int 
start
;

1122 struct 
value
 
f
, 
v
;

1124 if (
args
->
count
 == 1) {

1125 
start
 = 1;

1126 
f
 = 
args
->
items
[0];

1127 if (
array
->array->
count
 == 0)

1128 
	`vm_panic
("foldLeft called on empty array with 1 argument");

1129 
v
 = 
array
->array->
items
[0];

1131 
start
 = 0;

1132 
f
 = 
args
->
items
[1];

1133 
v
 = 
args
->
items
[0];

1136 if (!
	`CALLABLE
(
f
))

1137 
	`vm_panic
("non-function passed to the foldLeft method on array");

1139 
	`gc_push
(&
v
);

1141 int 
n
 = 
array
->array->
count
;

1142 for (int 
i
 = 
start
; i < 
n
; ++i)

1143 
v
 = 
	`vm_eval_function2
(&
f
, &v, &
array
->array->
items
[
i
]);

1145 
	`gc_pop
();

1147 return 
v
;

1148 
	}
}

1151 static struct 
value


1152 
	$array_fold_right
(struct 
value
 *
array
, 
value_vector
 *
args
)

1154 if (
args
->
count
 != 1 && args->count != 2)

1155 
	`vm_panic
("the foldRight method on arrays expects 1 or 2 arguments but got %zu", 
args
->
count
);

1157 int 
start
;

1158 struct 
value
 
f
, 
v
;

1160 if (
args
->
count
 == 1) {

1161 
start
 = 
array
->array->
count
 - 2;

1162 
f
 = 
args
->
items
[0];

1163 if (
array
->array->
count
 == 0)

1164 
	`vm_panic
("foldRight called on empty array with 1 argument");

1165 
v
 = 
array
->array->
items
[
start
 + 1];

1167 
start
 = 
array
->array->
count
 - 1;

1168 
f
 = 
args
->
items
[1];

1169 
v
 = 
args
->
items
[0];

1172 if (!
	`CALLABLE
(
f
))

1173 
	`vm_panic
("non-function passed to the foldRight method on array");

1175 
	`gc_push
(&
v
);

1177 for (int 
i
 = 
start
; i >= 0; --i)

1178 
v
 = 
	`vm_eval_function2
(&
f
, &
array
->array->
items
[
i
], &v);

1180 
	`gc_pop
();

1182 return 
v
;

1183 
	}
}

1185 static struct 
value


1186 
	$array_scan_left
(struct 
value
 *
array
, 
value_vector
 *
args
)

1188 if (
args
->
count
 != 1 && args->count != 2)

1189 
	`vm_panic
("the scanLeft method on arrays expects 1 or 2 arguments but got %zu", 
args
->
count
);

1191 int 
start
;

1192 struct 
value
 
f
, 
v
;

1194 if (
args
->
count
 == 1) {

1195 
start
 = 1;

1196 
f
 = 
args
->
items
[0];

1197 if (
array
->array->
count
 == 0)

1198 
	`vm_panic
("scanLeft called on empty array with 1 argument");

1199 
v
 = 
array
->array->
items
[0];

1201 
start
 = 0;

1202 
f
 = 
args
->
items
[1];

1203 
v
 = 
args
->
items
[0];

1206 if (!
	`CALLABLE
(
f
))

1207 
	`vm_panic
("non-function passed to the scanLeft method on array");

1209 int 
n
 = 
array
->array->
count
;

1210 for (int 
i
 = 
start
; i < 
n
; ++i) {

1211 
v
 = 
	`vm_eval_function2
(&
f
, &v, &
array
->array->
items
[
i
]);

1212 
array
->array->
items
[
i
] = 
v
;

1215 return *
array
;

1216 
	}
}

1218 static struct 
value


1219 
	$array_scan_right
(struct 
value
 *
array
, 
value_vector
 *
args
)

1221 if (
args
->
count
 != 1 && args->count != 2)

1222 
	`vm_panic
("the scanRight method on arrays expects 1 or 2 arguments but got %zu", 
args
->
count
);

1224 int 
start
;

1225 struct 
value
 
f
, 
v
;

1227 if (
args
->
count
 == 1) {

1228 
start
 = 
array
->array->
count
 - 2;

1229 
f
 = 
args
->
items
[0];

1230 if (
array
->array->
count
 == 0)

1231 
	`vm_panic
("scanRight called on empty array with 1 argument");

1232 
v
 = 
array
->array->
items
[
start
 + 1];

1234 
start
 = 
array
->array->
count
 - 1;

1235 
f
 = 
args
->
items
[1];

1236 
v
 = 
args
->
items
[0];

1239 if (!
	`CALLABLE
(
f
))

1240 
	`vm_panic
("non-function passed to the scanRight method on array");

1242 for (int 
i
 = 
start
; i >= 0; --i) {

1243 
v
 = 
	`vm_eval_function2
(&
f
, &
array
->array->
items
[
i
], &v);

1244 
array
->array->
items
[
i
] = 
v
;

1247 return *
array
;

1248 
	}
}

1250 static struct 
value


1251 
	$array_reverse
(struct 
value
 *
array
, 
value_vector
 *
args
)

1253 if (
args
->
count
 != 0)

1254 
	`vm_panic
("the reverse method on arrays expects no arguments but got %zu", 
args
->
count
);

1256 int 
lo
 = 0;

1257 int 
hi
 = 
array
->array->
count
 - 1;

1259 struct 
value
 
t
;

1260 while (
lo
 < 
hi
) {

1261 
t
 = 
array
->array->
items
[
lo
];

1262 
array
->array->
items
[
lo
] = array->array->items[
hi
];

1263 
array
->array->
items
[
hi
] = 
t
;

1265 ++
lo
;

1266 --
hi
;

1269 return *
array
;

1270 
	}
}

1272 static struct 
value


1273 
	$array_sort_by
(struct 
value
 *
array
, 
value_vector
 *
args
)

1275 if (
args
->
count
 != 1)

1276 
	`vm_panic
("the sortBy method on arrays expects 1 argument but got %zu", 
args
->
count
);

1278 struct 
value
 
f
 = 
args
->
items
[0];

1279 if (!
	`CALLABLE
(
f
))

1280 
	`vm_panic
("non-function passed to the sortBy method on array");

1282 
comparison_fn
 = &
f
;

1284 if (
f
.
type
 == 
VALUE_FUNCTION
 && f.
params
 > 1)

1285 
	`qsort
(
array
->array->
items
, array->array->
count
, sizeof (struct 
value
), 
compare_by2
);

1287 
	`qsort
(
array
->array->
items
, array->array->
count
, sizeof (struct 
value
), 
compare_by
);

1289 return *
array
;

1290 
	}
}

1292 static struct 
value


1293 
	$array_clone
(struct 
value
 *
array
, 
value_vector
 *
args
)

1295 if (
args
->
count
 != 0)

1296 
	`vm_panic
("the clone method on arrays expects no arguments but got %zu", 
args
->
count
);

1298 struct 
value
 
v
 = *
array
;

1299 
v
.
array
 = 
	`value_array_clone
(v.array);

1301 return 
v
;

1302 
	}
}

1304 #define 
	#DEFINE_NO_MUT
(
name
) \

1305 static struct 
value
 \

1306 
array_
 ## 
name
 ## 
	`_no_mut
(struct 
value
 *
array
, 
value_vector
 *
args
) \

1308 struct 
value
 
clone
 = 
	`array_clone
(
array
, &
NO_ARGS
); \

1309 
	`gc_push
(&
clone
); \

1310 struct 
value
 
result
 = 
array_
 ## 
	`name
(&
clone
, 
args
); \

1311 
	`gc_pop
(); \

1312 return 
result
; \

1313 }

	)

1315 
DEFINE_NO_MUT
(
enumerate
);

1316 
DEFINE_NO_MUT
(
filter
);

1317 
DEFINE_NO_MUT
(
group
);

1318 
DEFINE_NO_MUT
(
group_by
);

1319 
DEFINE_NO_MUT
(
groups_of
);

1320 
DEFINE_NO_MUT
(
intersperse
);

1321 
DEFINE_NO_MUT
(
map
);

1322 
DEFINE_NO_MUT
(
map_cons
);

1323 
DEFINE_NO_MUT
(
reverse
);

1324 
DEFINE_NO_MUT
(
scan_left
);

1325 
DEFINE_NO_MUT
(
scan_right
);

1326 
DEFINE_NO_MUT
(
shuffle
);

1327 
DEFINE_NO_MUT
(
sort
);

1328 
DEFINE_NO_MUT
(
sort_by
);

1329 
DEFINE_NO_MUT
(
uniq
);

1330 
DEFINE_NO_MUT
(
zip
);

1331 
DEFINE_NO_MUT
(
zip_with
);

1332 
DEFINE_NO_MUT
(
next_permutation
);

1334 
DEFINE_METHOD_TABLE
(

1335 { .
name
 = "clone", .
func
 = 
array_clone
 },

1336 { .
name
 = "consumeWhile", .
func
 = 
array_consume_while
 },

1337 { .
name
 = "contains?", .
func
 = 
array_contains
 },

1338 { .
name
 = "drop", .
func
 = 
array_drop
 },

1339 { .
name
 = "drop!", .
func
 = 
array_drop_mut
 },

1340 { .
name
 = "dropWhile", .
func
 = 
array_drop_while
 },

1341 { .
name
 = "dropWhile!", .
func
 = 
array_drop_while_mut
 },

1342 { .
name
 = "each", .
func
 = 
array_each
 },

1343 { .
name
 = "enumerate", .
func
 = 
array_enumerate_no_mut
 },

1344 { .
name
 = "enumerate!", .
func
 = 
array_enumerate
 },

1345 { .
name
 = "filter", .
func
 = 
array_filter_no_mut
 },

1346 { .
name
 = "filter!", .
func
 = 
array_filter
 },

1347 { .
name
 = "foldLeft", .
func
 = 
array_fold_left
 },

1348 { .
name
 = "foldRight", .
func
 = 
array_fold_right
 },

1349 { .
name
 = "group", .
func
 = 
array_group_no_mut
 },

1350 { .
name
 = "group!", .
func
 = 
array_group
 },

1351 { .
name
 = "groupBy", .
func
 = 
array_group_by_no_mut
 },

1352 { .
name
 = "groupBy!", .
func
 = 
array_group_by
 },

1353 { .
name
 = "groupsOf", .
func
 = 
array_groups_of_no_mut
 },

1354 { .
name
 = "groupsOf!", .
func
 = 
array_groups_of
 },

1355 { .
name
 = "insert", .
func
 = 
array_insert
 },

1356 { .
name
 = "intersperse", .
func
 = 
array_intersperse_no_mut
 },

1357 { .
name
 = "intersperse!", .
func
 = 
array_intersperse
 },

1358 { .
name
 = "join", .
func
 = 
array_join
 },

1359 { .
name
 = "len", .
func
 = 
array_length
 },

1360 { .
name
 = "map", .
func
 = 
array_map_no_mut
 },

1361 { .
name
 = "map!", .
func
 = 
array_map
 },

1362 { .
name
 = "mapCons", .
func
 = 
array_map_cons_no_mut
 },

1363 { .
name
 = "mapCons!", .
func
 = 
array_map_cons
 },

1364 { .
name
 = "max", .
func
 = 
array_max
 },

1365 { .
name
 = "maxBy", .
func
 = 
array_max_by
 },

1366 { .
name
 = "min", .
func
 = 
array_min
 },

1367 { .
name
 = "minBy", .
func
 = 
array_min_by
 },

1368 { .
name
 = "nextPermutation", .
func
 = 
array_next_permutation_no_mut
 },

1369 { .
name
 = "nextPermutation!", .
func
 = 
array_next_permutation
 },

1370 { .
name
 = "pop", .
func
 = 
array_pop
 },

1371 { .
name
 = "push", .
func
 = 
array_push
 },

1372 { .
name
 = "reverse", .
func
 = 
array_reverse_no_mut
 },

1373 { .
name
 = "reverse!", .
func
 = 
array_reverse
 },

1374 { .
name
 = "scanLeft", .
func
 = 
array_scan_left_no_mut
 },

1375 { .
name
 = "scanLeft!", .
func
 = 
array_scan_left
 },

1376 { .
name
 = "scanRight", .
func
 = 
array_scan_right_no_mut
 },

1377 { .
name
 = "scanRight!", .
func
 = 
array_scan_right
 },

1378 { .
name
 = "search", .
func
 = 
array_search
 },

1379 { .
name
 = "shuffle", .
func
 = 
array_shuffle_no_mut
 },

1380 { .
name
 = "shuffle!", .
func
 = 
array_shuffle
 },

1381 { .
name
 = "slice", .
func
 = 
array_slice
 },

1382 { .
name
 = "slice!", .
func
 = 
array_slice_mut
 },

1383 { .
name
 = "sort", .
func
 = 
array_sort_no_mut
 },

1384 { .
name
 = "sort!", .
func
 = 
array_sort
 },

1385 { .
name
 = "sortBy", .
func
 = 
array_sort_by_no_mut
 },

1386 { .
name
 = "sortBy!", .
func
 = 
array_sort_by
 },

1387 { .
name
 = "sum", .
func
 = 
array_sum
 },

1388 { .
name
 = "swap", .
func
 = 
array_swap
 },

1389 { .
name
 = "take", .
func
 = 
array_take
 },

1390 { .
name
 = "take!", .
func
 = 
array_take_mut
 },

1391 { .
name
 = "takeWhile", .
func
 = 
array_take_while
 },

1392 { .
name
 = "takeWhile!", .
func
 = 
array_take_while_mut
 },

1393 { .
name
 = "uniq", .
func
 = 
array_uniq_no_mut
 },

1394 { .
name
 = "uniq!", .
func
 = 
array_uniq
 },

1395 { .
name
 = "zip", .
func
 = 
array_zip_no_mut
 },

1396 { .
name
 = "zip!", .
func
 = 
array_zip
 },

1397 { .
name
 = "zipWith", .
func
 = 
array_zip_with_no_mut
 },

1398 { .
name
 = "zipWith!", .
func
 = 
array_zip_with
 },

1401 
DEFINE_METHOD_LOOKUP
(
array
)

	@blob.c

1 #include 
	~<limits.h
>

3 #include 
	~"blob.h
"

4 #include 
	~"value.h
"

5 #include 
	~"vm.h
"

6 #include 
	~"util.h
"

7 #include 
	~"utf8.h
"

9 static struct 
value


10 
	$blob_clear
(struct 
value
 *
blob
, 
value_vector
 *
args
)

12 int 
start
;

13 int 
n
;

15 if (
args
->
count
 > 0 && args->
items
[0].
type
 != 
VALUE_INTEGER
)

16 
	`vm_panic
("the first argument to blob.clear() must be an integer");

18 if (
args
->
count
 > 1 && args->
items
[1].
type
 != 
VALUE_INTEGER
)

19 
	`vm_panic
("the second argument to blob.clear() must be an integer");

21 switch (
args
->
count
) {

23 
start
 = 0;

24 
n
 = 
blob
->blob->
count
;

27 
start
 = 
args
->
items
[0].
integer
;

28 if (
start
 < 0)

29 
start
 += 
blob
->blob->
count
;

30 
n
 = 
blob
->blob->
count
 - 
start
;

33 
start
 = 
args
->
items
[0].
integer
;

34 if (
start
 < 0)

35 
start
 += 
blob
->blob->
count
;

36 
n
 = 
args
->
items
[1].
integer
;

39 
	`vm_panic
("blob.clear() expects 0, 1, or 2 arguments but got %zu", 
args
->
count
);

42 if (
start
 < 0 || 
n
 < 0 || (n + start) > 
blob
->blob->
count
)

43 
	`vm_panic
("invalid arguments to blob.clear()");

45 
	`memmove
(
blob
->blob->
items
 + 
start
, blob->blob->items + start + 
n
, blob->blob->
count
 - start - n);

46 
blob
->blob->
count
 -= 
n
;

48 return 
NIL
;

49 
	}
}

51 static struct 
value


52 
	$blob_search
(struct 
value
 *
blob
, 
value_vector
 *
args
)

55 struct 
value
 
start
;

56 struct 
value
 
c
;

58 switch (
args
->
count
) {

60 
start
 = 
	`INTEGER
(0);

61 
c
 = 
args
->
items
[0];

64 
start
 = 
args
->
items
[0];

65 
c
 = 
args
->
items
[1];

68 
	`vm_panic
("blob.search() expects 1 or 2 arguments but got %zu", 
args
->
count
);

71 if (
start
.
type
 != 
VALUE_INTEGER
)

72 
	`vm_panic
("the offset argument to blob.search() must be an integer");

74 if (
start
.
integer
 < 0 || start.integer > 
blob
->blob->
count
)

75 
	`vm_panic
("invalid offset passed to blob.search()");

77 if (
blob
->blob->
count
 == 0)

78 return 
NIL
;

80 char const *
haystack
 = (char const *) 
blob
->blob->
items
 + 
start
.
integer
;

81 int 
n
 = 
blob
->blob->
count
 - 
start
.
integer
;

82 char const *
s
;

84 switch (
c
.
type
) {

85 case 
VALUE_STRING
:

86 
s
 = 
	`strstrn
(
haystack
, 
n
, 
c
.
string
, c.
bytes
);

88 case 
VALUE_BLOB
:

89 
s
 = 
	`strstrn
(
haystack
, 
n
, (char *)
c
.
blob
->
items
, c.blob->
count
);

91 case 
VALUE_INTEGER
:

92 if (
c
.
integer
 < 0 || c.integer > 
UCHAR_MAX
)

93 
	`vm_panic
("invalid integer passed to blob.search()");

94 
s
 = 
	`memchr
(
haystack
, 
c
.
integer
, 
n
);

97 
	`vm_panic
("invalid argument passed to blob.search()");

100 return (
s
 == 
NULL
) ? 
NIL
 : 
	`INTEGER
(s - 
haystack
 + 
start
.
integer
);

101 
	}
}

103 static struct 
value


104 
	$blob_shrink
(struct 
value
 *
blob
, 
value_vector
 *
args
)

106 
	`resize
(
blob
->blob->
items
, blob->blob->
count
);

107 
blob
->blob->
capacity
 = blob->blob->
count
;

108 return 
NIL
;

109 
	}
}

111 static struct 
value


112 
	$blob_push
(struct 
value
 *
blob
, 
value_vector
 *
args
)

114 
size_t
 
index
 = 
blob
->blob->
count
;

115 struct 
value
 
arg
;

117 if (
args
->
count
 == 2) {

118 
arg
 = 
args
->
items
[1];

119 struct 
value
 
idx
 = 
args
->
items
[0];

120 if (
idx
.
type
 != 
VALUE_INTEGER
)

121 
	`vm_panic
("the index passed to blob.push() must be an integer");

122 if (
idx
.
integer
 < 0)

123 
idx
.
integer
 += 
blob
->blob->
count
;

124 if (
idx
.
integer
 < 0 || idx.integer > 
blob
->blob->
count
)

125 
	`vm_panic
("invalid index passed to blob.push()");

126 
index
 = 
idx
.
integer
;

128 
arg
 = 
args
->
items
[0];

131 switch (
arg
.
type
) {

132 case 
VALUE_INTEGER
:

133 if (
arg
.
integer
 < 0 || arg.integer > 
UCHAR_MAX
)

134 
	`vm_panic
("integer passed to blob.push() out of byte range");

135 
	`vec_insert
(*
blob
->blob, 
arg
.
integer
, 
index
);

137 case 
VALUE_BLOB
:

138 
	`vec_insert_n
(*
blob
->blob, 
arg
.blob->
items
, arg.blob->
count
, 
index
);

140 case 
VALUE_STRING
:

141 
	`vec_insert_n
(*
blob
->blob, 
arg
.
string
, arg.
bytes
, 
index
);

144 
	`vm_panic
("invalid argument passed to blob.push()");

147 return *
blob
;

148 
	}
}

150 static struct 
value


151 
	$blob_size
(struct 
value
 *
blob
, 
value_vector
 *
args
)

153 return 
	`INTEGER
(
blob
->blob->
count
);

154 
	}
}

156 static struct 
value


157 
	$blob_get
(struct 
value
 *
blob
, 
value_vector
 *
args
)

159 if (
args
->
count
 != 1)

160 
	`vm_panic
("blob.get() expects 1 argument but got %zu", 
args
->
count
);

162 struct 
value
 
i
 = 
args
->
items
[0];

163 if (
i
.
type
 != 
VALUE_INTEGER
)

164 
	`vm_panic
("the argument to blob.get() must be an integer");

165 if (
i
.
integer
 < 0)

166 
i
.
integer
 += 
blob
->blob->
count
;

167 if (
i
.
integer
 < 0 || i.integer >= 
blob
->blob->
count
)

168 
	`vm_panic
("invalid index passed to blob.get()");

170 return 
	`INTEGER
(
blob
->blob->
items
[
i
.
integer
]);

171 
	}
}

173 static struct 
value


174 
	$blob_fill
(struct 
value
 *
blob
, 
value_vector
 *
args
)

176 if (
args
->
count
 != 0)

177 
	`vm_panic
("blob.fill() expects no arguments but got %zu", 
args
->
count
);

179 if (
blob
->blob->
items
 == 
NULL
)

180 return 
NIL
;

182 
	`memset
(
blob
->blob->
items
 + blob->blob->
count
, 0, blob->blob->
capacity
 - blob->blob->count);

183 
blob
->blob->
count
 = blob->blob->
capacity
;

185 return 
NIL
;

186 
	}
}

188 static struct 
value


189 
	$blob_set
(struct 
value
 *
blob
, 
value_vector
 *
args
)

191 if (
args
->
count
 != 2)

192 
	`vm_panic
("blob.set() expects 2 arguments but got %zu", 
args
->
count
);

194 struct 
value
 
i
 = 
args
->
items
[0];

195 if (
i
.
type
 != 
VALUE_INTEGER
)

196 
	`vm_panic
("the argument to blob.get() must be an integer");

197 if (
i
.
integer
 < 0)

198 
i
.
integer
 += 
blob
->blob->
count
;

199 if (
i
.
integer
 < 0 || i.integer >= 
blob
->blob->
count
)

200 
	`vm_panic
("invalid index passed to blob.get()");

202 struct 
value
 
arg
 = 
args
->
items
[1];

203 if (
arg
.
type
 != 
VALUE_INTEGER
 || arg.
integer
 < 0 || arg.integer > 
UCHAR_MAX
)

204 
	`vm_panic
("invalid integer passed to blob.set()");

206 
blob
->blob->
items
[
i
.
integer
] = 
arg
.integer;

208 return 
NIL
;

209 
	}
}

211 static struct 
value


212 
	$blob_str
(struct 
value
 *
blob
, 
value_vector
 *
args
)

214 int 
start
;

215 int 
n
;

217 if (
args
->
count
 > 0 && args->
items
[0].
type
 != 
VALUE_INTEGER
)

218 
	`vm_panic
("the first argument to blob.str() must be an integer");

220 if (
args
->
count
 > 1 && args->
items
[1].
type
 != 
VALUE_INTEGER
)

221 
	`vm_panic
("the second argument to blob.str() must be an integer");

223 switch (
args
->
count
) {

225 
start
 = 0;

226 
n
 = 
blob
->blob->
count
;

229 
start
 = 
args
->
items
[0].
integer
;

230 
n
 = 
blob
->blob->
count
 - 
start
;

233 
start
 = 
args
->
items
[0].
integer
;

234 
n
 = 
args
->
items
[1].
integer
;

237 
	`vm_panic
("blob.str() expects 0, 1, or 2 arguments but got %zu", 
args
->
count
);

240 if (
start
 < 0 || 
n
 < 0 || (n + start) > 
blob
->blob->
count
)

241 
	`vm_panic
("invalid arguments to blob.str()");

243 if (!
	`utf8_valid
((char *)
blob
->blob->
items
 + 
start
, 
n
))

244 return 
NIL
;

246 return 
	`STRING_CLONE
((char *)
blob
->blob->
items
 + 
start
, 
n
);

247 
	}
}

249 static struct 
value


250 
	$blob_reserve
(struct 
value
 *
blob
, 
value_vector
 *
args
)

252 if (
args
->
count
 != 1)

253 
	`vm_panic
("blob.reserve() expects 1 argument but got %zu", 
args
->
count
);

255 struct 
value
 
n
 = 
args
->
items
[0];

256 if (
n
.
type
 != 
VALUE_INTEGER
)

257 
	`vm_panic
("the argument to blob.reserve() must be an integer");

258 if (
n
.
integer
 < 0)

259 
	`vm_panic
("the argument to blob.reserve() must be non-negative");

261 
	`vec_reserve
(*
blob
->blob, 
n
.
integer
);

263 return 
NIL
;

264 
	}
}

266 
DEFINE_METHOD_TABLE
(

267 { .
name
 = "clear", .
func
 = 
blob_clear
 },

268 { .
name
 = "fill", .
func
 = 
blob_fill
 },

269 { .
name
 = "get", .
func
 = 
blob_get
 },

270 { .
name
 = "push", .
func
 = 
blob_push
 },

271 { .
name
 = "reserve", .
func
 = 
blob_reserve
 },

272 { .
name
 = "search", .
func
 = 
blob_search
 },

273 { .
name
 = "set", .
func
 = 
blob_set
 },

274 { .
name
 = "shrink", .
func
 = 
blob_shrink
 },

275 { .
name
 = "size", .
func
 = 
blob_size
 },

276 { .
name
 = "str", .
func
 = 
blob_str
 },

279 
DEFINE_METHOD_LOOKUP
(
blob
)

	@class.c

1 #include 
	~<stdbool.h
>

2 #include 
	~<string.h
>

4 #include 
	~"value.h
"

5 #include 
	~"alloc.h
"

6 #include 
	~"log.h
"

7 #include 
	~"util.h
"

8 #include 
	~"vec.h
"

9 #include 
	~"table.h
"

11 static int 
	gclass
 = 0;

12 static 
	$vec
(char const *) 
names
;

13 static 
	$vec
(struct 
table
) 
tables
;

16 
	$class_new
(char const *
name
)

18 
	`vec_push
(
names
, 
name
);

20 struct 
table
 
t
;

21 
	`table_init
(&
t
);

22 
	`vec_push
(
tables
, 
t
);

24 return 
class
++;

25 
	}
}

28 
	$class_lookup
(char const *
name
)

30 for (int 
i
 = 0; i < 
names
.
count
; ++i)

31 if (
	`strcmp
(
names
.
items
[
i
], 
name
) == 0)

32 return 
i
;

35 
	}
}

38 
	$class_name
(int 
class
)

40 return 
names
.
items
[
class
];

41 
	}
}

44 
	$class_add_method
(int 
class
, char const *
name
, struct 
value
 
f
)

46 
	`table_add
(&
tables
.
items
[
class
], 
name
, 
f
);

47 
	}
}

50 
	$class_copy_methods
(int 
dst
, int 
src
)

52 struct 
table
 *
dt
 = &
tables
.
items
[
dst
];

53 struct 
table
 const *
st
 = &
tables
.
items
[
src
];

54 
	`table_copy
(
dt
, 
st
);

55 
	}
}

57 struct 
value
 *

58 
	$class_lookup_method
(int 
class
, char const *
name
)

60 struct 
table
 const *
t
 = &
tables
.
items
[
class
];

61 return 
	`table_lookup
(
t
, 
name
);

62 
	}
}

	@compiler.c

1 #include 
	~<stdlib.h
>

2 #include 
	~<stdio.h
>

3 #include 
	~<ctype.h
>

4 #include 
	~<string.h
>

5 #include 
	~<stdbool.h
>

6 #include 
	~<inttypes.h
>

7 #include 
	~<assert.h
>

8 #include 
	~<setjmp.h
>

9 #include 
	~<stdarg.h
>

10 #include 
	~<stdnoreturn.h
>

12 #include 
	~"location.h
"

13 #include 
	~"log.h
"

14 #include 
	~"alloc.h
"

15 #include 
	~"util.h
"

16 #include 
	~"value.h
"

17 #include 
	~"ast.h
"

18 #include 
	~"dict.h
"

19 #include 
	~"functions.h
"

20 #include 
	~"test.h
"

21 #include 
	~"lex.h
"

22 #include 
	~"parse.h
"

23 #include 
	~"tags.h
"

24 #include 
	~"class.h
"

25 #include 
	~"vm.h
"

27 #define 
	#emit_instr
(
i
) do { 
	`LOG
("emitting instr: %s", #i); 
	`_emit_instr
(i); } while (
false
)

	)

29 #define 
	#PLACEHOLDER_JUMP
(
t
, 
name
) \

30 
	`emit_instr
(
t
); \

31 
name
 = 
state
.
code
.
count
; \

32 
	`emit_int
(0);

	)

34 #define 
	#PATCH_JUMP
(
name
) \

36 
jumpdistance
 = 
state
.
code
.
count
 - 
name
 - sizeof (int); \

37 
	`memcpy
(
state
.
code
.
items
 + 
name
, &
jumpdistance
, sizeof jumpdistance); \

38 } while (
false
)

	)

40 #define 
	#JUMP
(
loc
) \

42 
	`emit_instr
(
INSTR_JUMP
); \

43 
	`emit_int
(
loc
 - 
state
.
code
.
count
 - sizeof (int)); \

44 } while (
false
)

	)

46 #define 
	#EXPR
(...) ((struct 
expression
){ .
loc
 = { -1, -1 }, 
__VA_ARGS__
 })

	)

48 struct 
	seloc
 {

50 
uintptr_t
 
	mp
;

51 
size_t
 
	moffset
;

53 struct 
location
 
	mloc
;

54 char const *
	mfilename
;

57 struct 
	smodule
 {

58 char const *
	mpath
;

59 char *
	mcode
;

60 struct 
scope
 *
	mscope
;

63 struct 
	simport
 {

64 char const *
	mname
;

65 struct 
scope
 *
	mscope
;

68 typedef 
	$vec
(struct 
	timport
) 
	timport_vector
;

69 typedef 
	$vec
(struct 
	treference
) 
	treference_vector
;

70 typedef 
	$vec
(struct 
	teloc
) 
	tlocation_vector
;

71 typedef 
	$vec
(struct 
	tsymbol
 *) 
	tsymbol_vector
;

72 typedef 
	$vec
(
	tsize_t
) 
	toffset_vector
;

73 typedef 
	$vec
(char) 
	tbyte_vector
;

74 typedef 
	$vec
(unsigned) 
	tinfo_vector
;

79 struct 
	sstate
 {

80 
byte_vector
 
code
;

82 
symbol_vector
 
bound_symbols
;

83 
reference_vector
 
refs
;

85 
int_vector
 
check
;

86 struct 
scope
 *
check_scope
;

88 
offset_vector
 
breaks
;

89 
offset_vector
 
continues
;

90 
offset_vector
 
match_fails
;

91 
offset_vector
 
match_successes
;

93 int 
function_depth
;

94 
bool
 
each_loop
;

96 
uint64_t
 
try
;

97 
uint64_t
 
loop
;

99 
import_vector
 
imports
;

100 
	`vec
(char *) 
exports
;

102 struct 
scope
 *
global
;

104 char const *
filename
;

105 struct 
location
 
loc
;

107 
location_vector
 
expression_locations
;

110 static 
jmp_buf
 
jb
;

111 static char const *
err_msg
;

112 static char 
err_buf
[512];

114 static int 
builtin_modules
;

115 static int 
builtin_count
;

117 static int 
jumpdistance
;

118 static 
	$vec
(struct 
module
) 
modules
;

119 static struct 
state
 state;

121 static 
	$vec
(
location_vector
) 
location_lists
;

123 static struct 
scope
 *
global
;

124 static int 
global_count
;

126 static 
uint64_t
 
t
;

129 
	`symbolize_statement
(struct 
scope
 *scope, struct 
statement
 *
s
);

132 
	`symbolize_pattern
(struct 
scope
 *scope, struct 
expression
 *
e
);

135 
	`symbolize_expression
(struct 
scope
 *scope, struct 
expression
 *
e
);

137 static 
bool


138 
	`emit_statement
(struct 
statement
 const *
s
);

141 
	`emit_expression
(struct 
expression
 const *
e
);

144 
	`emit_assignment
(struct 
expression
 *
target
, struct expression const *
e
);

146 static 
bool


147 
	`emit_case
(struct 
expression
 const *
pattern
, struct expression const *
condition
, struct 
statement
 const *
s
);

149 static struct 
scope
 *

150 
	`get_import_scope
(char const *);

153 
	`import_module
(struct 
statement
 const *
s
);

156 
	`compile
(char const *
source
);

158 
noreturn
 static void

159 
	$fail
(char const *
fmt
, ...)

161 
va_list
 
ap
;

162 
	`va_start
(
ap
, 
fmt
);

164 int 
n
;

165 if (
state
.
filename
 == 
NULL
)

166 
n
 = 
	`sprintf
(
err_buf
, "CompileError: %d:%d: ", 
state
.
loc
.
line
 + 1,state.loc.
col
 + 1);

167 else if (
state
.
global
 == global)

168 
n
 = 
	`sprintf
(
err_buf
, "CompileError: %s:%d:%d: ", 
state
.
filename
, state.
loc
.
line
 + 1,state.loc.
col
 + 1);

170 
n
 = 
	`sprintf
(
err_buf
, "CompileError: module '%s':%d:%d: ", 
state
.
filename
, state.
loc
.
line
 + 1,state.loc.
col
 + 1);

172 
	`vsnprintf
(
err_buf
 + 
n
, sizeof err_buf - n, 
fmt
, 
ap
);

173 
err_msg
 = 
err_buf
;

175 
	`LOG
("Failing with error: %s", 
err_buf
);

177 
	`va_end
(
ap
);

179 
	`longjmp
(
jb
, 1);

180 
	}
}

183 
	$slurp_module
(char const *
name
)

185 char 
pathbuf
[512];

186 char const *
home
 = 
	`getenv
("HOME");

187 if (
home
 == 
NULL
)

188 
	`fail
("unable to get $HOME from the environment");

190 
	`snprintf
(
pathbuf
, sizeof pathbuf, "%s/.ty/%s.ty", 
home
, 
name
);

192 char *
source
 = 
	`slurp
(
pathbuf
);

193 if (
source
 == 
NULL
)

194 
	`fail
("failed to read file: %s", 
pathbuf
);

196 return 
source
;

197 
	}
}

200 
	$add_location
(struct 
location
 
loc
)

202 if (
loc
.
line
 == -1 && loc.
col
 == -1)

205 
	`vec_push
(

206 
state
.
expression_locations
,

207 ((struct 
eloc
) {

208 .
offset
 = 
state
.
code
.
count
,

209 .
loc
 = loc,

210 .
filename
 = 
state
.filename

213 
	}
}

216 
	$patch_location_info
(void)

218 struct 
eloc
 *
locs
 = 
state
.
expression_locations
.
items
;

219 for (int 
i
 = 0; i < 
state
.
expression_locations
.
count
; ++i)

220 
locs
[
i
].
p
 = (
uintptr_t
)(
state
.
code
.
items
 + locs[i].
offset
);

221 
	}
}

223 
inline
 static void

224 
	$addref
(int 
symbol
)

226 
	`LOG
("adding reference: %d", 
symbol
);

228 struct 
reference
 
r
 = {

229 .
symbol
 = symbol,

230 .
offset
 = 
state
.
code
.
count


233 
	`vec_push
(
state
.
refs
, 
r
);

234 
	}
}

236 
inline
 static struct 
symbol
 *

237 
	$addsymbol
(struct 
scope
 *scope, char const *
name
)

239 
	`assert
(
name
 != 
NULL
);

241 if (
	`scope_locally_defined
(
scope
, 
name
) && 
	`strcmp
(name, "_") != 0)

242 
	`fail
("redeclaration of variable: %s", 
name
);

244 struct 
symbol
 *
s
 = 
	`scope_add
(
scope
, 
name
);

246 
	`LOG
("adding symbol: %s -> %d", 
name
, 
s
->
symbol
);

248 return 
s
;

249 
	}
}

251 
inline
 static 
bool


252 
	$is_call
(struct 
expression
 const *
e
)

254 return 
e
->
type
 == 
EXPRESSION_METHOD_CALL
 || e->type == 
EXPRESSION_FUNCTION_CALL
;

255 
	}
}

257 
inline
 static 
bool


258 
	$is_tag
(struct 
expression
 const *
e
)

260 
	`assert
(
e
->
type
 == 
EXPRESSION_IDENTIFIER
);

262 struct 
scope
 const *scope = (
e
->
module
 == 
NULL
 || *e->module == '\0') ? 
state
.
global
 : 
	`get_import_scope
(e->module);

263 struct 
symbol
 *
sym
 = 
	`scope_lookup
(
scope
, 
e
->
identifier
);

265 return 
sym
 != 
NULL
 && sym->
tag
 != -1;

266 
	}
}

268 
inline
 static 
bool


269 
	$is_class
(struct 
expression
 const *
e
)

271 
	`assert
(
e
->
type
 == 
EXPRESSION_IDENTIFIER
);

273 struct 
scope
 const *scope = (
e
->
module
 == 
NULL
 || *e->module == '\0') ? 
state
.
global
 : 
	`get_import_scope
(e->module);

274 struct 
symbol
 *
sym
 = 
	`scope_lookup
(
scope
, 
e
->
identifier
);

276 return 
sym
 != 
NULL
 && sym->
class
 != -1;

277 
	}
}

279 
inline
 static struct 
symbol
 *

280 
	$getsymbol
(struct 
scope
 const *scope, char const *
name
, 
bool
 *
local
)

285 if (
	`strcmp
(
name
, "_") == 0)

286 
	`fail
("the special identifier '_' can only be used as an lvalue");

288 struct 
symbol
 *
s
 = 
	`scope_lookup
(
scope
, 
name
);

289 if (
s
 == 
NULL
)

290 
	`fail
("reference to undefined variable: %s", 
name
);

292 if (
s
->
scope
->
external
 && !s->
public
)

293 
	`fail
("reference to non-public external variable '%s'", 
name
);

295 
bool
 
is_local
 = (
s
->
scope
->
function
 == scope->function) || (s->scope == 
global
) || (s->scope->
parent
 == global);

297 if (
local
 != 
NULL
)

298 *
local
 = 
is_local
;

300 if (!
is_local
 && 
	`scope_is_subscope
(
s
->
scope
, 
state
.
check_scope
))

301 
	`vec_push
(
state
.
check
, 
s
->
symbol
);

304 return 
s
;

305 
	}
}

307 
inline
 static struct 
symbol
 *

308 
	$tmpsymbol
(void)

310 static int 
i
;

311 static char 
idbuf
[16];

313 
	`assert
(
i
 <= 9999999);

315 
	`sprintf
(
idbuf
, "%d", 
i
++);

317 if (
	`scope_locally_defined
(
global
, 
idbuf
))

318 return 
	`scope_lookup
(
global
, 
idbuf
);

320 return 
	`scope_add
(
global
, 
	`sclone
(
idbuf
));

321 
	}
}

323 static struct 
state


324 
	$freshstate
(void)

326 struct 
state
 
s
;

328 
	`vec_init
(
s
.
code
);

330 
	`vec_init
(
s
.
refs
);

331 
	`vec_init
(
s
.
bound_symbols
);

333 
	`vec_init
(
s
.
check
);

334 
s
.
check_scope
 = 
NULL
;

336 
	`vec_init
(
s
.
breaks
);

337 
	`vec_init
(
s
.
continues
);

339 
	`vec_init
(
s
.
imports
);

340 
	`vec_init
(
s
.
exports
);

342 
s
.
global
 = 
	`scope_new
(global, 
false
);

344 
s
.
function_depth
 = 0;

345 
s
.
each_loop
 = 
false
;

347 
s
.
try
 = 0;

348 
s
.
loop
 = 0;

350 
s
.
filename
 = 
NULL
;

351 
s
.
loc
 = (struct 
location
){ 0, 0 };

353 
	`vec_init
(
s
.
expression_locations
);

355 return 
s
;

356 
	}
}

358 
inline
 static 
bool


359 
	$is_loop
(struct 
statement
 const *
s
)

361 switch (
s
->
type
) {

362 case 
STATEMENT_FOR_LOOP
:

363 case 
STATEMENT_WHILE_LOOP
:

364 case 
STATEMENT_WHILE_LET
:

365 case 
STATEMENT_EACH_LOOP
:

366 case 
STATEMENT_WHILE_MATCH
:

367 return 
true
;

369 return 
false
;

371 
	}
}

373 static struct 
scope
 *

374 
	$get_import_scope
(char const *
name
)

376 for (int 
i
 = 0; i < 
state
.
imports
.
count
; ++i)

377 if (
	`strcmp
(
name
, 
state
.
imports
.
items
[
i
].name) == 0)

378 return 
state
.
imports
.
items
[
i
].
scope
;

380 
	`fail
("reference to undefined module: %s", 
name
);

381 
	}
}

384 
	$symbolize_methods
(struct 
scope
 *scope, struct 
expression
 **
ms
, int 
n
)

386 for (int 
i
 = 0; i < 
n
; ++i) {

395 char *
name
 = 
ms
[
i
]->name;

396 
ms
[
i
]->
name
 = 
NULL
;

398 
	`symbolize_expression
(
scope
, 
ms
[
i
]);

399 
ms
[
i
]->
is_method
 = 
true
;

401 
ms
[
i
]->
name
 = name;

403 
	}
}

406 
	$try_symbolize_application
(struct 
scope
 *scope, struct 
expression
 *
e
)

408 if (
e
->
type
 == 
EXPRESSION_FUNCTION_CALL
 && e->
function
->type == 
EXPRESSION_IDENTIFIER
) {

409 
	`symbolize_expression
(
scope
, 
e
->
function
);

410 if (
e
->
function
->
symbol
->
tag
 != -1) {

411 char *
identifier
 = 
e
->
function
->identifier;

412 char *
module
 = 
e
->
function
->module;

413 struct 
expression
 **
tagged
 = 
e
->
args
.
items
;

414 int 
tagc
 = 
e
->
args
.
count
;

415 struct 
symbol
 *symbol = 
e
->
function
->symbol;

416 
e
->
type
 = 
EXPRESSION_TAG_APPLICATION
;

417 
e
->
identifier
 = identifier;

418 
e
->
module
 = module;

419 
e
->
symbol
 = symbol;

420 if (
tagc
 == 1 && 
tagged
[0]->
type
 != 
EXPRESSION_MATCH_REST
) {

421 
e
->
tagged
 = tagged[0];

423 struct 
expression
 *
items
 = 
	`alloc
(sizeof *items);

424 
items
->
type
 = 
EXPRESSION_ARRAY
;

425 
	`vec_init
(
items
->
elements
);

426 for (int 
i
 = 0; i < 
tagc
; ++i)

427 
	`vec_push
(
items
->
elements
, 
tagged
[
i
]);

428 
e
->
tagged
 = 
items
;

431 } else if (
e
->
type
 == 
EXPRESSION_TAG_APPLICATION
) {

432 
e
->
symbol
 = 
	`getsymbol
(

433 (
e
->
module
 == 
NULL
 || *e->module == '\0') ? 
scope
 : 
	`get_import_scope
(e->module),

434 
e
->
identifier
,

435 
NULL


438 
	}
}

441 
	$symbolize_lvalue
(struct 
scope
 *scope, struct 
expression
 *
target
, 
bool
 
decl
)

443 
state
.
loc
 = 
target
->loc;

445 
	`try_symbolize_application
(
scope
, 
target
);

447 switch (
target
->
type
) {

448 case 
EXPRESSION_IDENTIFIER
:

449 case 
EXPRESSION_MATCH_NOT_NIL
:

450 if (
decl
) {

451 
target
->
symbol
 = 
	`addsymbol
(
scope
, target->
identifier
);

452 
target
->
local
 = 
true
;

454 
target
->
symbol
 = 
	`getsymbol
(
scope
, target->
identifier
, &target->
local
);

457 case 
EXPRESSION_TAG_APPLICATION
:

458 
	`symbolize_lvalue
(
scope
, 
target
->
tagged
, 
decl
);

459 
target
->
symbol
 = 
	`getsymbol
(

460 ((
target
->
module
 == 
NULL
 || *target->module == '\0') ? 
state
.
global
 : 
	`get_import_scope
(target->module)),

461 
target
->
identifier
,

462 
NULL


465 case 
EXPRESSION_ARRAY
:

466 for (
size_t
 
i
 = 0; i < 
target
->
elements
.
count
; ++i)

467 
	`symbolize_lvalue
(
scope
, 
target
->
elements
.
items
[
i
], 
decl
);

469 case 
EXPRESSION_SUBSCRIPT
:

470 
	`symbolize_expression
(
scope
, 
target
->
container
);

471 
	`symbolize_expression
(
scope
, 
target
->
subscript
);

473 case 
EXPRESSION_MEMBER_ACCESS
:

474 
	`symbolize_expression
(
scope
, 
target
->
object
);

475 case 
EXPRESSION_LIST
:

476 for (int 
i
 = 0; i < 
target
->
es
.
count
; ++i) {

477 
	`symbolize_lvalue
(
scope
, 
target
->
es
.
items
[
i
], 
decl
);

481 
	}
}

484 
	$symbolize_pattern
(struct 
scope
 *scope, struct 
expression
 *
e
)

486 if (
e
 == 
NULL
)

489 
	`try_symbolize_application
(
scope
, 
e
);

491 if (
e
->
type
 == 
EXPRESSION_IDENTIFIER
 && 
	`is_tag
(e))

492 goto 
tag
;

494 
state
.
loc
 = 
e
->loc;

496 switch (
e
->
type
) {

497 case 
EXPRESSION_IDENTIFIER
:

498 if (
	`scope_locally_defined
(
scope
, 
e
->
identifier
) || e->
module
 != 
NULL
) {

499 
e
->
type
 = 
EXPRESSION_MUST_EQUAL
;

500 struct 
scope
 *
s
 = (
e
->
module
 == 
NULL
 || *e->module == '\0') ? scope : 
	`get_import_scope
(e->module);

501 
e
->
symbol
 = 
	`getsymbol
(
s
, e->
identifier
, 
NULL
);

503 case 
EXPRESSION_MATCH_NOT_NIL
:

504 
e
->
symbol
 = 
	`addsymbol
(
scope
, e->
identifier
);

507 case 
EXPRESSION_ARRAY
:

508 for (int 
i
 = 0; i < 
e
->
elements
.
count
; ++i)

509 
	`symbolize_pattern
(
scope
, 
e
->
elements
.
items
[
i
]);

511 case 
EXPRESSION_VIEW_PATTERN
:

512 
	`symbolize_expression
(
scope
, 
e
->
left
);

513 
	`symbolize_pattern
(
scope
, 
e
->
right
);

515 case 
EXPRESSION_MATCH_REST
:

516 
e
->
symbol
 = 
	`addsymbol
(
scope
, e->
identifier
);

518 case 
EXPRESSION_TAG_APPLICATION
:

519 
	`symbolize_pattern
(
scope
, 
e
->
tagged
);

521 
tag
:

522 
	`symbolize_expression
(
scope
, 
e
);

523 
e
->
type
 = 
EXPRESSION_MUST_EQUAL
;

526 
	`symbolize_expression
(
scope
, 
e
);

529 
	}
}

532 
	$symbolize_expression
(struct 
scope
 *scope, struct 
expression
 *
e
)

534 if (
e
 == 
NULL
)

537 
state
.
loc
 = 
e
->loc;

539 struct 
scope
 *
subscope
;

541 switch (
e
->
type
) {

542 case 
EXPRESSION_IDENTIFIER
:

543 
	`LOG
("symbolizing var: %s%s%s", (
e
->
module
 == 
NULL
 ? "" : e->module), (e->module == NULL ? "" : "::"), e->
identifier
);

544 
e
->
symbol
 = 
	`getsymbol
(

545 ((
e
->
module
 == 
NULL
 || *e->module == '\0') ? 
scope
 : 
	`get_import_scope
(e->module)),

546 
e
->
identifier
,

547 &
e
->
local


549 
	`LOG
("var %s local", 
e
->
local
 ? "is" : "is NOT");

551 case 
EXPRESSION_SPECIAL_STRING
:

552 for (int 
i
 = 0; i < 
e
->
expressions
.
count
; ++i)

553 
	`symbolize_expression
(
scope
, 
e
->
expressions
.
items
[
i
]);

555 case 
EXPRESSION_TAG
:

556 
e
->
symbol
 = 
	`getsymbol
(

557 ((
e
->
module
 == 
NULL
 || *e->module == '\0') ? 
state
.
global
 : 
	`get_import_scope
(e->module)),

558 
e
->
identifier
,

559 
NULL


562 case 
EXPRESSION_TAG_APPLICATION
:

563 
e
->
symbol
 = 
	`getsymbol
(

564 ((
e
->
module
 == 
NULL
 || *e->module) ? 
state
.
global
 : 
	`get_import_scope
(e->module)),

565 
e
->
identifier
,

566 
NULL


568 
	`symbolize_expression
(
scope
, 
e
->
tagged
);

570 case 
EXPRESSION_MATCH
:

571 
	`symbolize_expression
(
scope
, 
e
->
subject
);

572 for (int 
i
 = 0; i < 
e
->
patterns
.
count
; ++i) {

573 
subscope
 = 
	`scope_new
(
scope
, 
false
);

574 
	`symbolize_pattern
(
subscope
, 
e
->
patterns
.
items
[
i
]);

575 
	`symbolize_expression
(
subscope
, 
e
->
conds
.
items
[
i
]);

576 
	`symbolize_expression
(
subscope
, 
e
->
thens
.
items
[
i
]);

579 case 
EXPRESSION_PLUS
:

580 case 
EXPRESSION_MINUS
:

581 case 
EXPRESSION_STAR
:

582 case 
EXPRESSION_DIV
:

583 case 
EXPRESSION_PERCENT
:

584 case 
EXPRESSION_AND
:

585 case 
EXPRESSION_OR
:

586 case 
EXPRESSION_LT
:

587 case 
EXPRESSION_LEQ
:

588 case 
EXPRESSION_GT
:

589 case 
EXPRESSION_GEQ
:

590 case 
EXPRESSION_CMP
:

591 case 
EXPRESSION_DBL_EQ
:

592 case 
EXPRESSION_NOT_EQ
:

593 case 
EXPRESSION_DOT_DOT
:

594 case 
EXPRESSION_DOT_DOT_DOT
:

595 
	`symbolize_expression
(
scope
, 
e
->
left
);

596 
	`symbolize_expression
(
scope
, 
e
->
right
);

598 case 
EXPRESSION_PREFIX_BANG
:

599 case 
EXPRESSION_PREFIX_MINUS
:

600 case 
EXPRESSION_PREFIX_AT
:

601 case 
EXPRESSION_PREFIX_INC
:

602 case 
EXPRESSION_PREFIX_DEC
:

603 case 
EXPRESSION_POSTFIX_INC
:

604 case 
EXPRESSION_POSTFIX_DEC
:

605 
	`symbolize_expression
(
scope
, 
e
->
operand
);

607 case 
EXPRESSION_CONDITIONAL
:

608 
	`symbolize_expression
(
scope
, 
e
->
cond
);

609 
	`symbolize_expression
(
scope
, 
e
->
then
);

610 
	`symbolize_expression
(
scope
, 
e
->
otherwise
);

612 case 
EXPRESSION_FUNCTION_CALL
:

613 
	`symbolize_expression
(
scope
, 
e
->
function
);

614 for (
size_t
 
i
 = 0; i < 
e
->
args
.
count
; ++i)

615 
	`symbolize_expression
(
scope
, 
e
->
args
.
items
[
i
]);

617 case 
EXPRESSION_SUBSCRIPT
:

618 
	`symbolize_expression
(
scope
, 
e
->
container
);

619 
	`symbolize_expression
(
scope
, 
e
->
subscript
);

621 case 
EXPRESSION_MEMBER_ACCESS
:

622 
	`symbolize_expression
(
scope
, 
e
->
object
);

624 case 
EXPRESSION_METHOD_CALL
:

625 
	`symbolize_expression
(
scope
, 
e
->
object
);

626 for (
size_t
 
i
 = 0; i < 
e
->
method_args
.
count
; ++i)

627 
	`symbolize_expression
(
scope
, 
e
->
method_args
.
items
[
i
]);

629 case 
EXPRESSION_EQ
:

630 case 
EXPRESSION_PLUS_EQ
:

631 case 
EXPRESSION_STAR_EQ
:

632 case 
EXPRESSION_DIV_EQ
:

633 case 
EXPRESSION_MINUS_EQ
:

634 
	`symbolize_expression
(
scope
, 
e
->
value
);

635 
	`symbolize_lvalue
(
scope
, 
e
->
target
, 
false
);

637 case 
EXPRESSION_FUNCTION
:

639 
e
->
is_method
 = 
false
;

641 if (
e
->
name
 != 
NULL
) {

642 
scope
 = 
	`scope_new
(scope, 
false
);

643 
e
->
function_symbol
 = 
	`addsymbol
(
scope
, e->
name
);

645 
e
->
function_symbol
 = 
NULL
;

648 
scope
 = 
	`scope_new
(scope, 
true
);

650 
	`vec_init
(
e
->
param_symbols
);

651 for (
size_t
 
i
 = 0; i < 
e
->
params
.
count
; ++i)

652 
	`vec_push
(
e
->
param_symbols
, 
	`addsymbol
(
scope
, e->
params
.
items
[
i
]));

653 
	`symbolize_statement
(
scope
, 
e
->
body
);

655 
e
->
bound_symbols
.
items
 = 
scope
->
function_symbols
.items;

656 
e
->
bound_symbols
.
count
 = 
scope
->
function_symbols
.count;

659 case 
EXPRESSION_ARRAY
:

660 for (
size_t
 
i
 = 0; i < 
e
->
elements
.
count
; ++i)

661 
	`symbolize_expression
(
scope
, 
e
->
elements
.
items
[
i
]);

663 case 
EXPRESSION_DICT
:

664 for (
size_t
 
i
 = 0; i < 
e
->
keys
.
count
; ++i) {

665 
	`symbolize_expression
(
scope
, 
e
->
keys
.
items
[
i
]);

666 
	`symbolize_expression
(
scope
, 
e
->
values
.
items
[
i
]);

669 case 
EXPRESSION_MATCH_REST
:

670 
	`fail
("*<identifier> 'match-rest' pattern used outside of pattern context");

672 
	}
}

675 
	$symbolize_statement
(struct 
scope
 *scope, struct 
statement
 *
s
)

677 if (
s
 == 
NULL
)

680 
int_vector
 
check_save
 = 
state
.
check
;

681 struct 
scope
 *
check_scope_save
 = 
state
.
check_scope
;

683 if (
	`is_loop
(
s
)) {

684 
	`vec_init
(
state
.
check
);

685 
state
.
check_scope
 = 
scope
;

688 
state
.
loc
 = 
s
->loc;

690 struct 
scope
 *
subscope
;

691 struct 
symbol
 *
sym
;

693 switch (
s
->
type
) {

694 case 
STATEMENT_IMPORT
:

695 
	`import_module
(
s
);

697 case 
STATEMENT_EXPORT
:

698 
	`vec_push_n
(
state
.
exports
, 
s
->exports.
items
, s->exports.
count
);

700 case 
STATEMENT_EXPRESSION
:

701 
	`symbolize_expression
(
scope
, 
s
->
expression
);

703 case 
STATEMENT_CLASS_DEFINITION
:

704 if (
	`scope_locally_defined
(
state
.
global
, 
s
->
class
.
name
))

705 
	`fail
("redeclaration of class: %s", 
s
->
class
.
name
);

706 if (
s
->
class
.
super
 != 
NULL
) {

707 
	`symbolize_expression
(
scope
, 
s
->
class
.
super
);

708 if (!
	`is_class
(
s
->
class
.
super
))

709 
	`fail
("attempt to extend non-class");

711 
sym
 = 
	`scope_add
(
state
.
global
, 
s
->
class
.
name
);

712 
sym
->
class
 = 
	`class_new
(
s
->class.
name
);

713 
s
->
class
.
symbol
 = 
sym
->class;

714 
	`symbolize_methods
(
scope
, 
s
->
class
.
methods
.
items
, s->class.methods.
count
);

716 case 
STATEMENT_TAG_DEFINITION
:

717 if (
	`scope_locally_defined
(
state
.
global
, 
s
->
tag
.
name
))

718 
	`fail
("redeclaration of tag: %s", 
s
->
tag
.
name
);

719 if (
s
->
tag
.
super
 != 
NULL
) {

720 
	`symbolize_expression
(
scope
, 
s
->
tag
.
super
);

721 if (!
	`is_tag
(
s
->
tag
.
super
))

722 
	`fail
("attempt to extend non-tag");

724 
sym
 = 
	`scope_add
(
state
.
global
, 
s
->
tag
.
name
);

725 
sym
->
tag
 = 
	`tags_new
(
s
->tag.
name
);

726 
s
->
tag
.
symbol
 = 
sym
->tag;

727 
	`symbolize_methods
(
scope
, 
s
->
tag
.
methods
.
items
, s->tag.methods.
count
);

729 case 
STATEMENT_BLOCK
:

730 
scope
 = 
	`scope_new
(scope, 
false
);

731 for (
size_t
 
i
 = 0; i < 
s
->
statements
.
count
; ++i)

732 
	`symbolize_statement
(
scope
, 
s
->
statements
.
items
[
i
]);

734 case 
STATEMENT_THROW
:

735 
	`symbolize_expression
(
scope
, 
s
->
throw
);

737 case 
STATEMENT_TRY
:

739 
	`symbolize_statement
(
	`scope_new
(
scope
, 
false
), 
s
->
try
.s);

741 for (int 
i
 = 0; i < 
s
->
try
.
patterns
.
count
; ++i) {

742 struct 
scope
 *
catch
 = 
	`scope_new
(scope, 
false
);

743 
	`symbolize_pattern
(
catch
, 
s
->
try
.
patterns
.
items
[
i
]);

744 
	`symbolize_statement
(
catch
, 
s
->
try
.
handlers
.
items
[
i
]);

747 
	`symbolize_statement
(
scope
, 
s
->
try
.
finally
);

752 case 
STATEMENT_WHILE_MATCH
:

753 case 
STATEMENT_MATCH
:

754 
	`symbolize_expression
(
scope
, 
s
->
match
.
e
);

755 for (int 
i
 = 0; i < 
s
->
match
.
patterns
.
count
; ++i) {

756 
subscope
 = 
	`scope_new
(
scope
, 
false
);

757 
	`symbolize_pattern
(
subscope
, 
s
->
match
.
patterns
.
items
[
i
]);

758 
	`symbolize_expression
(
subscope
, 
s
->
match
.
conds
.
items
[
i
]);

759 
	`symbolize_statement
(
subscope
, 
s
->
match
.
statements
.
items
[
i
]);

761 
s
->
match
.
check
 = 
state
.check;

763 case 
STATEMENT_WHILE_LET
:

764 
	`symbolize_expression
(
scope
, 
s
->
while_let
.
e
);

765 
subscope
 = 
	`scope_new
(
scope
, 
false
);

766 
	`symbolize_pattern
(
subscope
, 
s
->
while_let
.
pattern
);

767 
	`symbolize_statement
(
subscope
, 
s
->
while_let
.
block
);

768 
s
->
while_let
.
check
 = 
state
.check;

770 case 
STATEMENT_IF_LET
:

771 
	`symbolize_expression
(
scope
, 
s
->
if_let
.
e
);

772 
subscope
 = 
	`scope_new
(
scope
, 
false
);

773 
	`symbolize_pattern
(
subscope
, 
s
->
if_let
.
pattern
);

774 
	`symbolize_statement
(
subscope
, 
s
->
if_let
.
then
);

775 
	`symbolize_statement
(
scope
, 
s
->
if_let
.
otherwise
);

777 case 
STATEMENT_FOR_LOOP
:

778 
scope
 = 
	`scope_new
(scope, 
false
);

779 
	`symbolize_statement
(
scope
, 
s
->
for_loop
.
init
);

780 
	`symbolize_expression
(
scope
, 
s
->
for_loop
.
cond
);

781 
	`symbolize_expression
(
scope
, 
s
->
for_loop
.
next
);

782 
	`symbolize_statement
(
scope
, 
s
->
for_loop
.
body
);

783 
s
->
for_loop
.
check
 = 
state
.check;

785 case 
STATEMENT_EACH_LOOP
:

786 
scope
 = 
	`scope_new
(scope, 
false
);

787 
	`symbolize_lvalue
(
scope
, 
s
->
each
.
target
, 
true
);

788 if (
s
->
each
.
counter
 != 
NULL
) {

789 
	`symbolize_lvalue
(
scope
, 
s
->
each
.
counter
, 
true
);

791 
	`symbolize_expression
(
scope
, 
s
->
each
.
array
);

792 
	`symbolize_statement
(
scope
, 
s
->
each
.
body
);

793 
s
->
each
.
check
 = 
state
.check;

795 case 
STATEMENT_WHILE_LOOP
:

796 
scope
 = 
	`scope_new
(scope, 
false
);

797 
	`symbolize_expression
(
scope
, 
s
->
while_loop
.
cond
);

798 
	`symbolize_statement
(
scope
, 
s
->
while_loop
.
body
);

799 
s
->
while_loop
.
check
 = 
state
.check;

801 case 
STATEMENT_CONDITIONAL
:

802 
	`symbolize_expression
(
scope
, 
s
->
conditional
.
cond
);

803 
	`symbolize_statement
(
scope
, 
s
->
conditional
.
then_branch
);

804 
	`symbolize_statement
(
scope
, 
s
->
conditional
.
else_branch
);

806 case 
STATEMENT_RETURN
:

807 for (int 
i
 = 0; i < 
s
->
returns
.
count
; ++i) {

808 
	`symbolize_expression
(
scope
, 
s
->
returns
.
items
[
i
]);

811 case 
STATEMENT_DEFINITION
:

812 
	`symbolize_expression
(
scope
, 
s
->
value
);

813 
	`symbolize_lvalue
(
scope
, 
s
->
target
, 
true
);

815 case 
STATEMENT_FUNCTION_DEFINITION
:

816 
	`symbolize_expression
(
scope
, 
s
->
value
);

820 if (
	`is_loop
(
s
)) {

821 
state
.
check_scope
 = 
check_scope_save
;

822 
state
.
check
 = 
check_save
;

824 
	}
}

826 
inline
 static void

827 
	$patch_jumps_to
(
offset_vector
 const *
js
, 
size_t
 
location
)

829 for (int 
i
 = 0; i < 
js
->
count
; ++i) {

830 int 
distance
 = 
location
 - 
js
->
items
[
i
] - sizeof (int);

831 
	`memcpy
(
state
.
code
.
items
 + 
js
->items[
i
], &
distance
, sizeof distance);

833 
	}
}

835 
inline
 static void

836 
	$patch_loop_jumps
(
size_t
 
begin
, size_t 
end
)

838 
	`patch_jumps_to
(&
state
.
continues
, 
begin
);

839 
	`patch_jumps_to
(&
state
.
breaks
, 
end
);

840 
	}
}

842 
inline
 static void

843 
	$_emit_instr
(char 
c
)

845 
	`vec_push
(
state
.
code
, 
c
);

846 
	}
}

848 
inline
 static char

849 
	$last_instr
(void)

851 return 
state
.
code
.
items
[state.code.
count
 - 1];

852 
	}
}

854 
inline
 static void

855 
	$emit_int
(int 
k
)

857 
	`LOG
("emitting int: %d", 
k
);

858 char const *
s
 = (char *) &
k
;

859 for (int 
i
 = 0; i < sizeof (int); ++i)

860 
	`vec_push
(
state
.
code
, 
s
[
i
]);

861 
	}
}

863 
inline
 static void

864 
	$emit_symbol
(
uintptr_t
 
sym
)

866 
	`LOG
("emitting symbol: %"
PRIuPTR
, 
sym
);

867 char const *
s
 = (char *) &
sym
;

868 for (int 
i
 = 0; i < sizeof (
uintptr_t
); ++i)

869 
	`vec_push
(
state
.
code
, 
s
[
i
]);

870 
	}
}

872 
inline
 static void

873 
	$emit_integer
(
intmax_t
 
k
)

876 
	`LOG
("emitting integer: %"
PRIiMAX
, 
k
);

877 
	`vec_push_n
(
state
.
code
, (char const *)&
k
, sizeof k);

878 
	}
}

880 
inline
 static void

881 
	$emit_boolean
(
bool
 
b
)

884 
	`LOG
("emitting boolean: %s", 
b
 ? "true" : "false");

885 char const *
s
 = (char *) &
b
;

886 for (int 
i
 = 0; i < sizeof (
bool
); ++i)

887 
	`vec_push
(
state
.
code
, 
s
[
i
]);

888 
	}
}

890 
inline
 static void

891 
	$emit_float
(float 
f
)

894 
	`LOG
("emitting float: %f", 
f
);

895 
	`vec_push_n
(
state
.
code
, (char const *)&
f
, sizeof f);

896 
	}
}

898 
inline
 static void

899 
	$emit_string
(char const *
s
)

902 
	`LOG
("emitting string: %s", 
s
);

903 
	`vec_push_n
(
state
.
code
, 
s
, 
	`strlen
(s) + 1);

904 
	}
}

906 
inline
 static void

907 
	$emit_checks
(
int_vector
 
check
)

909 
	`emit_instr
(
INSTR_CHECK_VARS
);

910 
	`emit_int
(
check
.
count
);

911 for (int 
i
 = 0; i < 
check
.
count
; ++i)

912 
	`emit_symbol
(
check
.
items
[
i
]);

913 
	}
}

916 
	$emit_function
(struct 
expression
 const *
e
)

918 
	`assert
(
e
->
type
 == 
EXPRESSION_FUNCTION
);

924 
reference_vector
 
refs_save
 = 
state
.
refs
;

925 
symbol_vector
 
syms_save
 = 
state
.
bound_symbols
;

926 
	`vec_init
(
state
.
refs
);

927 
state
.
bound_symbols
.
items
 = 
e
->bound_symbols.items;

928 
state
.
bound_symbols
.
count
 = 
e
->bound_symbols.count;

929 ++
state
.
function_depth
;

930 
uint64_t
 
loop_save
 = 
state
.
loop
;

931 
uint64_t
 
try_save
 = 
state
.
try
;

932 
uint64_t
 
each_loop_save
 = 
state
.
each_loop
;

933 
state
.
loop
 = state.
try
 = state.
each_loop
 = 0;

935 
	`emit_int
(
e
->
param_symbols
.
count
);

936 
	`emit_int
(
e
->
bound_symbols
.
count
);

938 while (((
uintptr_t
)(
state
.
code
.
items
 + state.code.
count
)) % (
	`_Alignof
 (int)) != ((_Alignof (int)) - 1))

939 
	`vec_push
(
state
.
code
, 0x00);

940 
	`vec_push
(
state
.
code
, 0xFF);

942 for (int 
i
 = 0; i < 
e
->
bound_symbols
.
count
; ++i)

943 
	`emit_int
(
e
->
bound_symbols
.
items
[
i
]->
symbol
);

948 
size_t
 
size_offset
 = 
state
.
code
.
count
;

949 
	`emit_int
(0);

955 
size_t
 
start_offset
 = 
state
.
code
.
count
;

957 
bool
 
returns
 = 
	`emit_statement
(
e
->
body
);

962 if (!
returns
) {

963 struct 
statement
 
empty
 = { .
type
 = 
STATEMENT_RETURN
, .
loc
 = 
state
.loc };

964 
	`vec_init
(
empty
.
returns
);

965 
	`emit_statement
(&
empty
);

968 int 
bytes
 = 
state
.
code
.
count
 - 
size_offset
 - sizeof (int);

969 
	`LOG
("bytes in func = %d", 
bytes
);

970 
	`memcpy
(
state
.
code
.
items
 + 
size_offset
, &
bytes
, sizeof (int));

972 
	`emit_int
(
state
.
refs
.
count
);

973 for (int 
i
 = 0; i < 
state
.
refs
.
count
; ++i) {

974 
	`emit_symbol
(
state
.
refs
.
items
[
i
].
symbol
);

975 
	`emit_symbol
(
state
.
refs
.
items
[
i
].
offset
 - 
start_offset
);

978 
state
.
refs
 = 
refs_save
;

979 
state
.
bound_symbols
 = 
syms_save
;

980 --
state
.
function_depth
;

981 
state
.
loop
 = 
loop_save
;

982 
state
.
try
 = 
try_save
;

983 
state
.
each_loop
 = 
each_loop_save
;

985 if (
e
->
function_symbol
 != 
NULL
) {

986 
	`emit_instr
(
INSTR_TARGET_VAR
);

987 
	`emit_symbol
(
e
->
function_symbol
->
symbol
);

988 
	`emit_instr
(
INSTR_ASSIGN
);

990 
	}
}

992 static 
bool


993 
	$emit_conditional_statement
(struct 
statement
 const *
s
)

995 
bool
 
returns
 = 
false
;

997 
	`emit_expression
(
s
->
conditional
.
cond
);

998 
	`PLACEHOLDER_JUMP
(
INSTR_JUMP_IF
, 
size_t
 
then_branch
);

1000 if (
s
->
conditional
.
else_branch
 != 
NULL
)

1001 
returns
 |= 
	`emit_statement
(
s
->
conditional
.
else_branch
);

1003 
	`PLACEHOLDER_JUMP
(
INSTR_JUMP
, 
size_t
 
end
);

1005 
	`PATCH_JUMP
(
then_branch
);

1007 
returns
 &= 
	`emit_statement
(
s
->
conditional
.
then_branch
);

1009 
	`PATCH_JUMP
(
end
);

1011 return 
returns
;

1012 
	}
}

1015 
	$emit_conditional_expression
(struct 
expression
 const *
e
)

1017 
	`emit_expression
(
e
->
cond
);

1019 
	`PLACEHOLDER_JUMP
(
INSTR_JUMP_IF_NOT
, 
size_t
 
false_branch
);

1021 
	`emit_expression
(
e
->
then
);

1023 
	`PLACEHOLDER_JUMP
(
INSTR_JUMP
, 
size_t
 
end
);

1025 
	`PATCH_JUMP
(
false_branch
);

1027 
	`emit_expression
(
e
->
otherwise
);

1029 
	`PATCH_JUMP
(
end
);

1030 
	}
}

1033 
	$emit_and
(struct 
expression
 const *
left
, struct expression const *
right
)

1035 
	`emit_expression
(
left
);

1036 
	`emit_instr
(
INSTR_DUP
);

1038 
	`PLACEHOLDER_JUMP
(
INSTR_JUMP_IF_NOT
, 
size_t
 
left_false
);

1040 
	`emit_instr
(
INSTR_POP
);

1041 
	`emit_expression
(
right
);

1043 
	`PATCH_JUMP
(
left_false
);

1044 
	}
}

1047 
	$emit_or
(struct 
expression
 const *
left
, struct expression const *
right
)

1049 
	`emit_expression
(
left
);

1050 
	`emit_instr
(
INSTR_DUP
);

1052 
	`PLACEHOLDER_JUMP
(
INSTR_JUMP_IF
, 
size_t
 
left_true
);

1054 
	`emit_instr
(
INSTR_POP
);

1055 
	`emit_expression
(
right
);

1057 
	`PATCH_JUMP
(
left_true
);

1058 
	}
}

1061 
	$emit_special_string
(struct 
expression
 const *
e
)

1063 
	`emit_instr
(
INSTR_STRING
);

1064 
	`emit_string
(
e
->
strings
.
items
[0]);

1066 for (int 
i
 = 0; i < 
e
->
expressions
.
count
; ++i) {

1067 
	`emit_expression
(
e
->
expressions
.
items
[
i
]);

1068 
	`emit_instr
(
INSTR_TO_STRING
);

1069 
	`emit_instr
(
INSTR_STRING
);

1070 
	`emit_string
(
e
->
strings
.
items
[
i
 + 1]);

1073 
	`emit_instr
(
INSTR_CONCAT_STRINGS
);

1074 
	`emit_int
(2 * 
e
->
expressions
.
count
 + 1);

1075 
	}
}

1077 static 
bool


1078 
	$emit_throw
(struct 
statement
 const *
s
)

1080 
	`emit_expression
(
s
->
throw
);

1081 
	`emit_instr
(
INSTR_THROW
);

1082 return 
true
;

1083 
	}
}

1085 static 
bool


1086 
	$emit_try
(struct 
statement
 const *
s
)

1088 
	`emit_instr
(
INSTR_TRY
);

1090 
size_t
 
catch_offset
 = 
state
.
code
.
count
;

1091 
	`emit_int
(0);

1093 
size_t
 
finally_offset
 = 
state
.
code
.
count
;

1094 
	`emit_int
(-1);

1096 
size_t
 
end_offset
 = 
state
.
code
.
count
;

1097 
	`emit_int
(-1);

1099 
uint64_t
 
try_save
 = 
state
.
try
;

1100 
state
.
try
 = ++
t
;

1102 
bool
 
returns
 = 
	`emit_statement
(
s
->
try
.s);

1104 
	`PLACEHOLDER_JUMP
(
INSTR_JUMP
, 
size_t
 
end
);

1106 
offset_vector
 
successes_save
 = 
state
.
match_successes
;

1107 
	`vec_init
(
state
.
match_successes
);

1109 
	`PATCH_JUMP
(
catch_offset
);

1111 for (int 
i
 = 0; i < 
s
->
try
.
patterns
.
count
; ++i)

1112 
returns
 &= 
	`emit_case
(
s
->
try
.
patterns
.
items
[
i
], 
NULL
, s->try.
handlers
.items[i]);

1114 
	`emit_instr
(
INSTR_FINALLY
);

1115 
	`emit_instr
(
INSTR_THROW
);

1117 
	`patch_jumps_to
(&
state
.
match_successes
, state.
code
.
count
);

1118 
	`PATCH_JUMP
(
end
);

1120 
state
.
match_successes
 = 
successes_save
;

1122 
state
.
try
 = 
try_save
;

1124 if (
s
->
try
.
finally
 != 
NULL
) {

1125 
	`PATCH_JUMP
(
finally_offset
);

1126 
returns
 &= 
	`emit_statement
(
s
->
try
.
finally
);

1127 
	`PATCH_JUMP
(
end_offset
);

1128 
	`emit_instr
(
INSTR_NOP
);

1130 
returns
 = 
false
;

1133 
	`emit_instr
(
INSTR_POP_TRY
);

1135 return 
returns
;

1136 
	}
}

1139 
	$emit_while_loop
(struct 
statement
 const *
s
)

1141 
offset_vector
 
cont_save
 = 
state
.
continues
;

1142 
offset_vector
 
brk_save
 = 
state
.
breaks
;

1143 
bool
 
each_loop_save
 = 
state
.
each_loop
;

1144 
state
.
each_loop
 = 
false
;

1145 
uint64_t
 
loop_save
 = 
state
.
loop
;

1146 
state
.
loop
 = 
loop_save
;

1147 
	`vec_init
(
state
.
continues
);

1148 
	`vec_init
(
state
.
breaks
);

1150 
size_t
 
begin
 = 
state
.
code
.
count
;

1152 
	`emit_checks
(
s
->
while_loop
.
check
);

1153 
	`emit_expression
(
s
->
while_loop
.
cond
);

1154 
	`PLACEHOLDER_JUMP
(
INSTR_JUMP_IF_NOT
, 
size_t
 
end
);

1156 
	`emit_statement
(
s
->
while_loop
.
body
);

1158 
	`JUMP
(
begin
);

1160 
	`PATCH_JUMP
(
end
);

1162 
	`patch_loop_jumps
(
begin
, 
state
.
code
.
count
);

1164 
state
.
continues
 = 
cont_save
;

1165 
state
.
breaks
 = 
brk_save
;

1166 
state
.
each_loop
 = 
each_loop_save
;

1167 
state
.
loop
 = 
loop_save
;

1168 
	}
}

1171 
	$emit_for_loop
(struct 
statement
 const *
s
)

1173 
offset_vector
 
cont_save
 = 
state
.
continues
;

1174 
offset_vector
 
brk_save
 = 
state
.
breaks
;

1175 
bool
 
each_loop_save
 = 
state
.
each_loop
;

1176 
state
.
each_loop
 = 
false
;

1177 
uint64_t
 
loop_save
 = 
state
.
loop
;

1178 
state
.
loop
 = ++
t
;

1179 
	`vec_init
(
state
.
continues
);

1180 
	`vec_init
(
state
.
breaks
);

1182 if (
s
->
for_loop
.
init
 != 
NULL
)

1183 
	`emit_statement
(
s
->
for_loop
.
init
);

1185 
	`PLACEHOLDER_JUMP
(
INSTR_JUMP
, 
size_t
 
skip_next
);

1187 
size_t
 
begin
 = 
state
.
code
.
count
;

1189 
	`emit_checks
(
s
->
for_loop
.
check
);

1190 if (
s
->
for_loop
.
next
 != 
NULL
) {

1191 
	`emit_expression
(
s
->
for_loop
.
next
);

1192 
	`emit_instr
(
INSTR_POP
);

1195 
	`PATCH_JUMP
(
skip_next
);

1197 
size_t
 
end_jump
;

1198 if (
s
->
for_loop
.
cond
 != 
NULL
) {

1199 
	`emit_expression
(
s
->
for_loop
.
cond
);

1200 
	`PLACEHOLDER_JUMP
(
INSTR_JUMP_IF_NOT
, 
end_jump
);

1203 
	`emit_statement
(
s
->
for_loop
.
body
);

1205 
	`JUMP
(
begin
);

1207 if (
s
->
for_loop
.
cond
 != 
NULL
)

1208 
	`PATCH_JUMP
(
end_jump
);

1210 
	`patch_loop_jumps
(
begin
, 
state
.
code
.
count
);

1212 
state
.
continues
 = 
cont_save
;

1213 
state
.
breaks
 = 
brk_save
;

1214 
state
.
each_loop
 = 
each_loop_save
;

1215 
state
.
loop
 = 
loop_save
;

1216 
	}
}

1219 
	$emit_try_match
(struct 
expression
 const *
pattern
)

1221 switch (
pattern
->
type
) {

1222 case 
EXPRESSION_IDENTIFIER
:

1223 if (
	`strcmp
(
pattern
->
identifier
, "_") == 0) {

1226 
	`emit_instr
(
INSTR_TARGET_VAR
);

1227 
	`emit_symbol
(
pattern
->
symbol
->symbol);

1228 
	`emit_instr
(
INSTR_ASSIGN
);

1231 case 
EXPRESSION_MATCH_NOT_NIL
:

1232 
	`emit_instr
(
INSTR_TRY_ASSIGN_NON_NIL
);

1233 
	`emit_symbol
(
pattern
->
symbol
->symbol);

1234 
	`vec_push
(
state
.
match_fails
, state.
code
.
count
);

1235 
	`emit_int
(0);

1237 case 
EXPRESSION_MUST_EQUAL
:

1238 
	`emit_instr
(
INSTR_ENSURE_EQUALS_VAR
);

1239 
	`emit_symbol
(
pattern
->
symbol
->symbol);

1240 
	`vec_push
(
state
.
match_fails
, state.
code
.
count
);

1241 
	`emit_int
(0);

1243 case 
EXPRESSION_VIEW_PATTERN
:

1244 
	`emit_instr
(
INSTR_DUP
);

1245 
	`emit_expression
(
pattern
->
left
);

1246 
	`emit_instr
(
INSTR_CALL
);

1247 
	`emit_int
(1);

1248 
	`emit_try_match
(
pattern
->
right
);

1249 
	`emit_instr
(
INSTR_POP
);

1251 case 
EXPRESSION_ARRAY
:

1252 for (int 
i
 = 0; i < 
pattern
->
elements
.
count
; ++i) {

1253 if (
pattern
->
elements
.
items
[
i
]->
type
 == 
EXPRESSION_MATCH_REST
) {

1254 
	`emit_instr
(
INSTR_ARRAY_REST
);

1255 
	`emit_symbol
(
pattern
->
elements
.
items
[
i
]->
symbol
->symbol);

1256 
	`emit_int
(
i
);

1257 
	`vec_push
(
state
.
match_fails
, state.
code
.
count
);

1258 
	`emit_int
(0);

1260 if (
i
 + 1 != 
pattern
->
elements
.
count
)

1261 
	`fail
("the *<id> array-matching pattern must be the last pattern in the array");

1263 
	`emit_instr
(
INSTR_TRY_INDEX
);

1264 
	`emit_int
(
i
);

1265 
	`vec_push
(
state
.
match_fails
, state.
code
.
count
);

1266 
	`emit_int
(0);

1268 
	`emit_try_match
(
pattern
->
elements
.
items
[
i
]);

1270 
	`emit_instr
(
INSTR_POP
);

1274 if (
pattern
->
elements
.
count
 == 0 || pattern->elements.
items
[pattern->elements.count - 1]->
type
 != 
EXPRESSION_MATCH_REST
) {

1275 
	`emit_instr
(
INSTR_ENSURE_LEN
);

1276 
	`emit_int
(
pattern
->
elements
.
count
);

1277 
	`vec_push
(
state
.
match_fails
, state.
code
.
count
);

1278 
	`emit_int
(0);

1282 case 
EXPRESSION_TAG_APPLICATION
:

1283 
	`emit_instr
(
INSTR_DUP
);

1284 
	`emit_instr
(
INSTR_TRY_TAG_POP
);

1285 
	`emit_int
(
pattern
->
symbol
->
tag
);

1286 
	`vec_push
(
state
.
match_fails
, state.
code
.
count
);

1287 
	`emit_int
(0);

1289 
	`emit_try_match
(
pattern
->
tagged
);

1291 
	`emit_instr
(
INSTR_POP
);

1293 case 
EXPRESSION_REGEX
:

1294 
	`emit_instr
(
INSTR_TRY_REGEX
);

1295 
	`emit_symbol
((
uintptr_t
) 
pattern
->
regex
);

1296 
	`emit_symbol
((
uintptr_t
) 
pattern
->
extra
);

1297 
	`vec_push
(
state
.
match_fails
, state.
code
.
count
);

1298 
	`emit_int
(0);

1301 
	`emit_instr
(
INSTR_DUP
);

1302 
	`emit_expression
(
pattern
);

1303 
	`emit_instr
(
INSTR_EQ
);

1304 
	`emit_instr
(
INSTR_JUMP_IF_NOT
);

1305 
	`vec_push
(
state
.
match_fails
, state.
code
.
count
);

1306 
	`emit_int
(0);

1308 
	}
}

1310 static 
bool


1311 
	$emit_case
(struct 
expression
 const *
pattern
, struct expression const *
condition
, struct 
statement
 const *
s
)

1313 
offset_vector
 
fails_save
 = 
state
.
match_fails
;

1314 
	`vec_init
(
state
.
match_fails
);

1316 
	`emit_instr
(
INSTR_SAVE_STACK_POS
);

1317 
	`emit_try_match
(
pattern
);

1319 
size_t
 
failcond
;

1320 if (
condition
 != 
NULL
) {

1321 
	`emit_expression
(
condition
);

1322 
	`emit_instr
(
INSTR_JUMP_IF_NOT
);

1323 
failcond
 = 
state
.
code
.
count
;

1324 
	`emit_int
(0);

1327 
	`emit_instr
(
INSTR_RESTORE_STACK_POS
);

1328 
	`emit_instr
(
INSTR_POP
);

1330 
bool
 
returns
 = 
false
;

1331 if (
s
 != 
NULL
) {

1332 
returns
 |= 
	`emit_statement
(
s
);

1335 
	`emit_instr
(
INSTR_JUMP
);

1336 
	`vec_push
(
state
.
match_successes
, state.
code
.
count
);

1337 
	`emit_int
(0);

1339 if (
condition
 != 
NULL
)

1340 
	`PATCH_JUMP
(
failcond
);

1342 
	`patch_jumps_to
(&
state
.
match_fails
, state.
code
.
count
);

1343 
	`emit_instr
(
INSTR_RESTORE_STACK_POS
);

1345 
state
.
match_fails
 = 
fails_save
;

1347 return 
returns
;

1348 
	}
}

1351 
	$emit_expression_case
(struct 
expression
 const *
pattern
, struct expression const *
condition
, struct expression const *
e
)

1353 
offset_vector
 
fails_save
 = 
state
.
match_fails
;

1354 
	`vec_init
(
state
.
match_fails
);

1356 
	`emit_instr
(
INSTR_SAVE_STACK_POS
);

1357 
	`emit_try_match
(
pattern
);

1359 
size_t
 
failcond
;

1360 if (
condition
 != 
NULL
) {

1361 
	`emit_expression
(
condition
);

1362 
	`emit_instr
(
INSTR_JUMP_IF_NOT
);

1363 
failcond
 = 
state
.
code
.
count
;

1364 
	`emit_int
(0);

1371 
	`emit_instr
(
INSTR_RESTORE_STACK_POS
);

1372 
	`emit_instr
(
INSTR_POP
);

1373 
	`emit_expression
(
e
);

1379 
	`emit_instr
(
INSTR_JUMP
);

1380 
	`vec_push
(
state
.
match_successes
, state.
code
.
count
);

1381 
	`emit_int
(0);

1383 if (
condition
 != 
NULL
)

1384 
	`PATCH_JUMP
(
failcond
);

1386 
	`patch_jumps_to
(&
state
.
match_fails
, state.
code
.
count
);

1387 
	`emit_instr
(
INSTR_RESTORE_STACK_POS
);

1389 
state
.
match_fails
 = 
fails_save
;

1390 
	}
}

1392 static 
bool


1393 
	$emit_match_statement
(struct 
statement
 const *
s
)

1395 
offset_vector
 
successes_save
 = 
state
.
match_successes
;

1396 
	`vec_init
(
state
.
match_successes
);

1398 
	`emit_expression
(
s
->
match
.
e
);

1400 
bool
 
returns
 = 
true
;

1402 for (int 
i
 = 0; i < 
s
->
match
.
patterns
.
count
; ++i) {

1403 
	`LOG
("emitting case %d", 
i
 + 1);

1404 
returns
 &= 
	`emit_case
(
s
->
match
.
patterns
.
items
[
i
], s->match.
conds
.items[i], s->match.
statements
.items[i]);

1410 
	`emit_instr
(
INSTR_BAD_MATCH
);

1412 
	`patch_jumps_to
(&
state
.
match_successes
, state.
code
.
count
);

1414 
state
.
match_successes
 = 
successes_save
;

1416 return 
returns
;

1417 
	}
}

1420 
	$emit_while_match
(struct 
statement
 const *
s
)

1422 
offset_vector
 
brk_save
 = 
state
.
breaks
;

1423 
offset_vector
 
cont_save
 = 
state
.
continues
;

1424 
offset_vector
 
successes_save
 = 
state
.
match_successes
;

1425 
bool
 
each_loop_save
 = 
state
.
each_loop
;

1426 
state
.
each_loop
 = 
false
;

1427 
uint64_t
 
loop_save
 = 
state
.
loop
;

1428 
state
.
loop
 = 
loop_save
;

1429 
	`vec_init
(
state
.
breaks
);

1430 
	`vec_init
(
state
.
continues
);

1431 
	`vec_init
(
state
.
match_successes
);

1433 
size_t
 
begin
 = 
state
.
code
.
count
;

1435 
	`emit_checks
(
s
->
match
.
check
);

1437 
	`emit_expression
(
s
->
match
.
e
);

1439 for (int 
i
 = 0; i < 
s
->
match
.
patterns
.
count
; ++i) {

1440 
	`LOG
("emitting case %d", 
i
 + 1);

1441 
	`emit_case
(
s
->
match
.
patterns
.
items
[
i
], s->match.
conds
.items[i], s->match.
statements
.items[i]);

1447 
	`emit_instr
(
INSTR_POP
);

1448 
	`PLACEHOLDER_JUMP
(
INSTR_JUMP
, 
size_t
 
finished
);

1450 
	`patch_jumps_to
(&
state
.
match_successes
, state.
code
.
count
);

1455 
	`JUMP
(
begin
);

1457 
	`PATCH_JUMP
(
finished
);

1458 
	`patch_loop_jumps
(
begin
, 
state
.
code
.
count
);

1460 
state
.
match_successes
 = 
successes_save
;

1461 
state
.
breaks
 = 
brk_save
;

1462 
state
.
continues
 = 
cont_save
;

1463 
state
.
each_loop
 = 
each_loop_save
;

1464 
state
.
loop
 = 
loop_save
;

1465 
	}
}

1468 
	$emit_while_let
(struct 
statement
 const *
s
)

1470 
offset_vector
 
brk_save
 = 
state
.
breaks
;

1471 
offset_vector
 
cont_save
 = 
state
.
continues
;

1472 
offset_vector
 
successes_save
 = 
state
.
match_successes
;

1473 
bool
 
each_loop_save
 = 
state
.
each_loop
;

1474 
state
.
each_loop
 = 
false
;

1475 
uint64_t
 
loop_save
 = 
state
.
loop
;

1476 
state
.
loop
 = ++
t
;

1477 
	`vec_init
(
state
.
breaks
);

1478 
	`vec_init
(
state
.
continues
);

1479 
	`vec_init
(
state
.
match_successes
);

1481 
size_t
 
begin
 = 
state
.
code
.
count
;

1483 
	`emit_checks
(
s
->
while_let
.
check
);

1485 
	`emit_expression
(
s
->
while_let
.
e
);

1487 
	`emit_case
(
s
->
while_let
.
pattern
, 
NULL
, s->while_let.
block
);

1492 
	`PLACEHOLDER_JUMP
(
INSTR_JUMP
, 
size_t
 
finished
);

1494 
	`patch_jumps_to
(&
state
.
match_successes
, state.
code
.
count
);

1499 
	`JUMP
(
begin
);

1501 
	`PATCH_JUMP
(
finished
);

1502 
	`patch_loop_jumps
(
begin
, 
state
.
code
.
count
);

1504 
	`emit_instr
(
INSTR_POP
);

1506 
state
.
match_successes
 = 
successes_save
;

1507 
state
.
breaks
 = 
brk_save
;

1508 
state
.
continues
 = 
cont_save
;

1509 
state
.
each_loop
 = 
each_loop_save
;

1510 
state
.
loop
 = 
loop_save
;

1511 
	}
}

1513 static 
bool


1514 
	$emit_if_let
(struct 
statement
 const *
s
)

1516 
offset_vector
 
successes_save
 = 
state
.
match_successes
;

1517 
	`vec_init
(
state
.
match_successes
);

1519 
	`emit_expression
(
s
->
if_let
.
e
);

1521 
bool
 
returns
 = 
	`emit_case
(
s
->
if_let
.
pattern
, 
NULL
, s->if_let.
then
);

1523 
	`emit_instr
(
INSTR_POP
);

1525 if (
s
->
if_let
.
otherwise
 != 
NULL
) {

1526 
returns
 &= 
	`emit_statement
(
s
->
if_let
.
otherwise
);

1528 
returns
 = 
false
;

1531 
	`patch_jumps_to
(&
state
.
match_successes
, state.
code
.
count
);

1533 
state
.
match_successes
 = 
successes_save
;

1535 return 
returns
;

1536 
	}
}

1539 
	$emit_match_expression
(struct 
expression
 const *
e
)

1541 
offset_vector
 
successes_save
 = 
state
.
match_successes
;

1542 
	`vec_init
(
state
.
match_successes
);

1544 
	`emit_expression
(
e
->
subject
);

1546 for (int 
i
 = 0; i < 
e
->
patterns
.
count
; ++i) {

1547 
	`LOG
("emitting case %d", 
i
 + 1);

1548 
	`emit_expression_case
(
e
->
patterns
.
items
[
i
], e->
conds
.items[i], e->
thens
.items[i]);

1554 
	`emit_instr
(
INSTR_BAD_MATCH
);

1561 
	`patch_jumps_to
(&
state
.
match_successes
, state.
code
.
count
);

1563 
state
.
match_successes
 = 
successes_save
;

1564 
	}
}

1567 
	$emit_target
(struct 
expression
 *
target
)

1569 switch (
target
->
type
) {

1570 case 
EXPRESSION_IDENTIFIER
:

1571 case 
EXPRESSION_MATCH_NOT_NIL
:

1572 if (
target
->
local
) {

1573 
	`emit_instr
(
INSTR_TARGET_VAR
);

1575 
	`emit_instr
(
INSTR_TARGET_REF
);

1576 
	`addref
(
target
->
symbol
->symbol);

1578 
	`emit_symbol
(
target
->
symbol
->symbol);

1580 case 
EXPRESSION_MEMBER_ACCESS
:

1581 
	`emit_expression
(
target
->
object
);

1582 
	`emit_instr
(
INSTR_TARGET_MEMBER
);

1583 
	`emit_string
(
target
->
member_name
);

1585 case 
EXPRESSION_SUBSCRIPT
:

1586 
	`emit_expression
(
target
->
container
);

1587 
	`emit_expression
(
target
->
subscript
);

1588 
	`emit_instr
(
INSTR_TARGET_SUBSCRIPT
);

1591 
	`fail
("oh no!");

1593 
	}
}

1596 
	$emit_for_each
(struct 
statement
 const *
s
)

1598 
bool
 
each_loop_save
 = 
state
.
each_loop
;

1599 
state
.
each_loop
 = 
true
;

1601 
uint64_t
 
loop_save
 = 
state
.
loop
;

1602 
state
.
loop
 = ++
t
;

1604 
offset_vector
 
brk_save
 = 
state
.
breaks
;

1605 
offset_vector
 
cont_save
 = 
state
.
continues
;

1606 
offset_vector
 
successes_save
 = 
state
.
match_successes
;

1607 
	`vec_init
(
state
.
breaks
);

1608 
	`vec_init
(
state
.
continues
);

1609 
	`vec_init
(
state
.
match_successes
);

1611 
	`emit_instr
(
INSTR_PUSH_INDEX
);

1612 
	`emit_expression
(
s
->
each
.
array
);

1614 
size_t
 
start
 = 
state
.
code
.
count
;

1615 
	`emit_checks
(
s
->
each
.
check
);

1616 if (
s
->
each
.
counter
 != 
NULL
) {

1617 
	`emit_target
(
s
->
each
.
counter
);

1618 
	`emit_instr
(
INSTR_READ_INDEX
);

1620 
	`emit_instr
(
INSTR_GET_NEXT
);

1621 
	`emit_assignment
(
s
->
each
.
target
, 
NULL
);

1622 
	`emit_instr
(
INSTR_NIL
);

1623 
	`emit_instr
(
INSTR_EQ
);

1624 
	`PLACEHOLDER_JUMP
(
INSTR_JUMP_IF
, 
size_t
 
stop
);

1625 
	`emit_statement
(
s
->
each
.
body
);

1626 
	`JUMP
(
start
);

1627 
	`PATCH_JUMP
(
stop
);

1628 
	`patch_loop_jumps
(
start
, 
state
.
code
.
count
);

1629 
	`emit_instr
(
INSTR_POP
);

1630 
	`emit_instr
(
INSTR_POP
);

1632 
state
.
match_successes
 = 
successes_save
;

1633 
state
.
breaks
 = 
brk_save
;

1634 
state
.
continues
 = 
cont_save
;

1635 
state
.
each_loop
 = 
each_loop_save
;

1636 
state
.
loop
 = 
loop_save
;

1637 
	}
}

1639 static 
bool


1640 
	$check_multi
(struct 
expression
 *
target
, struct expression const *
e
, int *
n
)

1642 if (
	`is_call
(
e
))

1643 return 
true
;

1645 if (
e
->
type
 != 
EXPRESSION_LIST
)

1646 return 
false
;

1648 for (*
n
 = 0; *n < 
e
->
es
.
count
; ++*n) {

1649 if (
	`is_call
(
e
->
es
.
items
[*
n
]))

1650 return 
true
;

1653 return *
n
 == 
e
->
es
.
count
;

1654 
	}
}

1657 
	$emit_assignment
(struct 
expression
 *
target
, struct expression const *
e
)

1660 struct 
symbol
 *
tmp
;

1661 struct 
expression
 
container
, 
index
, 
subscript
;

1662 int 
n
;

1664 if (
e
 != 
NULL
 && 
target
->
type
 != 
EXPRESSION_LIST
)

1665 
	`emit_expression
(
e
);

1667 switch (
target
->
type
) {

1668 case 
EXPRESSION_ARRAY
:

1669 
tmp
 = 
	`tmpsymbol
();

1670 
	`emit_instr
(
INSTR_PUSH_VAR
);

1671 
	`emit_symbol
(
tmp
->
symbol
);

1672 
	`emit_instr
(
INSTR_TARGET_VAR
);

1673 
	`emit_symbol
(
tmp
->
symbol
);

1674 
	`emit_instr
(
INSTR_ASSIGN
);

1675 
container
 = 
	`EXPR
(.
type
 = 
EXPRESSION_IDENTIFIER
, .
symbol
 = 
tmp
, .
local
 = 
true
);

1676 
index
 = 
	`EXPR
(.
type
 = 
EXPRESSION_INTEGER
);

1677 
subscript
 = 
	`EXPR
(.
type
 = 
EXPRESSION_SUBSCRIPT
, .
container
 = &container, .subscript = &
index
);

1678 for (int 
i
 = 0; i < 
target
->
elements
.
count
; ++i) {

1679 
index
.
integer
 = 
i
;

1680 
	`emit_assignment
(
target
->
elements
.
items
[
i
], &
subscript
);

1681 
	`emit_instr
(
INSTR_POP
);

1683 
	`emit_instr
(
INSTR_POP_VAR
);

1684 
	`emit_symbol
(
tmp
->
symbol
);

1686 case 
EXPRESSION_TAG_APPLICATION
:

1687 
	`emit_instr
(
INSTR_UNTAG_OR_DIE
);

1688 
	`emit_int
(
target
->
symbol
->
tag
);

1689 
	`emit_assignment
(
target
->
tagged
, 
NULL
);

1691 case 
EXPRESSION_MATCH_NOT_NIL
:

1692 
	`emit_instr
(
INSTR_DIE_IF_NIL
);

1693 
	`emit_target
(
target
);

1694 
	`emit_instr
(
INSTR_ASSIGN
);

1696 case 
EXPRESSION_LIST
:

1697 if (!
	`check_multi
(
target
, 
e
, &
n
)) {

1698 
	`fail
("wrong number of values on RHS of assignment. expected %d but found %d", 
target
->
es
.
count
, 
n
);

1701 for (int 
i
 = 0; i < 
target
->
es
.
count
; ++i) {

1702 
	`emit_target
(
target
->
es
.
items
[
i
]);

1705 
	`emit_instr
(
INSTR_SENTINEL
);

1707 if (
e
->
type
 == 
EXPRESSION_LIST
) for (int 
i
 = 0; i < e->
es
.
count
; ++i) {

1708 if (
	`is_call
(
e
->
es
.
items
[
i
])) {

1709 
	`emit_instr
(
INSTR_CLEAR_RC
);

1710 
	`emit_expression
(
e
->
es
.
items
[
i
]);

1711 
	`emit_instr
(
INSTR_GET_EXTRA
);

1713 
	`emit_expression
(
e
->
es
.
items
[
i
]);

1716 
	`emit_instr
(
INSTR_CLEAR_RC
);

1717 
	`emit_expression
(
e
);

1718 
	`emit_instr
(
INSTR_GET_EXTRA
);

1721 
	`emit_instr
(
INSTR_MULTI_ASSIGN
);

1722 
	`emit_int
((int)
target
->
es
.
count
);

1726 
	`emit_target
(
target
);

1727 
	`emit_instr
(
INSTR_ASSIGN
);

1729 
	}
}

1732 
	$emit_expression
(struct 
expression
 const *
e
)

1734 
state
.
loc
 = 
e
->loc;

1735 
	`add_location
(
e
->
loc
);

1737 switch (
e
->
type
) {

1738 case 
EXPRESSION_IDENTIFIER
:

1739 if (
e
->
local
) {

1740 
	`emit_instr
(
INSTR_LOAD_VAR
);

1742 
	`emit_instr
(
INSTR_LOAD_REF
);

1743 
	`addref
(
e
->
symbol
->symbol);

1745 
	`emit_symbol
(
e
->
symbol
->symbol);

1747 case 
EXPRESSION_MATCH
:

1748 
	`emit_match_expression
(
e
);

1750 case 
EXPRESSION_TAG_APPLICATION
:

1751 
	`emit_expression
(
e
->
tagged
);

1752 
	`emit_instr
(
INSTR_TAG_PUSH
);

1753 
	`emit_int
(
e
->
symbol
->
tag
);

1755 case 
EXPRESSION_DOT_DOT
:

1756 
	`emit_expression
(
e
->
left
);

1757 
	`emit_expression
(
e
->
right
);

1758 
	`emit_instr
(
INSTR_RANGE
);

1760 case 
EXPRESSION_DOT_DOT_DOT
:

1761 
	`emit_expression
(
e
->
left
);

1762 
	`emit_expression
(
e
->
right
);

1763 
	`emit_instr
(
INSTR_INCRANGE
);

1765 case 
EXPRESSION_EQ
:

1766 
	`emit_assignment
(
e
->
target
, e->
value
);

1768 case 
EXPRESSION_INTEGER
:

1769 
	`emit_instr
(
INSTR_INTEGER
);

1770 
	`emit_integer
(
e
->
integer
);

1772 case 
EXPRESSION_BOOLEAN
:

1773 
	`emit_instr
(
INSTR_BOOLEAN
);

1774 
	`emit_boolean
(
e
->
boolean
);

1776 case 
EXPRESSION_REAL
:

1777 
	`emit_instr
(
INSTR_REAL
);

1778 
	`emit_float
(
e
->
real
);

1780 case 
EXPRESSION_STRING
:

1781 
	`emit_instr
(
INSTR_STRING
);

1782 
	`emit_string
(
e
->
string
);

1784 case 
EXPRESSION_SPECIAL_STRING
:

1785 
	`emit_special_string
(
e
);

1787 case 
EXPRESSION_TAG
:

1788 
	`emit_instr
(
INSTR_TAG
);

1789 
	`emit_int
(
e
->
symbol
->
tag
);

1791 case 
EXPRESSION_REGEX
:

1792 
	`emit_instr
(
INSTR_REGEX
);

1793 
	`emit_symbol
((
uintptr_t
) 
e
->
regex
);

1794 
	`emit_symbol
((
uintptr_t
) 
e
->
extra
);

1795 
	`emit_symbol
((
uintptr_t
) 
e
->
pattern
);

1797 case 
EXPRESSION_ARRAY
:

1798 for (int 
i
 = 
e
->
elements
.
count
 - 1; i >= 0; --i)

1799 
	`emit_expression
(
e
->
elements
.
items
[
i
]);

1800 
	`emit_instr
(
INSTR_ARRAY
);

1801 
	`emit_int
(
e
->
elements
.
count
);

1803 case 
EXPRESSION_DICT
:

1804 for (int 
i
 = 
e
->
keys
.
count
 - 1; i >= 0; --i) {

1805 
	`emit_expression
(
e
->
keys
.
items
[
i
]);

1806 if (
e
->
values
.
items
[
i
] == 
NULL
)

1807 
	`emit_instr
(
INSTR_NIL
);

1809 
	`emit_expression
(
e
->
values
.
items
[
i
]);

1811 
	`emit_instr
(
INSTR_DICT
);

1812 
	`emit_int
(
e
->
keys
.
count
);

1814 case 
EXPRESSION_NIL
:

1815 
	`emit_instr
(
INSTR_NIL
);

1817 case 
EXPRESSION_MEMBER_ACCESS
:

1818 
	`emit_expression
(
e
->
object
);

1819 
	`emit_instr
(
INSTR_MEMBER_ACCESS
);

1820 
	`emit_string
(
e
->
member_name
);

1822 case 
EXPRESSION_SUBSCRIPT
:

1823 
	`emit_expression
(
e
->
container
);

1824 
	`emit_expression
(
e
->
subscript
);

1825 
	`emit_instr
(
INSTR_SUBSCRIPT
);

1827 case 
EXPRESSION_FUNCTION_CALL
:

1828 for (
size_t
 
i
 = 0; i < 
e
->
args
.
count
; ++i)

1829 
	`emit_expression
(
e
->
args
.
items
[
i
]);

1830 
	`emit_expression
(
e
->
function
);

1831 
	`emit_instr
(
INSTR_CALL
);

1832 
	`emit_int
(
e
->
args
.
count
);

1834 case 
EXPRESSION_METHOD_CALL
:

1835 for (
size_t
 
i
 = 0; i < 
e
->
method_args
.
count
; ++i)

1836 
	`emit_expression
(
e
->
method_args
.
items
[
i
]);

1837 
	`emit_expression
(
e
->
object
);

1838 
	`emit_instr
(
INSTR_CALL_METHOD
);

1839 
	`emit_string
(
e
->
method_name
);

1840 
	`emit_int
(
e
->
method_args
.
count
);

1842 case 
EXPRESSION_FUNCTION
:

1843 
	`emit_instr
(
INSTR_FUNCTION
);

1844 
	`emit_function
(
e
);

1846 case 
EXPRESSION_CONDITIONAL
:

1847 
	`emit_conditional_expression
(
e
);

1849 case 
EXPRESSION_PLUS
:

1850 
	`emit_expression
(
e
->
left
);

1851 
	`emit_expression
(
e
->
right
);

1852 
	`emit_instr
(
INSTR_ADD
);

1854 case 
EXPRESSION_MINUS
:

1855 
	`emit_expression
(
e
->
left
);

1856 
	`emit_expression
(
e
->
right
);

1857 
	`emit_instr
(
INSTR_SUB
);

1859 case 
EXPRESSION_STAR
:

1860 
	`emit_expression
(
e
->
left
);

1861 
	`emit_expression
(
e
->
right
);

1862 
	`emit_instr
(
INSTR_MUL
);

1864 case 
EXPRESSION_DIV
:

1865 
	`emit_expression
(
e
->
left
);

1866 
	`emit_expression
(
e
->
right
);

1867 
	`emit_instr
(
INSTR_DIV
);

1869 case 
EXPRESSION_PERCENT
:

1870 
	`emit_expression
(
e
->
left
);

1871 
	`emit_expression
(
e
->
right
);

1872 
	`emit_instr
(
INSTR_MOD
);

1874 case 
EXPRESSION_AND
:

1875 
	`emit_and
(
e
->
left
, e->
right
);

1877 case 
EXPRESSION_OR
:

1878 
	`emit_or
(
e
->
left
, e->
right
);

1880 case 
EXPRESSION_LT
:

1881 
	`emit_expression
(
e
->
left
);

1882 
	`emit_expression
(
e
->
right
);

1883 
	`emit_instr
(
INSTR_LT
);

1885 case 
EXPRESSION_LEQ
:

1886 
	`emit_expression
(
e
->
left
);

1887 
	`emit_expression
(
e
->
right
);

1888 
	`emit_instr
(
INSTR_LEQ
);

1890 case 
EXPRESSION_GT
:

1891 
	`emit_expression
(
e
->
left
);

1892 
	`emit_expression
(
e
->
right
);

1893 
	`emit_instr
(
INSTR_GT
);

1895 case 
EXPRESSION_GEQ
:

1896 
	`emit_expression
(
e
->
left
);

1897 
	`emit_expression
(
e
->
right
);

1898 
	`emit_instr
(
INSTR_GEQ
);

1900 case 
EXPRESSION_CMP
:

1901 
	`emit_expression
(
e
->
left
);

1902 
	`emit_expression
(
e
->
right
);

1903 
	`emit_instr
(
INSTR_CMP
);

1905 case 
EXPRESSION_DBL_EQ
:

1906 
	`emit_expression
(
e
->
left
);

1907 
	`emit_expression
(
e
->
right
);

1908 
	`emit_instr
(
INSTR_EQ
);

1910 case 
EXPRESSION_NOT_EQ
:

1911 
	`emit_expression
(
e
->
left
);

1912 
	`emit_expression
(
e
->
right
);

1913 
	`emit_instr
(
INSTR_NEQ
);

1915 case 
EXPRESSION_PREFIX_BANG
:

1916 
	`emit_expression
(
e
->
operand
);

1917 
	`emit_instr
(
INSTR_NOT
);

1919 case 
EXPRESSION_PREFIX_AT
:

1920 
	`emit_expression
(
e
->
operand
);

1921 
	`emit_instr
(
INSTR_GET_TAG
);

1923 case 
EXPRESSION_PREFIX_MINUS
:

1924 
	`emit_expression
(
e
->
operand
);

1925 
	`emit_instr
(
INSTR_NEG
);

1927 case 
EXPRESSION_PREFIX_INC
:

1928 
	`emit_target
(
e
->
operand
);

1929 
	`emit_instr
(
INSTR_PRE_INC
);

1931 case 
EXPRESSION_PREFIX_DEC
:

1932 
	`emit_target
(
e
->
operand
);

1933 
	`emit_instr
(
INSTR_PRE_DEC
);

1935 case 
EXPRESSION_POSTFIX_INC
:

1936 
	`emit_target
(
e
->
operand
);

1937 
	`emit_instr
(
INSTR_POST_INC
);

1939 case 
EXPRESSION_POSTFIX_DEC
:

1940 
	`emit_target
(
e
->
operand
);

1941 
	`emit_instr
(
INSTR_POST_DEC
);

1943 case 
EXPRESSION_PLUS_EQ
:

1944 
	`emit_target
(
e
->
target
);

1945 
	`emit_expression
(
e
->
value
);

1946 
	`emit_instr
(
INSTR_MUT_ADD
);

1948 case 
EXPRESSION_STAR_EQ
:

1949 
	`emit_target
(
e
->
target
);

1950 
	`emit_expression
(
e
->
value
);

1951 
	`emit_instr
(
INSTR_MUT_MUL
);

1953 case 
EXPRESSION_DIV_EQ
:

1954 
	`emit_target
(
e
->
target
);

1955 
	`emit_expression
(
e
->
value
);

1956 
	`emit_instr
(
INSTR_MUT_DIV
);

1958 case 
EXPRESSION_MINUS_EQ
:

1959 
	`emit_target
(
e
->
target
);

1960 
	`emit_expression
(
e
->
value
);

1961 
	`emit_instr
(
INSTR_MUT_SUB
);

1963 case 
EXPRESSION_LIST
:

1964 
	`fail
("list in invalid context");

1967 
	}
}

1969 static 
bool


1970 
	$emit_statement
(struct 
statement
 const *
s
)

1972 
state
.
loc
 = 
s
->loc;

1973 
bool
 
returns
 = 
false
;

1975 switch (
s
->
type
) {

1976 case 
STATEMENT_BLOCK
:

1977 for (int 
i
 = 0; !
returns
 && i < 
s
->
statements
.
count
; ++i) {

1978 
returns
 |= 
	`emit_statement
(
s
->
statements
.
items
[
i
]);

1981 case 
STATEMENT_MATCH
:

1982 
returns
 |= 
	`emit_match_statement
(
s
);

1984 case 
STATEMENT_CONDITIONAL
:

1985 
returns
 |= 
	`emit_conditional_statement
(
s
);

1987 case 
STATEMENT_FOR_LOOP
:

1988 
	`emit_for_loop
(
s
);

1990 case 
STATEMENT_EACH_LOOP
:

1991 
	`emit_for_each
(
s
);

1993 case 
STATEMENT_WHILE_LOOP
:

1994 
	`emit_while_loop
(
s
);

1996 case 
STATEMENT_WHILE_MATCH
:

1997 
	`emit_while_match
(
s
);

1999 case 
STATEMENT_WHILE_LET
:

2000 
	`emit_while_let
(
s
);

2002 case 
STATEMENT_IF_LET
:

2003 
returns
 |= 
	`emit_if_let
(
s
);

2005 case 
STATEMENT_EXPRESSION
:

2006 
	`emit_expression
(
s
->
expression
);

2007 
	`emit_instr
(
INSTR_POP
);

2009 case 
STATEMENT_DEFINITION
:

2010 case 
STATEMENT_FUNCTION_DEFINITION
:

2011 
	`emit_assignment
(
s
->
target
, s->
value
);

2012 
	`emit_instr
(
INSTR_POP
);

2014 case 
STATEMENT_TAG_DEFINITION
:

2015 for (int 
i
 = 0; i < 
s
->
tag
.
methods
.
count
; ++i) {

2016 
	`emit_instr
(
INSTR_FUNCTION
);

2017 
	`emit_function
(
s
->
tag
.
methods
.
items
[
i
]);

2020 
	`emit_instr
(
INSTR_DEFINE_TAG
);

2021 
	`emit_int
(
s
->
tag
.
symbol
);

2022 
	`emit_int
(
s
->
tag
.
super
 == 
NULL
 ? -1 : s->tag.super->
symbol
->tag);

2023 
	`emit_int
(
s
->
tag
.
methods
.
count
);

2025 for (int 
i
 = 
s
->
tag
.
methods
.
count
; i > 0; --i)

2026 
	`emit_string
(
s
->
tag
.
methods
.
items
[
i
 - 1]->
name
);

2029 case 
STATEMENT_CLASS_DEFINITION
:

2030 for (int 
i
 = 0; i < 
s
->
class
.
methods
.
count
; ++i) {

2031 
	`emit_instr
(
INSTR_FUNCTION
);

2032 
	`emit_function
(
s
->
class
.
methods
.
items
[
i
]);

2035 
	`emit_instr
(
INSTR_DEFINE_CLASS
);

2036 
	`emit_int
(
s
->
class
.
symbol
);

2037 
	`emit_int
(
s
->
class
.
super
 == 
NULL
 ? -1 : s->class.super->
symbol
->class);

2038 
	`emit_int
(
s
->
class
.
methods
.
count
);

2040 for (int 
i
 = 
s
->
class
.
methods
.
count
; i > 0; --i)

2041 
	`emit_string
(
s
->
class
.
methods
.
items
[
i
 - 1]->
name
);

2044 case 
STATEMENT_TRY
:

2045 
returns
 |= 
	`emit_try
(
s
);

2047 case 
STATEMENT_THROW
:

2048 
returns
 |= 
	`emit_throw
(
s
);

2050 case 
STATEMENT_RETURN
:

2051 if (
state
.
function_depth
 == 0)

2052 
	`fail
("invalid 'return' statement (not inside of a function)");

2054 if (
state
.
each_loop
) {

2055 
	`emit_instr
(
INSTR_POP
);

2056 
	`emit_instr
(
INSTR_POP
);

2059 if (
s
->
returns
.
count
 > 0) for (int 
i
 = 0; i < s->returns.count; ++i) {

2060 
	`emit_expression
(
s
->
returns
.
items
[
i
]);

2062 
	`emit_instr
(
INSTR_NIL
);

2065 for (int 
i
 = 0; i < 
state
.
bound_symbols
.
count
; ++i) {

2066 
	`emit_instr
(
INSTR_POP_VAR
);

2067 
	`emit_symbol
(
state
.
bound_symbols
.
items
[
i
]->
symbol
);

2069 if (
state
.
try
)

2070 
	`emit_instr
(
INSTR_FINALLY
);

2071 if (
s
->
returns
.
count
 > 1) {

2072 
	`emit_instr
(
INSTR_MULTI_RETURN
);

2073 
	`emit_int
((int)
s
->
returns
.
count
 - 1);

2075 
	`emit_instr
(
INSTR_RETURN
);

2077 
returns
 = 
true
;

2079 case 
STATEMENT_BREAK
:

2080 if (
state
.
try
 > state.
loop
)

2081 
	`emit_instr
(
INSTR_FINALLY
);

2082 
	`emit_instr
(
INSTR_JUMP
);

2083 
	`vec_push
(
state
.
breaks
, state.
code
.
count
);

2084 
	`emit_int
(0);

2086 case 
STATEMENT_CONTINUE
:

2087 if (
state
.
try
 > state.
loop
)

2088 
	`emit_instr
(
INSTR_FINALLY
);

2089 
	`emit_instr
(
INSTR_JUMP
);

2090 
	`vec_push
(
state
.
continues
, state.
code
.
count
);

2091 
	`emit_int
(0);

2095 return 
returns
;

2096 
	}
}

2099 
	$emit_new_globals
(void)

2101 for (int 
i
 = 
global_count
; i < 
global
->
function_symbols
.
count
; ++i) {

2102 struct 
symbol
 *
s
 = 
global
->
function_symbols
.
items
[
i
];

2103 if (
s
->
symbol
 >= 
builtin_count
) {

2104 
	`emit_instr
(
INSTR_PUSH_VAR
);

2105 
	`emit_symbol
(
s
->
symbol
);

2106 if (
s
->
tag
 != -1) {

2107 
	`emit_instr
(
INSTR_TAG
);

2108 
	`emit_int
(
s
->
tag
);

2109 
	`emit_instr
(
INSTR_TARGET_VAR
);

2110 
	`emit_symbol
(
s
->
symbol
);

2111 
	`emit_instr
(
INSTR_ASSIGN
);

2112 
	`emit_instr
(
INSTR_POP
);

2113 } else if (
s
->
class
 != -1) {

2114 
	`emit_instr
(
INSTR_CLASS
);

2115 
	`emit_int
(
s
->
class
);

2116 
	`emit_instr
(
INSTR_TARGET_VAR
);

2117 
	`emit_symbol
(
s
->
symbol
);

2118 
	`emit_instr
(
INSTR_ASSIGN
);

2119 
	`emit_instr
(
INSTR_POP
);

2124 
global_count
 = 
global
->
function_symbols
.
count
;

2125 
	}
}

2127 static struct 
scope
 *

2128 
	$get_module_scope
(char const *
name
)

2130 for (int 
i
 = 0; i < 
modules
.
count
; ++i)

2131 if (
	`strcmp
(
name
, 
modules
.
items
[
i
].
path
) == 0)

2132 return 
modules
.
items
[
i
].
scope
;

2134 return 
NULL
;

2135 
	}
}

2138 
	$compile
(char const *
source
)

2140 struct 
statement
 **
p
 = 
	`parse
(
source
, 
state
.
filename
);

2141 if (
p
 == 
NULL
) {

2142 
err_msg
 = 
	`parse_error
();

2143 
	`longjmp
(
jb
, 1);

2146 for (
size_t
 
i
 = 0; 
p
[i] != 
NULL
; ++i) {

2147 if (
p
[
i
]->
type
 == 
STATEMENT_FUNCTION_DEFINITION
) {

2148 
	`symbolize_lvalue
(
state
.
global
, 
p
[
i
]->
target
, 
true
);

2149 
p
[
i
]->
value
->
name
 = 
NULL
;

2153 for (
size_t
 
i
 = 0; 
p
[i] != 
NULL
; ++i)

2154 
	`symbolize_statement
(
state
.
global
, 
p
[
i
]);

2156 for (int 
i
 = 0; i < 
state
.
exports
.
count
; ++i) {

2157 struct 
symbol
 *
s
 = 
	`scope_lookup
(
state
.
global
, state.
exports
.
items
[
i
]);

2158 if (
s
 == 
NULL
)

2159 
	`fail
("attempt to export non-existent variable '%s'", 
state
.
exports
.
items
[
i
]);

2160 
s
->
public
 = 
true
;

2163 
	`emit_new_globals
();

2182 
size_t
 
fi
 = 0;

2183 for (
size_t
 
i
 = 0; 
p
[i] != 
NULL
; ++i) {

2184 if (
p
[
i
]->
type
 == 
STATEMENT_FUNCTION_DEFINITION
) {

2185 struct 
statement
 *
s
 = 
p
[
fi
];

2186 
p
[
fi
++] = p[
i
];

2187 
p
[
i
] = 
s
;

2191 for (
size_t
 
i
 = 0; 
p
[i] != 
NULL
; ++i) {

2192 
	`emit_statement
(
p
[
i
]);

2195 
	`emit_instr
(
INSTR_HALT
);

2200 
	`add_location
((struct 
location
){});

2201 
	`patch_location_info
();

2202 
	`vec_push
(
location_lists
, 
state
.
expression_locations
);

2203 
	}
}

2206 
	$import_module
(struct 
statement
 const *
s
)

2208 char const *
name
 = 
s
->
import
.
module
;

2209 char const *
as
 = 
s
->
import
.as;

2211 struct 
scope
 *
module_scope
 = 
	`get_module_scope
(
name
);

2228 for (int 
i
 = 0; i < 
state
.
imports
.
count
; ++i) {

2229 if (
	`strcmp
(
as
, 
state
.
imports
.
items
[
i
].
name
) == 0)

2230 
	`fail
("there is already a module imported under the name '%s'", 
as
);

2231 if (
state
.
imports
.
items
[
i
].
scope
 == 
module_scope
)

2232 
	`fail
("the module '%s' has already been imported", 
name
);

2239 if (
module_scope
 != 
NULL
)

2240 goto 
import
;

2242 char *
source
 = 
	`slurp_module
(
name
);

2248 struct 
state
 
save
 = state;

2249 
state
 = 
	`freshstate
();

2250 
state
.
filename
 = 
name
;

2252 
	`compile
(
source
);

2254 
module_scope
 = 
state
.
global
;

2259 
module_scope
->
external
 = 
true
;

2261 struct 
module
 
m
 = {

2262 .
path
 = 
name
,

2263 .
code
 = 
state
.code.
items
,

2264 .
scope
 = 
module_scope


2267 
	`vec_push
(
modules
, 
m
);

2269 
state
 = 
save
;

2271 
	`emit_instr
(
INSTR_EXEC_CODE
);

2272 
	`emit_symbol
((
uintptr_t
) 
m
.
code
);

2274 
import
:

2276 char const **
identifiers
 = (char const **) 
s
->
import
.identifiers.
items
;

2277 int 
n
 = 
s
->
import
.
identifiers
.
count
;

2278 
bool
 
everything
 = 
n
 == 1 && 
	`strcmp
(
identifiers
[0], "..") == 0;

2280 if (
everything
) {

2281 char const *
id
 = 
	`scope_copy_public
(
state
.
global
, 
module_scope
);

2282 if (
id
 != 
NULL
)

2283 
	`fail
("module '%s' exports conflcting name '%s'", 
name
, 
id
);

2284 } else for (int 
i
 = 0; i < 
n
; ++i) {

2285 struct 
symbol
 *
s
 = 
	`scope_lookup
(
module_scope
, 
identifiers
[
i
]);

2286 if (
s
 == 
NULL
 || !s->
public
)

2287 
	`fail
("module '%s' does not export '%s'", 
name
, 
identifiers
[
i
]);

2288 if (
	`scope_lookup
(
state
.
global
, 
identifiers
[
i
]) != 
NULL
)

2289 
	`fail
("module '%s' exports conflicting name '%s'", 
name
, 
identifiers
[
i
]);

2290 
	`scope_insert
(
state
.
global
, 
s
);

2293 
	`vec_push
(
state
.
imports
, ((struct 
import
){ .
name
 = 
as
, .
scope
 = 
module_scope
 }));

2295 
	}
}

2298 
	$compiler_error
(void)

2300 return 
err_msg
;

2301 
	}
}

2304 
	$compiler_init
(void)

2306 
	`tags_init
();

2307 
	`class_new
("Object");

2308 
state
 = 
	`freshstate
();

2309 
global
 = 
state
.global;

2310 
	}
}

2313 
	$compiler_load_prelude
(void)

2315 
	`compile
(
	`slurp_module
("prelude"));

2316 
state
.
global
 = 
	`scope_new
(state.global, 
false
);

2317 return 
state
.
code
.
items
;

2318 
	}
}

2324 
	$compiler_introduce_symbol
(char const *
module
, char const *
name
)

2326 struct 
scope
 *
s
;

2327 if (
module
 == 
NULL
) {

2328 
s
 = 
global
;

2330 
s
 = 
	`get_module_scope
(
module
);

2332 if (
s
 == 
NULL
) {

2333 ++
builtin_modules
;

2334 
s
 = 
	`scope_new
(
NULL
, 
false
);

2335 
	`vec_push
(
modules
, ((struct 
module
){

2336 .
path
 = 
module
,

2337 .
code
 = 
NULL
,

2338 .
scope
 = 
s


2343 
	`addsymbol
(
s
, 
name
)->
public
 = 
true
;

2345 
builtin_count
 += 1;

2346 
	}
}

2349 
	$compiler_compile_source
(char const *
source
, char const *
filename
)

2351 
	`vec_init
(
state
.
code
);

2352 
	`vec_init
(
state
.
refs
);

2353 
	`vec_init
(
state
.
expression_locations
);

2355 
state
.
filename
 = filename;

2356 int 
symbol_count
 = 
	`scope_get_symbol
();

2358 if (
	`setjmp
(
jb
) != 0) {

2359 
	`scope_set_symbol
(
symbol_count
);

2360 return 
NULL
;

2363 
	`compile
(
source
);

2365 return 
state
.
code
.
items
;

2366 
	}
}

2369 
	$compiler_symbol_count
(void)

2371 return 
	`scope_get_symbol
();

2372 
	}
}

2374 struct 
location


2375 
	$compiler_get_location
(char const *
code
, char const **
file
)

2377 
location_vector
 *
locs
 = 
NULL
;

2378 *
file
 = 
NULL
;

2380 
uintptr_t
 
c
 = (uintptr_t) 
code
;

2386 for (int 
i
 = 0; i < 
location_lists
.
count
; ++i) {

2387 if (
location_lists
.
items
[
i
].
count
 == 0)

2389 if (
c
 < 
location_lists
.
items
[
i
].items[0].
p
)

2391 if (
c
 > 
	`vec_last
(
location_lists
.
items
[
i
])->
p
)

2393 
locs
 = &
location_lists
.
items
[
i
];

2397 if (
locs
 == 
NULL
)

2398 return (struct 
location
) { -1, -1 };

2403 int 
lo
 = 0,

2404 
hi
 = 
locs
->
count
 - 1;

2406 while (
lo
 <= 
hi
) {

2407 int 
m
 = (
lo
 / 2) + (
hi
 / 2) + (lo & hi & 1);

2408 if (
c
 < 
locs
->
items
[
m
].
p
) 
hi
 = m - 1;

2409 else if (
c
 > 
locs
->
items
[
m
].
p
) 
lo
 = m + 1;

2413 while (
lo
 > 0 && (lo >= 
locs
->
count
 || locs->
items
[lo].
p
 >= 
c
))

2414 --
lo
;

2416 *
file
 = 
locs
->
items
[
lo
].
filename
;

2418 return 
locs
->
items
[
lo
].
loc
;

2419 
	}
}

	@dict.c

1 #include 
	~<string.h
>

2 #include 
	~<stdio.h
>

3 #include 
	~<stdlib.h
>

4 #include 
	~<stdbool.h
>

6 #include 
	~"alloc.h
"

7 #include 
	~"util.h
"

8 #include 
	~"value.h
"

9 #include 
	~"dict.h
"

10 #include 
	~"log.h
"

11 #include 
	~"vm.h
"

12 #include 
	~"gc.h
"

14 struct 
dict
 *

15 
	$dict_new
(void)

17 struct 
dict
 *dict = 
	`gc_alloc_object
(sizeof *dict, 
GC_DICT
);

19 
dict
->
size
 = 16;

20 
dict
->
count
 = 0;

21 
dict
->
dflt
 = 
NIL
;

22 
dict
->
hashes
 = 
	`alloc
(sizeof (unsigned long [16]));

23 
dict
->
keys
 = 
	`alloc
(sizeof (struct 
value
 [16]));

24 
dict
->
values
 = 
	`alloc
(sizeof (struct 
value
 [16]));

26 
	`memset
(
dict
->
keys
, 0, sizeof (struct 
value
 [16]));

28 return 
dict
;

29 
	}
}

31 
inline
 static 
size_t


32 
	$find_spot
(
size_t
 
size
, unsigned long const *
hs
, struct 
value
 const *
vs
, unsigned long 
h
, struct value const *
v
)

34 
size_t
 
mask
 = 
size
 - 1;

35 
size_t
 
i
 = 
h
 & 
mask
;

37 while (
vs
[
i
].
type
 != 0 && (
hs
[i] != 
h
 || !
	`value_test_equality
(&vs[i], 
v
)))

38 
i
 = (i + 1) & 
mask
;

40 return 
i
;

41 
	}
}

43 
inline
 static void

44 
	$grow
(struct 
dict
 *
d
)

46 
size_t
 
oldsz
 = 
d
->
size
;

47 
d
->
size
 = 
oldsz
 << 2;

49 unsigned long *
hashes
 = 
	`alloc
(sizeof (unsigned long [
d
->
size
]));

50 struct 
value
 *
keys
 = 
	`alloc
(sizeof (struct value [
d
->
size
]));

51 struct 
value
 *
values
 = 
	`alloc
(sizeof (struct value [
d
->
size
]));

53 
	`memset
(
keys
, 0, sizeof (struct 
value
 [
d
->
size
]));

55 for (
size_t
 
i
 = 0; i < 
oldsz
; ++i) {

56 if (
d
->
keys
[
i
].
type
 == 0)

58 
size_t
 
j
 = 
	`find_spot
(
d
->
size
, 
hashes
, 
keys
, d->hashes[
i
], &d->keys[i]);

59 
hashes
[
j
] = 
d
->hashes[
i
];

60 
keys
[
j
] = 
d
->keys[
i
];

61 
values
[
j
] = 
d
->values[
i
];

64 
	`free
(
d
->
hashes
);

65 
	`free
(
d
->
keys
);

66 
	`free
(
d
->
values
);

68 
d
->
hashes
 = hashes;

69 
d
->
keys
 = keys;

70 
d
->
values
 = values;

71 
	}
}

73 
inline
 static struct 
value
 *

74 
	$put
(struct 
dict
 *
d
, 
size_t
 
i
, unsigned long 
h
, struct 
value
 
k
, struct value 
v
)

76 if (4 * 
d
->
count
 >= d->
size
)

77 
	`grow
(
d
);

79 
d
->
hashes
[
i
] = 
h
;

80 
d
->
keys
[
i
] = 
k
;

81 
d
->
values
[
i
] = 
v
;

82 
d
->
count
 += 1;

84 return &
d
->
values
[
i
];

85 
	}
}

87 struct 
value
 *

88 
	$dict_get_value
(struct 
dict
 *
d
, struct 
value
 *
key
)

90 unsigned long 
h
 = 
	`value_hash
(
key
);

91 
size_t
 
i
 = 
	`find_spot
(
d
->
size
, d->
hashes
, d->
keys
, 
h
, 
key
);

93 if (
d
->
keys
[
i
].
type
 != 0)

94 return &
d
->
values
[
i
];

96 if (
d
->
dflt
.
type
 != 
VALUE_NIL
) {

97 struct 
value
 
dflt
 = 
	`value_apply_callable
(&
d
->dflt, 
key
);

98 
	`put
(
d
, 
i
, 
h
, *
key
, 
dflt
);

99 return &
d
->
values
[
i
];

102 return 
NULL
;

103 
	}
}

106 
	$dict_put_value
(struct 
dict
 *
d
, struct 
value
 
key
, struct value value)

108 unsigned long 
h
 = 
	`value_hash
(&
key
);

109 
size_t
 
i
 = 
	`find_spot
(
d
->
size
, d->
hashes
, d->
keys
, 
h
, &
key
);

111 if (
d
->
keys
[
i
].
type
 != 0)

112 
d
->
values
[
i
] = 
value
;

114 
	`put
(
d
, 
i
, 
h
, 
key
, 
value
);

115 
	}
}

117 struct 
value
 *

118 
	$dict_put_key_if_not_exists
(struct 
dict
 *
d
, struct 
value
 
key
)

120 unsigned long 
h
 = 
	`value_hash
(&
key
);

121 
size_t
 
i
 = 
	`find_spot
(
d
->
size
, d->
hashes
, d->
keys
, 
h
, &
key
);

123 if (
d
->
keys
[
i
].
type
 != 0) {

124 return &
d
->
values
[
i
];

125 } else if (
d
->
dflt
.
type
 != 
VALUE_NIL
) {

126 return 
	`put
(
d
, 
i
, 
h
, 
key
, 
	`value_apply_callable
(&d->
dflt
, &key));

128 return 
	`put
(
d
, 
i
, 
h
, 
key
, 
NIL
);

130 
	}
}

132 struct 
value
 *

133 
	$dict_put_member_if_not_exists
(struct 
dict
 *
d
, char const *
member
)

135 return 
	`dict_put_key_if_not_exists
(
d
, 
	`STRING_NOGC
(
member
, 
	`strlen
(member)));

136 
	}
}

138 struct 
value
 *

139 
	$dict_get_member
(struct 
dict
 *
d
, char const *
key
)

141 struct 
value
 
string
 = 
	`STRING_NOGC
(
key
, 
	`strlen
(key));

142 return 
	`dict_get_value
(
d
, &
string
);

143 
	}
}

146 
	$dict_put_member
(struct 
dict
 *
d
, char const *
key
, struct 
value
 value)

148 struct 
value
 
string
 = 
	`STRING_NOGC
(
key
, 
	`strlen
(key));

149 
	`dict_put_value
(
d
, 
string
, 
value
);

150 
	}
}

153 
	$dict_mark
(struct 
dict
 *
d
)

155 
	`MARK
(
d
);

157 if (
d
->
dflt
.
type
 != 
VALUE_NIL
)

158 
	`value_mark
(&
d
->
dflt
);

160 for (
size_t
 
i
 = 0; i < 
d
->
size
; ++i) {

161 if (
d
->
keys
[
i
].
type
 != 0) {

162 
	`value_mark
(&
d
->
keys
[
i
]);

163 
	`value_mark
(&
d
->
values
[
i
]);

166 
	}
}

169 
	$dict_free
(struct 
dict
 *
d
)

171 
	`free
(
d
->
hashes
);

172 
	`free
(
d
->
keys
);

173 
	`free
(
d
->
values
);

174 
	}
}

176 static struct 
value


177 
	$dict_default
(struct 
value
 *
d
, 
value_vector
 *
args
)

179 if (
args
->
count
 == 0)

180 return 
d
->
dict
->
dflt
;

182 if (
args
->
count
 != 1)

183 
	`vm_panic
("dict.default() expects 1 or 0 arguments but got %zu", 
args
->
count
);

185 if (!
	`CALLABLE
(
args
->
items
[0]))

186 
	`vm_panic
("the argument to dict.default() must be callable");

188 
d
->
dict
->
dflt
 = 
args
->
items
[0];

190 return *
d
;

191 
	}
}

193 static struct 
value


194 
	$dict_contains
(struct 
value
 *
d
, 
value_vector
 *
args
)

196 if (
args
->
count
 != 1)

197 
	`vm_panic
("dict.contains() expects 1 argument but got %zu", 
args
->
count
);

199 struct 
value
 *
key
 = &
args
->
items
[0];

200 unsigned long 
h
 = 
	`value_hash
(
key
);

201 
size_t
 
i
 = 
	`find_spot
(
d
->
dict
->
size
, d->dict->
hashes
, d->dict->
keys
, 
h
, 
key
);

203 return 
	`BOOLEAN
(
d
->
dict
->
keys
[
i
].
type
 != 0);

204 
	}
}

206 static struct 
value


207 
	$dict_keys
(struct 
value
 *
d
, 
value_vector
 *
args
)

209 if (
args
->
count
 != 0)

210 
	`vm_panic
("dict.keys() expects 0 argument but got %zu", 
args
->
count
);

212 struct 
value
 
keys
 = 
	`ARRAY
(
	`value_array_new
());

214 
	`gc_push
(&
keys
);

216 for (
size_t
 
i
 = 0; i < 
d
->
dict
->
size
; ++i)

217 if (
d
->
dict
->
keys
[
i
].
type
 != 0)

218 
	`value_array_push
(
keys
.
array
, 
d
->
dict
->keys[
i
]);

220 
	`gc_pop
();

222 return 
keys
;

223 
	}
}

225 static struct 
value


226 
	$dict_values
(struct 
value
 *
d
, 
value_vector
 *
args
)

228 if (
args
->
count
 != 0)

229 
	`vm_panic
("dict.values() expects 0 argument but got %zu", 
args
->
count
);

231 struct 
value
 
values
 = 
	`ARRAY
(
	`value_array_new
());

233 
	`gc_push
(&
values
);

235 for (
size_t
 
i
 = 0; i < 
d
->
dict
->
size
; ++i)

236 if (
d
->
dict
->
keys
[
i
].
type
 != 0)

237 
	`value_array_push
(
values
.
array
, 
d
->
dict
->values[
i
]);

239 
	`gc_pop
();

241 return 
values
;

242 
	}
}

244 static struct 
value


245 
	$dict_len
(struct 
value
 *
d
, 
value_vector
 *
args
)

247 if (
args
->
count
 != 0)

248 
	`vm_panic
("dict.len() expects 0 argument but got %zu", 
args
->
count
);

250 return 
	`INTEGER
(
d
->
dict
->
count
);

251 
	}
}

253 
DEFINE_METHOD_TABLE
(

254 { .
name
 = "contains?", .
func
 = 
dict_contains
 },

255 { .
name
 = "default", .
func
 = 
dict_default
 },

256 { .
name
 = "keys", .
func
 = 
dict_keys
 },

257 { .
name
 = "len", .
func
 = 
dict_len
 },

258 { .
name
 = "values", .
func
 = 
dict_values
 },

261 
DEFINE_METHOD_LOOKUP
(
dict
);

	@functions.c

1 #include 
	~<inttypes.h
>

2 #include 
	~<math.h
>

3 #include 
	~<errno.h
>

4 #include 
	~<limits.h
>

5 #include 
	~<string.h
>

6 #include 
	~<stdnoreturn.h
>

8 #include 
	~<fcntl.h
>

9 #include 
	~<unistd.h
>

10 #include 
	~<dirent.h
>

11 #include 
	~<sys/types.h
>

12 #include 
	~<sys/socket.h
>

13 #include 
	~<sys/wait.h
>

14 #include 
	~<netdb.h
>

15 #include 
	~<sys/time.h
>

16 #include 
	~<poll.h
>

17 #include 
	~<signal.h
>

19 #include 
	~"tags.h
"

20 #include 
	~"value.h
"

21 #include 
	~"vm.h
"

22 #include 
	~"log.h
"

23 #include 
	~"util.h
"

24 #include 
	~"json.h
"

25 #include 
	~"dict.h
"

26 #include 
	~"object.h
"

28 static char 
	gbuffer
[1024];

30 #define 
	#ASSERT_ARGC
(
func
, 
argc
) \

31 if (
args
->
count
 != (
argc
)) { \

32 
	`vm_panic
(
func
 " expects " #argc " argument(s) but got %zu", 
args
->
count
); \

33 }

	)

35 #define 
	#ASSERT_ARGC_2
(
func
, 
argc1
, 
argc2
) \

36 if (
args
->
count
 != (
argc1
) && args->count != (
argc2
)) { \

37 
	`vm_panic
(
func
 " expects " #argc1 " or " #argc2 " argument(s) but got %zu", 
args
->
count
); \

38 }

	)

40 #define 
	#ASSERT_ARGC_3
(
func
, 
argc1
, 
argc2
, 
argc3
) \

41 if (
args
->
count
 != (
argc1
) && args->count != (
argc2
) && args->count != (
argc3
)) { \

42 
	`vm_panic
(
func
 " expects " #argc1 ", " #argc2 ", or " #argc3 " argument(s) but got %zu", 
args
->
count
); \

43 }

	)

45 struct 
value


46 
	$builtin_print
(
value_vector
 *
args
)

48 
	`ASSERT_ARGC
("print()", 1);

50 if (
args
->
items
[0].
type
 == 
VALUE_STRING
) {

51 
	`fwrite
(
args
->
items
[0].
string
, 1, args->items[0].
bytes
, 
stdout
);

53 char *
s
 = 
	`value_show
(&
args
->
items
[0]);

54 
	`fputs
(
s
, 
stdout
);

55 
	`free
(
s
);

58 
	`putchar
('\n');

60 return 
NIL
;

61 
	}
}

63 struct 
value


64 
	$builtin_die
(
value_vector
 *
args
)

66 
	`ASSERT_ARGC
("die()", 1);

68 struct 
value
 
message
 = 
args
->
items
[0];

69 if (
message
.
type
 != 
VALUE_STRING
)

70 
	`vm_panic
("the argument to die() must be a string");

72 
	`vm_panic
("%.*s", (int) 
message
.
bytes
, message.
string
);

73 
	}
}

75 struct 
value


76 
	$builtin_read
(
value_vector
 *
args
)

78 
	`ASSERT_ARGC
("read()", 0);

80 static 
	`vec
(char) 
input
;

81 
input
.
count
 = 0;

83 int 
c
;

84 while (
c
 = 
	`getchar
(), c != 
EOF
 && c != '\n')

85 
	`vec_push
(
input
, 
c
);

87 if (
input
.
count
 == 0 && 
c
 != '\n')

88 return 
NIL
;

90 return 
	`STRING_CLONE
(
input
.
items
, input.
count
);

91 
	}
}

93 struct 
value


94 
	$builtin_rand
(
value_vector
 *
args
)

96 int 
low
, 
high
;

98 
	`ASSERT_ARGC_3
("rand()", 0, 1, 2);

100 if (
args
->
count
 == 1 && args->
items
[0].
type
 == 
VALUE_ARRAY
) {

101 int 
n
 = 
args
->
items
[0].
array
->
count
;

102 if (
n
 == 0)

103 return 
NIL
;

105 return 
args
->
items
[0].
array
->items[
	`rand
() % 
n
];

108 for (int 
i
 = 0; i < 
args
->
count
; ++i)

109 if (
args
->
items
[
i
].
type
 != 
VALUE_INTEGER
)

110 
	`vm_panic
("non-integer passed as argument %d to rand", 
i
 + 1);

112 switch (
args
->
count
) {

113 case 0: 
low
 = 0; 
high
 = 
RAND_MAX
; break;

114 case 1: 
low
 = 0; 
high
 = 
args
->
items
[0].
integer
; break;

115 case 2: 
low
 = 
args
->
items
[0].
integer
; 
high
 = args->items[1].integer; break;

118 return 
	`INTEGER
((
	`rand
() % (
high
 - 
low
)) + low);

120 
	}
}

122 struct 
value


123 
	$builtin_float
(
value_vector
 *
args
)

125 
	`ASSERT_ARGC
("float()", 1);

127 struct 
value
 
v
 = 
args
->
items
[0];

129 switch (
v
.
type
) {

130 case 
VALUE_INTEGER
: return 
	`REAL
((float)
v
.
integer
);

131 case 
VALUE_REAL
: return 
v
;

132 case 
VALUE_STRING
:;

133 char 
buf
[128];

134 char *
end
;

135 unsigned 
n
 = 
	`umin
(
v
.
bytes
, 127);

137 
	`memcpy
(
buf
, 
v
.
string
, 
n
);

138 
buf
[
n
] = '\0';

140 
errno
 = 0;

141 float 
f
 = 
	`strtof
(
buf
, &
end
);

143 if (
errno
 != 0 || *
end
 != '\0')

144 return 
NIL
;

146 return 
	`REAL
(
f
);

149 
	`vm_panic
("invalid type passed to float()");

150 
	}
}

152 struct 
value


153 
	$builtin_blob
(
value_vector
 *
args
)

155 
	`ASSERT_ARGC
("blob()", 0);

156 return 
	`BLOB
(
	`value_blob_new
());

157 
	}
}

159 struct 
value


160 
	$builtin_int
(
value_vector
 *
args
)

162 struct 
value
 
v
 = 
	`INTEGER
(0), 
a
, 
s
, 
b
;

163 int 
base
;

165 char 
nbuf
[64] = {0};

167 char const *
string
 = 
nbuf
;

169 
	`ASSERT_ARGC_3
("int()", 0, 1, 2);

171 switch (
args
->
count
) {

172 case 0: 
v
.
integer
 = 0; return v;

173 case 1: goto 
coerce
;

174 case 2: goto 
custom_base
;

177 
coerce
:

179 
a
 = 
args
->
items
[0];

180 switch (
a
.
type
) {

181 case 
VALUE_INTEGER
: return 
a
;

182 case 
VALUE_REAL
: 
v
.
integer
 = 
a
.
real
; return v;

183 case 
VALUE_BOOLEAN
: 
v
.
integer
 = 
a
.
boolean
; return v;

184 case 
VALUE_ARRAY
: 
v
.
integer
 = 
a
.
array
->
count
; return v;

185 case 
VALUE_DICT
: 
v
.
integer
 = 
a
.
dict
->
count
; return v;

186 case 
VALUE_STRING
: 
base
 = 10; 
	`memcpy
(
nbuf
, 
a
.
string
, a.
bytes
); goto string;

187 default: return 
NIL
;

190 
custom_base
:

192 
s
 = 
args
->
items
[0];

193 
b
 = 
args
->
items
[1];

195 if (
s
.
type
 != 
VALUE_STRING
)

196 
	`vm_panic
("non-string passed as first of two arguments to int()");

197 if (
b
.
type
 != 
VALUE_INTEGER
)

198 
	`vm_panic
("non-integer passed as second argument to int()");

199 if (
b
.
integer
 < 0 || b.integer == 1 || b.integer > 36)

200 
	`vm_panic
("invalid base passed to int(): expected 0 or 2..36, but got %d", (int) 
b
.
integer
);

202 
base
 = 
b
.
integer
;

203 
	`memcpy
(
nbuf
, 
s
.
string
, s.
bytes
);

209 if (
base
 == 0 && 
string
[0] == '0' && string[1] == 'b') {

210 
base
 = 2;

211 
string
 += 2;

214 
string
:

216 
errno
 = 0;

218 char *
end
;

219 
intmax_t
 
n
 = 
	`strtoimax
(
string
, &
end
, 
base
);

221 if (
errno
 != 0 || *
end
 != '\0')

222 return 
NIL
;

224 
v
.
integer
 = 
n
;

226 return 
v
;

227 
	}
}

229 struct 
value


230 
	$builtin_str
(
value_vector
 *
args
)

232 
	`ASSERT_ARGC_2
("str()", 0, 1);

234 if (
args
->
count
 == 0)

235 return 
	`STRING_NOGC
(
NULL
, 0);

237 struct 
value
 
arg
 = 
args
->
items
[0];

238 if (
arg
.
type
 == 
VALUE_STRING
) {

239 return 
arg
;

241 char *
str
 = 
	`value_show
(&
arg
);

242 struct 
value
 
result
 = 
	`STRING_CLONE
(
str
, 
	`strlen
(str));

243 
	`free
(
str
);

244 return 
result
;

246 
	}
}

248 struct 
value


249 
	$builtin_bool
(
value_vector
 *
args
)

251 
	`ASSERT_ARGC
("bool()", 1);

252 return 
	`BOOLEAN
(
	`value_truthy
(&
args
->
items
[0]));

253 
	}
}

255 struct 
value


256 
	$builtin_regex
(
value_vector
 *
args
)

258 
	`ASSERT_ARGC
("regex()", 1);

260 struct 
value
 
pattern
 = 
args
->
items
[0];

262 if (
pattern
.
type
 == 
VALUE_REGEX
)

263 return 
pattern
;

265 if (
pattern
.
type
 != 
VALUE_STRING
)

266 
	`vm_panic
("non-string passed to regex()");

268 
	`snprintf
(
buffer
, sizeof buffer - 1, "%.*s", (int) 
pattern
.
bytes
, pattern.
string
);

270 char const *
err
;

271 int 
off
;

273 
pcre
 *
re
 = 
	`pcre_compile
(
buffer
, 0, &
err
, &
off
, 
NULL
);

274 if (
re
 == 
NULL
)

275 return 
NIL
;

277 
pcre_extra
 *
extra
 = 
	`pcre_study
(
re
, 
PCRE_STUDY_EXTRA_NEEDED
 | 
PCRE_STUDY_JIT_COMPILE
, &
err
);

278 if (
extra
 == 
NULL
)

279 return 
NIL
;

281 struct 
value
 
regex
 = 
	`REGEX
(
re
);

282 
regex
.
extra
 = extra;

283 
regex
.
pattern
 = 
	`sclone
(
buffer
);

285 return 
regex
;

286 
	}
}

288 struct 
value


289 
	$builtin_min
(
value_vector
 *
args
)

291 if (
args
->
count
 < 2)

292 
	`vm_panic
("min() expects 2 or more arguments, but got %zu", 
args
->
count
);

294 struct 
value
 
min
, 
v
;

295 
min
 = 
args
->
items
[0];

297 for (int 
i
 = 1; i < 
args
->
count
; ++i) {

298 
v
 = 
args
->
items
[
i
];

299 if (
	`value_compare
(&
v
, &
min
) < 0)

300 
min
 = 
v
;

303 return 
min
;

304 
	}
}

306 struct 
value


307 
	$builtin_max
(
value_vector
 *
args
)

309 if (
args
->
count
 < 2)

310 
	`vm_panic
("max() expects 2 or more arguments, but got %zu", 
args
->
count
);

312 struct 
value
 
max
, 
v
;

313 
max
 = 
args
->
items
[0];

315 for (int 
i
 = 1; i < 
args
->
count
; ++i) {

316 
v
 = 
args
->
items
[
i
];

317 if (
	`value_compare
(&
v
, &
max
) > 0)

318 
max
 = 
v
;

321 return 
max
;

322 
	}
}

324 struct 
value


325 
	$builtin_exp
(
value_vector
 *
args
)

327 
	`ASSERT_ARGC
("math::exp()", 1);

329 struct 
value
 
x
 = 
args
->
items
[0];

330 if (
x
.
type
 == 
VALUE_INTEGER
)

331 
x
 = 
	`REAL
(x.
integer
);

332 if (
x
.
type
 != 
VALUE_REAL
)

333 
	`vm_panic
("the argument to math::exp() must be a float");

335 return 
	`REAL
(
	`expf
(
x
.
real
));

336 
	}
}

338 struct 
value


339 
	$builtin_log
(
value_vector
 *
args
)

341 
	`ASSERT_ARGC
("math::log()", 1);

343 struct 
value
 
x
 = 
args
->
items
[0];

344 if (
x
.
type
 == 
VALUE_INTEGER
)

345 
x
 = 
	`REAL
(x.
integer
);

346 if (
x
.
type
 != 
VALUE_REAL
)

347 
	`vm_panic
("the argument to math::log() must be a float");

349 return 
	`REAL
(
	`logf
(
x
.
real
));

350 
	}
}

352 struct 
value


353 
	$builtin_log2
(
value_vector
 *
args
)

355 
	`ASSERT_ARGC
("math::log2()", 1);

357 struct 
value
 
x
 = 
args
->
items
[0];

358 if (
x
.
type
 == 
VALUE_INTEGER
)

359 
x
 = 
	`REAL
(x.
integer
);

360 if (
x
.
type
 != 
VALUE_REAL
)

361 
	`vm_panic
("the argument to math::log2() must be a float");

363 return 
	`REAL
(
	`log2f
(
x
.
real
));

364 
	}
}

366 struct 
value


367 
	$builtin_pow
(
value_vector
 *
args
)

369 
	`ASSERT_ARGC
("math::pow()", 2);

371 struct 
value
 
x
 = 
args
->
items
[0];

372 if (
x
.
type
 == 
VALUE_INTEGER
)

373 
x
 = 
	`REAL
(x.
integer
);

374 if (
x
.
type
 != 
VALUE_REAL
)

375 
	`vm_panic
("the first argument to math::pow() must be a float");

377 struct 
value
 
y
 = 
args
->
items
[1];

378 if (
y
.
type
 == 
VALUE_INTEGER
)

379 
y
 = 
	`REAL
(y.
integer
);

380 if (
y
.
type
 != 
VALUE_REAL
)

381 
	`vm_panic
("the second argument to math::pow() must be a float");

383 return 
	`REAL
(
	`powf
(
x
.
real
, 
y
.real));

384 
	}
}

386 struct 
value


387 
	$builtin_atan2
(
value_vector
 *
args
)

389 
	`ASSERT_ARGC
("math::atan2()", 2);

391 struct 
value
 
x
 = 
args
->
items
[0];

392 if (
x
.
type
 == 
VALUE_INTEGER
)

393 
x
 = 
	`REAL
(x.
integer
);

394 if (
x
.
type
 != 
VALUE_REAL
)

395 
	`vm_panic
("the first argument to math::atan2() must be a float");

397 struct 
value
 
y
 = 
args
->
items
[1];

398 if (
y
.
type
 == 
VALUE_INTEGER
)

399 
y
 = 
	`REAL
(y.
integer
);

400 if (
y
.
type
 != 
VALUE_REAL
)

401 
	`vm_panic
("the second argument to math::atan2() must be a float");

403 return 
	`REAL
(
	`atan2
(
x
.
real
, 
y
.real));

404 
	}
}

406 #define 
	#MATH_WRAP
(
func
) \

407 struct 
value
 \

408 
builtin_
 ## 
	`func
 (
value_vector
 *
args
) \

410 
	`ASSERT_ARGC
("math::" #func "()", 1); \

412 struct 
value
 
x
 = 
args
->
items
[0]; \

413 if (
x
.
type
 == 
VALUE_INTEGER
) \

414 
x
 = 
	`REAL
(x.
integer
); \

415 if (
x
.
type
 != 
VALUE_REAL
) \

416 
	`vm_panic
("the argument to math::" #func "() must be a float"); \

418 return 
	`REAL
(
func
 ## 
	`f
 (
x
.
real
)); \

419 }

	)

421 
	$MATH_WRAP
(
cos
)

422 
	$MATH_WRAP
(
sin
)

423 
	$MATH_WRAP
(
tan
)

424 
	$MATH_WRAP
(
acos
)

425 
	$MATH_WRAP
(
asin
)

426 
	$MATH_WRAP
(
atan
)

428 struct 
value


429 
	$builtin_sqrt
(
value_vector
 *
args
)

431 
	`ASSERT_ARGC
("math::sqrt()", 1);

433 struct 
value
 
x
 = 
args
->
items
[0];

434 if (
x
.
type
 == 
VALUE_INTEGER
)

435 
x
 = 
	`REAL
(x.
integer
);

436 if (
x
.
type
 != 
VALUE_REAL
)

437 
	`vm_panic
("the argument to math::sqrt() must be a float");

439 return 
	`REAL
(
	`sqrtf
(
x
.
real
));

440 
	}
}

442 struct 
value


443 
	$builtin_cbrt
(
value_vector
 *
args
)

445 
	`ASSERT_ARGC
("math::cbrt()", 1);

447 struct 
value
 
x
 = 
args
->
items
[0];

448 if (
x
.
type
 == 
VALUE_INTEGER
)

449 
x
 = 
	`REAL
(x.
integer
);

450 if (
x
.
type
 != 
VALUE_REAL
)

451 
	`vm_panic
("the argument to math::cbrt() must be a float");

453 return 
	`REAL
(
	`cbrtf
(
x
.
real
));

454 
	}
}

456 struct 
value


457 
	$builtin_bit_and
(
value_vector
 *
args
)

459 
	`ASSERT_ARGC
("bit::and()", 2);

461 struct 
value
 
a
 = 
args
->
items
[0];

462 if (
a
.
type
 != 
VALUE_INTEGER
)

463 
	`vm_panic
("the first argument to bit::and() must be an integer");

465 struct 
value
 
b
 = 
args
->
items
[1];

466 if (
b
.
type
 != 
VALUE_INTEGER
)

467 
	`vm_panic
("the second argument to bit::and() must be an integer");

469 return 
	`INTEGER
(
a
.
integer
 & 
b
.integer);

470 
	}
}

472 struct 
value


473 
	$builtin_bit_or
(
value_vector
 *
args
)

475 
	`ASSERT_ARGC
("bit::or()", 2);

477 struct 
value
 
a
 = 
args
->
items
[0];

478 if (
a
.
type
 != 
VALUE_INTEGER
)

479 
	`vm_panic
("the first argument to bit::or() must be an integer");

481 struct 
value
 
b
 = 
args
->
items
[1];

482 if (
b
.
type
 != 
VALUE_INTEGER
)

483 
	`vm_panic
("the second argument to bit::or() must be an integer");

485 return 
	`INTEGER
(
a
.
integer
 | 
b
.integer);

486 
	}
}

488 struct 
value


489 
	$builtin_bit_xor
(
value_vector
 *
args
)

491 
	`ASSERT_ARGC
("bit::xor()", 2);

493 struct 
value
 
a
 = 
args
->
items
[0];

494 if (
a
.
type
 != 
VALUE_INTEGER
)

495 
	`vm_panic
("the first argument to bit::xor() must be an integer");

497 struct 
value
 
b
 = 
args
->
items
[1];

498 if (
b
.
type
 != 
VALUE_INTEGER
)

499 
	`vm_panic
("the second argument to bit::xor() must be an integer");

501 return 
	`INTEGER
(
a
.
integer
 ^ 
b
.integer);

502 
	}
}

504 struct 
value


505 
	$builtin_bit_shift_left
(
value_vector
 *
args
)

507 
	`ASSERT_ARGC
("bit::shiftLeft()", 2);

509 struct 
value
 
a
 = 
args
->
items
[0];

510 if (
a
.
type
 != 
VALUE_INTEGER
)

511 
	`vm_panic
("the first argument to bit::shiftLeft() must be an integer");

513 struct 
value
 
b
 = 
args
->
items
[1];

514 if (
b
.
type
 != 
VALUE_INTEGER
)

515 
	`vm_panic
("the second argument to bit::shiftLeft() must be an integer");

517 return 
	`INTEGER
(
a
.
integer
 << 
b
.integer);

518 
	}
}

520 struct 
value


521 
	$builtin_bit_shift_right
(
value_vector
 *
args
)

523 
	`ASSERT_ARGC
("bit::shiftRight()", 2);

525 struct 
value
 
a
 = 
args
->
items
[0];

526 if (
a
.
type
 != 
VALUE_INTEGER
)

527 
	`vm_panic
("the first argument to bit::shiftRight() must be an integer");

529 struct 
value
 
b
 = 
args
->
items
[1];

530 if (
b
.
type
 != 
VALUE_INTEGER
)

531 
	`vm_panic
("the second argument to bit::shiftRight() must be an integer");

533 return 
	`INTEGER
(
a
.
integer
 >> 
b
.integer);

534 
	}
}

536 struct 
value


537 
	$builtin_bit_complement
(
value_vector
 *
args
)

539 
	`ASSERT_ARGC
("bit::complement()", 1);

541 struct 
value
 
a
 = 
args
->
items
[0];

542 if (
a
.
type
 != 
VALUE_INTEGER
)

543 
	`vm_panic
("the first argument to bit::complement() must be an integer");

545 return 
	`INTEGER
(~
a
.
integer
);

546 
	}
}

548 struct 
value


549 
	$builtin_setenv
(
value_vector
 *
args
)

551 static 
	`vec
(char) 
varbuf
;

552 static 
	`vec
(char) 
valbuf
;

554 
	`ASSERT_ARGC
("setenv()", 2);

556 struct 
value
 
var
 = 
args
->
items
[0];

557 struct 
value
 
val
 = 
args
->
items
[1];

559 if (
var
.
type
 != 
VALUE_STRING
 || 
val
.type != VALUE_STRING)

560 
	`vm_panic
("both arguments to setenv() must be strings");

562 
	`vec_push_n
(
varbuf
, 
var
.
string
, var.
bytes
);

563 
	`vec_push
(
varbuf
, '\0');

565 
	`vec_push_n
(
valbuf
, 
val
.
string
, val.
bytes
);

566 
	`vec_push
(
valbuf
, '\0');

568 
	`setenv
(
varbuf
.
items
, 
valbuf
.items, 1);

570 
varbuf
.
count
 = 0;

571 
valbuf
.
count
 = 0;

573 return 
NIL
;

574 
	}
}

576 struct 
value


577 
	$builtin_getenv
(
value_vector
 *
args
)

579 
	`ASSERT_ARGC
("getenv()", 1);

581 struct 
value
 
var
 = 
args
->
items
[0];

583 if (
var
.
type
 != 
VALUE_STRING
)

584 
	`vm_panic
("non-string passed to getenv()");

586 char 
buffer
[256];

588 if (
var
.
bytes
 >= sizeof 
buffer
)

589 
	`vm_panic
("argument to getenv() is too long: '%.10s..'", 
var
.
string
);

591 
	`memcpy
(
buffer
, 
var
.
string
, var.
bytes
);

592 
buffer
[
var
.
bytes
] = '\0';

594 char const *
val
 = 
	`getenv
(
buffer
);

596 if (
val
 == 
NULL
)

597 return 
NIL
;

599 return 
	`STRING_NOGC
(
val
, 
	`strlen
(val));

600 
	}
}

602 struct 
value


603 
	$builtin_json_parse
(
value_vector
 *
args
)

605 
	`ASSERT_ARGC
("json::parse()", 1);

607 struct 
value
 
json
 = 
args
->
items
[0];

608 if (
json
.
type
 != 
VALUE_STRING
)

609 
	`vm_panic
("non-string passed to json::parse()");

611 return 
	`json_parse
(
json
.
string
, json.
bytes
);

612 
	}
}

614 struct 
value


615 
	$builtin_os_open
(
value_vector
 *
args
)

617 
	`ASSERT_ARGC_2
("os::open()", 2, 3);

619 struct 
value
 
path
 = 
args
->
items
[0];

620 if (
path
.
type
 != 
VALUE_STRING
)

621 
	`vm_panic
("the path passed to os::open() must be a string");

623 static 
	`vec
(char) 
pathbuf
;

624 
pathbuf
.
count
 = 0;

625 
	`vec_push_n
(
pathbuf
, 
path
.
string
, path.
bytes
);

626 
	`vec_push
(
pathbuf
, '\0');

628 unsigned 
flags
 = 0;

630 struct 
value
 
flags_array
 = 
args
->
items
[1];

631 if (
flags_array
.
type
 != 
VALUE_ARRAY
)

632 
	`vm_panic
("the second argument to os::open() must be an array");

634 for (int 
i
 = 0; i < 
flags_array
.
array
->
count
; ++i) {

635 struct 
value
 
flag
 = 
flags_array
.
array
->
items
[
i
];

636 if (
flag
.
type
 != 
VALUE_INTEGER
)

637 
	`vm_panic
("non-integer passed as flag to os::open()");

638 
flags
 |= (unsigned) 
flag
.
integer
;

641 int 
fd
;

643 if (
flags
 & 
O_CREAT
) {

644 if (
args
->
count
 != 3)

645 
	`vm_panic
("os::open() called with O_CREAT but no third argument");

646 if (
args
->
items
[2].
type
 != 
VALUE_INTEGER
)

647 
	`vm_panic
("the third argument to os::open() must be an integer");

648 
fd
 = 
	`open
(
pathbuf
.
items
, 
flags
, (
mode_t
) 
args
->items[2].
integer
);

650 
fd
 = 
	`open
(
pathbuf
.
items
, 
flags
);

654 return 
	`INTEGER
(
fd
);

655 
	}
}

657 struct 
value


658 
	$builtin_os_close
(
value_vector
 *
args
)

660 
	`ASSERT_ARGC
("os::close()", 1);

662 struct 
value
 
file
 = 
args
->
items
[0];

664 if (
file
.
type
 != 
VALUE_INTEGER
)

665 
	`vm_panic
("the argument to os::close() must be an integer");

667 return 
	`INTEGER
(
	`close
(
file
.
integer
));

668 
	}
}

670 struct 
value


671 
	$builtin_os_read
(
value_vector
 *
args
)

673 
	`ASSERT_ARGC
("os::read()", 3);

675 struct 
value
 
file
 = 
args
->
items
[0];

676 struct 
value
 
blob
 = 
args
->
items
[1];

677 struct 
value
 
n
 = 
args
->
items
[2];

679 if (
file
.
type
 != 
VALUE_INTEGER
)

680 
	`vm_panic
("the first argument to os::read() must be an integer");

682 if (
blob
.
type
 != 
VALUE_BLOB
)

683 
	`vm_panic
("the second argument to os::read() must be a blob");

685 if (
n
.
type
 != 
VALUE_INTEGER
)

686 
	`vm_panic
("the third argument to os::read() must be an integer");

688 if (
n
.
integer
 < 0)

689 
	`vm_panic
("the second argument to os::read() must be non-negative");

691 
	`vec_reserve
(*
blob
.blob, blob.blob->
count
 + 
n
.
integer
);

693 
ssize_t
 
nr
 = 
	`read
(
file
.
integer
, 
blob
.blob->
items
 + blob.blob->
count
, 
n
.integer);

695 if (
nr
 != -1)

696 
blob
.blob->
count
 += 
nr
;

698 return 
	`INTEGER
(
nr
);

699 
	}
}

701 struct 
value


702 
	$builtin_os_write
(
value_vector
 *
args
)

704 
	`ASSERT_ARGC
("os::write()", 2);

706 struct 
value
 
file
 = 
args
->
items
[0];

707 struct 
value
 
data
 = 
args
->
items
[1];

709 if (
file
.
type
 != 
VALUE_INTEGER
)

710 
	`vm_panic
("the first argument to os::write() must be an integer");

712 
ssize_t
 
n
;

714 switch (
data
.
type
) {

715 case 
VALUE_BLOB
:

716 
n
 = 
	`write
(
file
.
integer
, (char *)
data
.
blob
->
items
, data.blob->
count
);

718 case 
VALUE_STRING
:

719 
n
 = 
	`write
(
file
.
integer
, 
data
.
string
, data.
bytes
);

722 
	`vm_panic
("invalid argument to os::write()");

725 return 
	`INTEGER
(
n
);

726 
	}
}

728 struct 
value


729 
	$builtin_os_spawn
(
value_vector
 *
args
)

731 
	`ASSERT_ARGC
("os::spawn()", 1);

733 struct 
value
 
cmd
 = 
args
->
items
[0];

734 if (
cmd
.
type
 != 
VALUE_ARRAY
)

735 
	`vm_panic
("the argument to os::spawn() must be an array");

737 if (
cmd
.
array
->
count
 == 0)

738 
	`vm_panic
("empty array passed to os::spawn()");

740 for (int 
i
 = 0; i < 
cmd
.
array
->
count
; ++i)

741 if (
cmd
.
array
->
items
[
i
].
type
 != 
VALUE_STRING
)

742 
	`vm_panic
("non-string in array passed to os::spawn()");

744 int 
in
[2];

745 int 
out
[2];

746 int 
err
[2];

747 int 
exc
[2];

749 if (
	`pipe
(
in
) == -1) {

750 return 
NIL
;

753 if (
	`pipe
(
out
) == -1) {

754 
	`close
(
in
[0]);

755 
	`close
(
in
[1]);

756 return 
NIL
;

759 if (
	`pipe
(
err
) == -1) {

760 
	`close
(
in
[0]);

761 
	`close
(
in
[1]);

762 
	`close
(
out
[0]);

763 
	`close
(
out
[1]);

764 return 
NIL
;

767 if (
	`pipe
(
exc
) == -1) {

768 
	`close
(
in
[0]);

769 
	`close
(
in
[1]);

770 
	`close
(
out
[0]);

771 
	`close
(
out
[1]);

772 
	`close
(
err
[0]);

773 
	`close
(
err
[1]);

774 return 
NIL
;

777 
pid_t
 
pid
 = 
	`fork
();

778 switch (
pid
) {

780 
	`close
(
in
[0]);

781 
	`close
(
in
[1]);

782 
	`close
(
out
[0]);

783 
	`close
(
out
[1]);

784 
	`close
(
err
[0]);

785 
	`close
(
err
[1]);

786 
	`close
(
exc
[0]);

787 
	`close
(
exc
[1]);

788 return 
NIL
;

790 
	`close
(
in
[1]);

791 
	`close
(
out
[0]);

792 
	`close
(
err
[0]);

794 if (
	`dup2
(
in
[0], 
STDIN_FILENO
) == -1

795 || 
	`dup2
(
out
[1], 
STDOUT_FILENO
) == -1

796 || 
	`dup2
(
err
[1], 
STDERR_FILENO
) == -1) {

797 
	`write
(
exc
[1], &
errno
, sizeof errno);

798 
	`exit
(
EXIT_FAILURE
);

801 
	`fcntl
(
exc
[1], 
F_SETFD
, 
FD_CLOEXEC
);

803 
	`vec
(char *) 
args
;

804 
	`vec_init
(
args
);

806 for (int 
i
 = 0; i < 
cmd
.
array
->
count
; ++i) {

807 char *
arg
 = 
	`alloc
(
cmd
.
array
->
items
[
i
].
bytes
 + 1);

808 
	`memcpy
(
arg
, 
cmd
.
array
->
items
[
i
].
string
, cmd.array->items[i].
bytes
 + 1);

809 
	`vec_push
(
args
, 
arg
);

812 
	`vec_push
(
args
, 
NULL
);

814 if (
	`execvp
(
args
.
items
[0], args.items) == -1) {

815 
	`write
(
exc
[1], &
errno
, sizeof errno);

816 
	`exit
(
EXIT_FAILURE
);

819 return 
NIL
;

821 
	`close
(
in
[0]);

822 
	`close
(
out
[1]);

823 
	`close
(
err
[1]);

824 
	`close
(
exc
[1]);

826 int 
status
;

827 if (
	`read
(
exc
[0], &
status
, sizeof status) != 0) {

828 
errno
 = 
status
;

829 
	`close
(
in
[1]);

830 
	`close
(
out
[0]);

831 
	`close
(
err
[0]);

832 
	`close
(
exc
[0]);

833 return 
NIL
;

836 
	`close
(
exc
[0]);

838 struct 
table
 *
result
 = 
	`object_new
();

840 
	`table_add
(
result
, "stdin", 
	`INTEGER
(
in
[1]));

841 
	`table_add
(
result
, "stdout", 
	`INTEGER
(
out
[0]));

842 
	`table_add
(
result
, "stderr", 
	`INTEGER
(
err
[0]));

843 
	`table_add
(
result
, "pid", 
	`INTEGER
(
pid
));

845 return 
	`OBJECT
(
result
, 0);

847 
	}
}

849 struct 
value


850 
	$builtin_os_fork
(
value_vector
 *
args
)

852 
	`ASSERT_ARGC
("os::fork()", 0);

853 return 
	`INTEGER
(
	`fork
());

854 
	}
}

856 struct 
value


857 
	$builtin_os_pipe
(
value_vector
 *
args
)

859 
	`ASSERT_ARGC
("os::pipe()", 0);

861 int 
p
[2];

863 if (
	`pipe
(
p
) == -1)

864 return 
NIL
;

866 struct 
array
 *
fds
 = 
	`value_array_new
();

868 
	`value_array_push
(
fds
, 
	`INTEGER
(
p
[0]));

869 
	`value_array_push
(
fds
, 
	`INTEGER
(
p
[1]));

871 return 
	`ARRAY
(
fds
);

872 
	}
}

874 struct 
value


875 
	$builtin_os_dup2
(
value_vector
 *
args
)

877 
	`ASSERT_ARGC
("os::dup2()", 2);

879 struct 
value
 
old
 = 
args
->
items
[0];

880 struct 
value
 
new
 = 
args
->
items
[1];

882 if (
old
.
type
 != 
VALUE_INTEGER
 || 
new
.type != VALUE_INTEGER)

883 
	`vm_panic
("the arguments to os::dup2() must be integers");

885 return 
	`INTEGER
(
	`dup2
(
old
.
integer
, 
new
.integer));

886 
	}
}

888 struct 
value


889 
	$builtin_os_poll
(
value_vector
 *
args
)

891 
	`ASSERT_ARGC
("os::poll()", 2);

893 struct 
value
 
fds
 = 
args
->
items
[0];

894 struct 
value
 
timeout
 = 
args
->
items
[1];

896 if (
fds
.
type
 != 
VALUE_ARRAY
)

897 
	`vm_panic
("the first argument to os::poll() must be an array");

899 if (
timeout
.
type
 != 
VALUE_INTEGER
)

900 
	`vm_panic
("the second argument to os::poll() must be an integer");

902 static 
	`vec
(struct 
pollfd
) 
pfds
;

903 
pfds
.
count
 = 0;

905 
	`vec_reserve
(
pfds
, 
fds
.
array
->
count
);

907 struct 
value
 *
v
;

908 for (int 
i
 = 0; i < 
fds
.
array
->
count
; ++i) {

909 if (
fds
.
array
->
items
[
i
].
type
 != 
VALUE_DICT
)

910 
	`vm_panic
("non-dict in fds array passed to os::poll()");

911 
v
 = 
	`dict_get_member
(
fds
.
array
->
items
[
i
].
dict
, "fd");

912 if (
v
 == 
NULL
 || v->
type
 != 
VALUE_INTEGER
)

913 
	`vm_panic
("all dicts in the fds array passed to os::poll() must have an integer value under the key 'fd'");

914 
pfds
.
items
[
i
].
fd
 = 
v
->
integer
;

915 
v
 = 
	`dict_get_member
(
fds
.
array
->
items
[
i
].
dict
, "events");

916 if (
v
 != 
NULL
 && v->
type
 == 
VALUE_INTEGER
)

917 
pfds
.
items
[
i
].
events
 = 
v
->
integer
;

919 
pfds
.
items
[
i
].
events
 = 
POLLIN
;

922 
pfds
.
count
 = 
fds
.
array
->count;

924 int 
ret
 = 
	`poll
(
pfds
.
items
, pfds.
count
, 
timeout
.
integer
);

925 if (
ret
 <= 0)

926 return 
	`INTEGER
(
ret
);

928 for (int 
i
 = 0; i < 
fds
.
array
->
count
; ++i)

929 
	`dict_put_member
(
fds
.
array
->
items
[
i
].
dict
, "revents", 
	`INTEGER
(
pfds
.items[i].
revents
));

931 return 
	`INTEGER
(
ret
);

932 
	}
}

934 struct 
value


935 
	$builtin_os_waitpid
(
value_vector
 *
args
)

937 
	`ASSERT_ARGC
("os::waitpid()", 2);

939 struct 
value
 
pid
 = 
args
->
items
[0];

940 struct 
value
 
flags
 = 
args
->
items
[1];

942 if (
pid
.
type
 != 
VALUE_INTEGER
 || 
flags
.type != VALUE_INTEGER)

943 
	`vm_panic
("both arguments to os::waitpid() must be integers");

945 int 
status
;

946 int 
ret
 = 
	`waitpid
(
pid
.
integer
, &
status
, 
flags
.integer);

948 if (
ret
 <= 0)

949 return 
	`INTEGER
(
ret
);

951 struct 
array
 *
result
 = 
	`value_array_new
();

952 
	`NOGC
(
result
);

954 
	`value_array_push
(
result
, 
	`INTEGER
(
ret
));

955 
	`value_array_push
(
result
, 
	`INTEGER
(
status
));

957 
	`OKGC
(
result
);

959 return 
	`ARRAY
(
result
);

960 
	}
}

962 #define 
	#WAITMACRO
(
name
) \

963 struct 
value
 \

964 
builtin_os_
 ## 
	`name
(
value_vector
 *
args
) \

966 
	`ASSERT_ARGC
("os::" #name, 1); \

968 struct 
value
 
status
 = 
args
->
items
[0]; \

969 if (
status
.
type
 != 
VALUE_INTEGER
) \

970 
	`vm_panic
("the argument to os::" #name "() must be an integer"); \

972 int 
s
 = 
status
.
integer
; \

974 return 
	`INTEGER
(
	`name
(
s
)); \

975 }

	)

977 
	$WAITMACRO
(
WIFEXITED
)

978 
	$WAITMACRO
(
WEXITSTATUS
)

979 
	$WAITMACRO
(
WIFSIGNALED
)

980 
	$WAITMACRO
(
WTERMSIG
)

981 
	$WAITMACRO
(
WIFSTOPPED
)

982 
	$WAITMACRO
(
WSTOPSIG
)

983 #ifdef 
WIFCONTINUED


984 
	$WAITMACRO
(
WIFCONTINUED
)

986 #ifdef 
WCOREDUMP


987 
	$WAITMACRO
(
WCOREDUMP
)

990 #define 
	#GETID
(
name
) \

991 struct 
value
 \

992 
builtin_os_
 ## 
	`name
 (
value_vector
 *
args
) \

994 
	`ASSERT_ARGC
("os::" #name, 0); \

995 return 
	`INTEGER
(
	`name
()); \

996 
	}

	)
}

998 #define 
	#SETID
(
name
) \

999 struct 
value
 \

1000 
builtin_os_
 ## 
	`name
 (
value_vector
 *
args
) \

1002 
	`ASSERT_ARGC
("os::" #name, 1); \

1003 struct 
value
 
id
 = 
args
->
items
[0]; \

1004 if (
id
.
type
 != 
VALUE_INTEGER
) \

1005 
	`vm_panic
("the argument to os::" #name "() must be an integer"); \

1006 return 
	`INTEGER
(
	`name
(
id
.
integer
)); \

1007 }

	)

1009 
	$GETID
(
getpid
)

1010 
	$GETID
(
getppid
)

1011 
	$GETID
(
getuid
)

1012 
	$GETID
(
geteuid
)

1013 
	$GETID
(
getgid
)

1014 
	$GETID
(
getegid
)

1015 
	$SETID
(
setuid
)

1016 
	$SETID
(
seteuid
)

1017 
	$SETID
(
setgid
)

1018 
	$SETID
(
setegid
)

1020 struct 
value


1021 
	$builtin_os_utime
(
value_vector
 *
args
)

1023 
	`ASSERT_ARGC
("os::utime()", 0);

1025 struct 
timeval
 
t
;

1026 
	`gettimeofday
(&
t
, 
NULL
);

1028 return 
	`INTEGER
(
t
.
tv_usec
 + t.
tv_sec
 * (
	`INTMAX_C
(1000000)));

1029 
	}
}

1031 
noreturn
 struct 
value


1032 
	$builtin_os_exit
(
value_vector
 *
args
)

1034 
	`ASSERT_ARGC
("os::exit()", 1);

1036 struct 
value
 
status
 = 
args
->
items
[0];

1037 if (
status
.
type
 != 
VALUE_INTEGER
)

1038 
	`vm_panic
("the argument to os::exit() must be an integer");

1040 
	`exit
(
status
.
integer
);

1041 
	}
}

1043 struct 
value


1044 
	$builtin_os_exec
(
value_vector
 *
args
)

1046 
	`ASSERT_ARGC
("os::exec()", 1);

1048 struct 
value
 
cmd
 = 
args
->
items
[0];

1049 if (
cmd
.
type
 != 
VALUE_ARRAY
)

1050 
	`vm_panic
("the argument to os::exec() must be an array");

1052 if (
cmd
.
array
->
count
 == 0)

1053 
	`vm_panic
("empty array passed to os::exec()");

1055 for (int 
i
 = 0; i < 
cmd
.
array
->
count
; ++i)

1056 if (
cmd
.
array
->
items
[
i
].
type
 != 
VALUE_STRING
)

1057 
	`vm_panic
("non-string in array passed to os::exec()");

1059 
	`vec
(char *) 
argv
;

1060 
	`vec_init
(
argv
);

1062 for (int 
i
 = 0; i < 
cmd
.
array
->
count
; ++i) {

1063 char *
arg
 = 
	`alloc
(
cmd
.
array
->
items
[
i
].
bytes
 + 1);

1064 
	`memcpy
(
arg
, 
cmd
.
array
->
items
[
i
].
string
, cmd.array->items[i].
bytes
 + 1);

1065 
	`vec_push
(
argv
, 
arg
);

1068 
	`vec_push
(
argv
, 
NULL
);

1070 return 
	`INTEGER
(
	`execvp
(
argv
.
items
[0], argv.items));

1071 
	}
}

1073 struct 
value


1074 
	$builtin_os_kill
(
value_vector
 *
args
)

1076 
	`ASSERT_ARGC
("os::kill()", 2);

1078 struct 
value
 
pid
 = 
args
->
items
[0];

1079 struct 
value
 
sig
 = 
args
->
items
[1];

1081 if (
pid
.
type
 != 
VALUE_INTEGER
 || 
sig
.type != VALUE_INTEGER)

1082 
	`vm_panic
("both arguments to os::kill() must be integers");

1084 return 
	`INTEGER
(
	`kill
(
pid
.
integer
, 
sig
.integer));

1085 
	}
}

1087 struct 
value


1088 
	$builtin_os_connect
(
value_vector
 *
args
)

1090 static 
	`vec
(char) 
host
;

1091 static 
	`vec
(char) 
port
;

1093 
host
.
count
 = 0;

1094 
port
.
count
 = 0;

1096 
	`ASSERT_ARGC
("os::connect()", 2);

1098 struct 
value
 
h
 = 
args
->
items
[0];

1099 if (
h
.
type
 != 
VALUE_STRING
)

1100 
	`vm_panic
("the first argument to os::connect() must be a string");

1102 
	`vec_push_n
(
host
, 
h
.
string
, h.
bytes
);

1103 
	`vec_push
(
host
, '\0');

1105 struct 
value
 
p
 = 
args
->
items
[1];

1106 switch (
p
.
type
) {

1107 case 
VALUE_STRING
:

1108 
	`vec_push_n
(
port
, 
p
.
string
, p.
bytes
);

1109 
	`vec_push
(
port
, '\0');

1111 case 
VALUE_INTEGER
:

1112 
	`vec_reserve
(
port
, 16);

1113 
	`snprintf
(
port
.
items
, 16, "%d", (int) 
p
.
integer
);

1116 
	`vm_panic
("the second argument to os::connect() must be a string or an int");

1119 struct 
addrinfo
 
hints
, *
result
;

1120 int 
conn
;

1122 
	`memset
(&
hints
, 0, sizeof hints);

1124 
hints
.
ai_family
 = 
AF_INET
;

1125 
hints
.
ai_socktype
 = 
SOCK_STREAM
;

1127 if (
	`getaddrinfo
(
host
.
items
, 
port
.items, &
hints
, &
result
) != 0)

1128 return 
NIL
;

1129 if ((
conn
 = 
	`socket
(
result
->
ai_family
, result->
ai_socktype
, result->
ai_protocol
)) == -1)

1130 return 
NIL
;

1131 if (
	`connect
(
conn
, 
result
->
ai_addr
, result->
ai_addrlen
) == -1) {

1132 
	`close
(
conn
);

1133 return 
NIL
;

1136 return 
	`INTEGER
(
conn
);

1137 
	}
}

1139 struct 
value


1140 
	$builtin_os_usleep
(
value_vector
 *
args
)

1142 
	`ASSERT_ARGC
("os::usleep()", 1);

1144 struct 
value
 
duration
 = 
args
->
items
[0];

1145 if (
duration
.
type
 != 
VALUE_INTEGER
)

1146 
	`vm_panic
("the argument to os::usleep() must be an integer");

1148 if (
duration
.
integer
 < 0)

1149 
	`vm_panic
("negative argument passed to os::usleep()");

1151 return 
	`INTEGER
(
	`usleep
(
duration
.
integer
));

1152 
	}
}

1154 struct 
value


1155 
	$builtin_os_listdir
(
value_vector
 *
args
)

1157 
	`ASSERT_ARGC
("os::listdir()", 1);

1159 struct 
value
 
dir
 = 
args
->
items
[0];

1160 if (
dir
.
type
 != 
VALUE_STRING
)

1161 
	`vm_panic
("the argument to os::listdir() must be a string");

1163 static 
	`vec
(char) 
dirbuf
;

1164 
dirbuf
.
count
 = 0;

1165 
	`vec_push_n
(
dirbuf
, 
dir
.
string
, dir.
bytes
);

1166 
	`vec_push
(
dirbuf
, '\0');

1168 
DIR
 *
d
 = 
	`opendir
(
dirbuf
.
items
);

1169 if (
d
 == 
NULL
)

1170 return 
NIL
;

1173 struct 
array
 *
files
 = 
	`value_array_new
();

1175 struct 
dirent
 *
e
;

1177 while (
e
 = 
	`readdir
(
d
), e != 
NULL
)

1178 if (
	`strcmp
(
e
->
d_name
, ".") != 0 && strcmp(e->d_name, "..") != 0)

1179 
	`vec_push
(*
files
, 
	`STRING_CLONE
(
e
->
d_name
, 
	`strlen
(e->d_name)));

1181 
	`closedir
(
d
);

1183 return 
	`ARRAY
(
files
);

1184 
	}
}

1186 struct 
value


1187 
	$builtin_os_fcntl
(
value_vector
 *
args
)

1189 
	`ASSERT_ARGC_2
("os::fcntl()", 2, 3);

1191 struct 
value
 
fd
 = 
args
->
items
[0];

1192 if (
fd
.
type
 != 
VALUE_INTEGER
)

1193 
	`vm_panic
("the first argument to os::fcntl() must be an integer");

1195 struct 
value
 
cmd
 = 
args
->
items
[1];

1196 if (
fd
.
type
 != 
VALUE_INTEGER
)

1197 
	`vm_panic
("the second argument to os::fcntl() must be an integer");

1199 if (
args
->
count
 == 2)

1200 return 
	`INTEGER
(
	`fcntl
(
fd
.
integer
, 
cmd
.integer));

1202 struct 
value
 
arg
 = 
args
->
items
[2];

1203 switch (
cmd
.
integer
) {

1204 case 
F_DUPFD
:

1205 #ifdef 
__APPLE__


1206 case 
F_DUPFD_CLOEXEC
:

1208 case 
F_SETFD
:

1209 case 
F_SETFL
:

1210 if (
arg
.
type
 != 
VALUE_INTEGER
)

1211 
	`vm_panic
("the third argument to os::fcntl() must be an integer when it is called with F_DUPFD");

1212 return 
	`INTEGER
(
	`fcntl
(
fd
.
integer
, 
cmd
.integer, (int) 
arg
.integer));

1215 
	`vm_panic
("os::fcntl() functionality not implemented yet");

1216 
	}
}

1218 struct 
value


1219 
	$builtin_errno_get
(
value_vector
 *
args
)

1221 
	`ASSERT_ARGC
("errno::get()", 0);

1222 return 
	`INTEGER
(
errno
);

1223 
	}
}

1225 struct 
value


1226 
	$builtin_errno_str
(
value_vector
 *
args
)

1228 
	`ASSERT_ARGC_2
("errno::str()", 0, 1);

1230 int 
e
;

1232 if (
args
->
count
 == 0) {

1233 
e
 = 
errno
;

1235 if (
args
->
items
[0].
type
 != 
VALUE_INTEGER
)

1236 
	`vm_panic
("the argument to errno::str() must be an integer");

1237 
e
 = 
args
->
items
[0].
integer
;

1240 char const *
s
 = 
	`strerror
(
e
);

1242 return 
	`STRING_CLONE
(
s
, 
	`strlen
(s));

1243 
	}
}

	@gc.c

1 #include 
	~<string.h
>

3 #include 
	~"value.h
"

4 #include 
	~"gc.h
"

5 #include 
	~"dict.h
"

6 #include 
	~"object.h
"

7 #include 
	~"vm.h
"

8 #include 
	~"log.h
"

10 #define 
	#GC_ALLOC_THRESHOLD
 (1ULL << 24)

	)

13 static 
size_t
 
	gallocated
 = 0;

14 static 
	$vec
(struct 
value
 *) 
root_set
;

15 static 
	$vec
(struct 
alloc
 *) 
allocs
;

17 
bool
 
GC_ENABLED
 = 
true
;

19 
inline
 static void

20 
	$collect
(struct 
alloc
 *
a
)

22 void *
p
 = 
a
->
data
;

24 switch (
a
->
type
) {

25 case 
GC_ARRAY
: 
	`free
(((struct 
array
 *)
p
)->
items
); break;

26 case 
GC_BLOB
: 
	`free
(((struct 
blob
 *)
p
)->
items
); break;

27 case 
GC_DICT
: 
	`dict_free
(
p
); break;

28 case 
GC_OBJECT
: 
	`object_free
(
p
); break;

31 
	`free
(
a
);

32 
	}
}

34 
inline
 static void

35 
	$gc
(void)

37 
	`vm_mark
();

39 for (int 
i
 = 0; i < 
root_set
.
count
; ++i) {

40 
	`value_mark
(
root_set
.
items
[
i
]);

43 int 
len
 = 0;

44 for (int 
i
 = 0; i < 
allocs
.
count
; ++i) {

45 if (
allocs
.
items
[
i
]->
mark
 == 
GC_NONE
) {

46 
	`collect
(
allocs
.
items
[
i
]);

48 
allocs
.
items
[
i
]->
mark
 &= ~
GC_MARK
;

49 
allocs
.
items
[
len
++] = allocs.items[
i
];

53 
allocs
.
count
 = 
len
;

54 
allocated
 = 0;

55 
	}
}

58 
	$gc_alloc
(
size_t
 
n
)

60 void *
mem
 = 
	`alloc
(
n
);

62 
allocated
 += 
n
;

64 if (
allocated
 > 
GC_ALLOC_THRESHOLD
 && 
GC_ENABLED
)

65 
	`gc
();

67 return 
mem
;

68 
	}
}

71 
	$gc_notify
(
size_t
 
n
)

73 
allocated
 += 
n
;

74 if (
allocated
 > 
GC_ALLOC_THRESHOLD
 && 
GC_ENABLED
)

75 
	`gc
();

76 
	}
}

79 
	$gc_alloc_object
(
size_t
 
n
, char 
type
)

81 struct 
alloc
 *
a
 = 
	`alloc
(sizeof *a + 
n
);

83 
allocated
 += 
n
;

85 
a
->
mark
 = 
GC_NONE
;

86 
a
->
type
 = type;

88 if (
allocated
 > 
GC_ALLOC_THRESHOLD
 && 
GC_ENABLED
)

89 
	`gc
();

91 
	`vec_push
(
allocs
, 
a
);

93 return 
a
->
data
;

94 
	}
}

97 
	$gc_register
(void *
p
)

99 
	`vec_push
(
allocs
, 
	`ALLOC_OF
(
p
));

100 
	}
}

103 
	$_gc_push
(struct 
value
 *
v
)

105 
	`vec_push
(
root_set
, 
v
);

106 
	}
}

109 
	$gc_pop
(void)

111 --
root_set
.
count
;

112 
	}
}

115 
	$gc_clear_root_set
(void)

117 
root_set
.
count
 = 0;

118 
	}
}

121 
	$gc_truncate_root_set
(
size_t
 
n
)

123 
root_set
.
count
 = 
n
;

124 
	}
}

126 
size_t


127 
	$gc_root_set_count
(void)

129 return 
root_set
.
count
;

130 
	}
}

	@json.c

1 #include 
	~<setjmp.h
>

2 #include 
	~<ctype.h
>

3 #include 
	~<stdlib.h
>

4 #include 
	~<errno.h
>

6 #include 
	~"test.h
"

7 #include 
	~"value.h
"

8 #include 
	~"dict.h
"

9 #include 
	~"util.h
"

10 #include 
	~"vec.h
"

11 #include 
	~"vm.h
"

13 #define 
	#KW_DELIM
(
c
) (
	`strchr
(" \n}],", c) != 
NULL
)

	)

14 #define 
	#FAIL
 
	`longjmp
(
jb
, 1)

	)

16 static 
jmp_buf
 
	gjb
;

17 static char const *
	gjson
;

18 static int 
	glen
;

20 
inline
 static char

21 
	$peek
(void)

23 if (
len
 <= 0)

26 return *
json
;

27 
	}
}

29 
inline
 static char

30 
	$next
(void)

32 if (
len
 <= 0)

34 --
len
;

35 return *
json
++;

36 
	}
}

38 static struct 
value


39 
value
(void);

41 
inline
 static void

42 
	$space
(void)

44 while (
	`isspace
(
	`peek
())) 
	`next
();

45 
	}
}

47 static struct 
value


48 
	$number
(void)

50 char 
numbuf
[512];

51 char const *
num
 = 
json
;

52 
bool
 
integral
 = 
true
;

54 if (
	`peek
() == '-')

55 
	`next
();

57 if (!
	`isdigit
(
	`peek
()))

58 
FAIL
;

60 while (
	`isdigit
(
	`peek
()))

61 
	`next
();

63 if (
	`peek
() == '.') {

64 
integral
 = 
false
;

65 
	`next
();

66 if (!
	`isdigit
(
	`peek
()))

67 
FAIL
;

68 while (
	`isdigit
(
	`peek
()))

69 
	`next
();

72 if (
	`peek
() == 'e' || peek() == 'E') {

73 
integral
 = 
false
;

74 
	`next
();

75 if (
	`peek
() == '-' || peek() == '+')

76 
	`next
();

77 if (!
	`isdigit
(
	`peek
()))

78 
FAIL
;

79 while (
	`isdigit
(
	`peek
()))

80 
	`next
();

83 int 
n
 = 
	`min
(
json
 - 
num
, sizeof 
numbuf
 - 1);

84 
	`memcpy
(
numbuf
, 
num
, 
n
);

85 
numbuf
[
n
] = '\0';

87 struct 
value
 
result
;

89 
errno
 = 0;

90 if (
integral
)

91 
result
 = 
	`INTEGER
(
	`strtoimax
(
num
, 
NULL
, 10));

93 
result
 = 
	`REAL
(
	`strtod
(
num
, 
NULL
));

95 if (
errno
 != 0)

96 
FAIL
;

98 return 
result
;

99 
	}
}

101 static struct 
value


102 
	$null
(void)

104 if (
	`strncmp
(
json
, "null", 4) != 0)

105 
FAIL
;

107 if (!
	`KW_DELIM
(
json
[4]))

108 
FAIL
;

110 
json
 += 4;

111 
len
 -= 4;

113 return 
NIL
;

114 
	}
}

116 static struct 
value


117 
	$jtrue
(void)

119 if (
	`strncmp
(
json
, "true", 4) != 0)

120 
FAIL
;

122 if (!
	`KW_DELIM
(
json
[4]))

123 
FAIL
;

125 
json
 += 4;

126 
len
 -= 4;

128 return 
	`BOOLEAN
(
true
);

129 
	}
}

131 static struct 
value


132 
	$jfalse
(void)

134 if (
	`strncmp
(
json
, "false", 5) != 0)

135 
FAIL
;

137 if (!
	`KW_DELIM
(
json
[5]))

138 
FAIL
;

140 
json
 += 5;

141 
len
 -= 5;

143 return 
	`BOOLEAN
(
false
);

144 
	}
}

146 static struct 
value


147 
	$string
(void)

149 if (
	`next
() != '"')

150 
FAIL
;

152 
	`vec
(char) 
str
;

153 
	`vec_init
(
str
);

155 while (
	`peek
() != '\0' && peek() != '"') {

156 if (
	`peek
() == '\\') switch (
	`next
(), next()) {

157 case 't': 
	`vec_push
(
str
, '\t'); break;

158 case 'f': 
	`vec_push
(
str
, '\f'); break;

159 case 'n': 
	`vec_push
(
str
, '\n'); break;

160 case 'r': 
	`vec_push
(
str
, '\r'); break;

161 case 'b': 
	`vec_push
(
str
, '\b'); break;

162 case '"': 
	`vec_push
(
str
, '"'); break;

163 case '/': 
	`vec_push
(
str
, '/'); break;

164 case '\\': 
	`vec_push
(
str
, '\\'); break;

165 } else 
	`vec_push
(
str
, 
	`next
());

168 if (
	`next
() != '"')

169 
FAIL
;

171 int 
n
 = 
str
.
count
;

173 if (
n
 == 0)

174 return 
	`STRING_NOGC
(
NULL
, 0);

176 char *
s
 = 
	`value_string_alloc
(
n
);

177 
	`memcpy
(
s
, 
str
.
items
, 
n
);

179 
	`vec_empty
(
str
);

181 return 
	`STRING
(
s
, 
n
);

182 
	}
}

184 static struct 
value


185 
	$array
(void)

187 if (
	`next
() != '[')

188 
FAIL
;

190 struct 
array
 *
a
 = 
	`value_array_new
();

192 while (
	`peek
() != '\0' && peek() != ']') {

193 
	`vec_push
(*
a
, 
	`value
());

194 
	`space
();

195 if (
	`peek
() != ']' && 
	`next
() != ',')

196 
FAIL
;

199 if (
	`next
() != ']')

200 
FAIL
;

202 return 
	`ARRAY
(
a
);

203 
	}
}

205 static struct 
value


206 
	$object
(void)

208 if (
	`next
() != '{')

209 
FAIL
;

211 struct 
dict
 *
obj
 = 
	`dict_new
();

213 while (
	`peek
() != '\0' && peek() != '}') {

214 
	`space
();

215 struct 
value
 
key
 = 
	`string
();

216 
	`space
();

217 if (
	`next
() != ':')

218 
FAIL
;

219 struct 
value
 
val
 = 
	`value
();

220 
	`dict_put_value
(
obj
, 
key
, 
val
);

221 
	`space
();

222 if (
	`peek
() != '}' && 
	`next
() != ',')

223 
FAIL
;

226 if (
	`next
() != '}')

227 
FAIL
;

229 return 
	`DICT
(
obj
);

230 
	}
}

232 static struct 
value


233 
	$value
(void)

235 
	`space
();

237 switch (
	`peek
()) {

238 case '{': return 
	`object
();

239 case '[': return 
	`array
();

240 case '"': return 
	`string
();

241 case 'n': return 
	`null
();

242 case 't': return 
	`jtrue
();

243 case 'f': return 
	`jfalse
();

246 return 
	`number
();

247 default: 
FAIL
;

249 
	}
}

251 struct 
value


252 
	$json_parse
(char const *
s
, int 
n
)

254 
json
 = 
s
;

255 
len
 = 
n
;

257 
	`gc_disable
();

259 if (
	`setjmp
(
jb
) != 0) {

260 
	`gc_enable
();

261 return 
NIL
;

264 struct 
value
 
v
 = 
	`value
();

265 
	`space
();

267 if (
	`peek
() != '\0')

268 
v
 = 
NIL
;

270 
	`gc_enable
();

271 
	`gc_alloc
(0);

273 return 
v
;

274 
	}
}

276 
	$TEST
(
null
)

278 
	`vm_init
(0, 
NULL
);

279 char const *
s
 = " null ";

280 struct 
value
 
v
 = 
	`json_parse
(
s
, 6);

281 
	`claim
(
	`value_test_equality
(&
v
, &
NIL
));

282 
	}
}

284 
	$TEST
(
jtrue
)

286 
	`vm_init
(0, 
NULL
);

287 char const *
s
 = " true";

288 struct 
value
 
v
 = 
	`json_parse
(
s
, 5);

289 
	`claim
(
	`value_test_equality
(&
v
, &
	`BOOLEAN
(
true
)));

290 
	}
}

292 
	$TEST
(
jfalse
)

294 
	`vm_init
(0, 
NULL
);

295 char const *
s
 = " false";

296 struct 
value
 
v
 = 
	`json_parse
(
s
, 6);

297 
	`claim
(
	`value_test_equality
(&
v
, &
	`BOOLEAN
(
false
)));

298 
	}
}

	@lex.c

1 #include 
	~<ctype.h
>

2 #include 
	~<setjmp.h
>

3 #include 
	~<stdarg.h
>

4 #include 
	~<string.h
>

5 #include 
	~<stdbool.h
>

6 #include 
	~<stdnoreturn.h
>

7 #include 
	~<assert.h
>

8 #include 
	~<errno.h
>

9 #include 
	~<math.h
>

11 #include 
	~"vec.h
"

12 #include 
	~"token.h
"

13 #include 
	~"test.h
"

14 #include 
	~"util.h
"

15 #include 
	~"lex.h
"

16 #include 
	~"log.h
"

19 
	mMAX_OP_LEN
 = 8,

20 
	mMAX_ERR_LEN
 = 2048

23 static struct 
location
 
	gstartloc
;

24 static struct 
location
 
	gloc
;

26 static char const *
	gfilename
;

28 static 
jmp_buf
 
	gjb
;

29 static 
bool
 
	gkeep_next_newline
;

31 static char 
	gerrbuf
[
MAX_ERR_LEN
 + 1];

33 static 
	$vec
(char const *) 
states
;

34 static char const *
chars
;

36 static char const *
opchars
 = "/=<~|!@%^&*-+>?.$";

38 
noreturn
 static void

39 
	$error
(char const *
fmt
, ...)

41 
va_list
 
ap
;

42 
	`va_start
(
ap
, 
fmt
);

44 char *
err
 = 
errbuf
;

45 
err
 += 
	`sprintf
(err, "SyntaxError %s:%d:%d: ", 
filename
, 
loc
.
line
 + 1, loc.
col
 + 1);

46 
err
[
	`vsnprintf
(err, 
MAX_ERR_LEN
, 
fmt
, 
ap
)] = '\0';

48 
	`va_end
(
ap
);

50 
	`longjmp
(
jb
, 1);

51 
	}
}

53 static struct 
token


54 
	$mktoken
(int 
type
)

56 return (struct 
token
) {

57 .
type
 = type,

58 .
loc
 = 
startloc
,

60 
	}
}

62 static struct 
token


63 
	$mkid
(char *
id
, char *
module
)

65 return (struct 
token
) {

66 .
type
 = 
TOKEN_IDENTIFIER
,

67 .
identifier
 = 
id
,

68 .
module
 = module,

69 .
loc
 = 
startloc
,

71 
	}
}

73 static struct 
token


74 
	$mkstring
(char *
string
)

76 return (struct 
token
) {

77 .
type
 = 
TOKEN_STRING
,

78 .
string
 = string,

79 .
loc
 = 
startloc
,

81 
	}
}

83 static struct 
token


84 
	$mkregex
(char const *
pat
, int 
flags
)

86 char const *
err
;

87 int 
offset
;

89 
pcre
 *
re
 = 
	`pcre_compile
(
pat
, 
flags
, &
err
, &
offset
, 
NULL
);

90 if (
re
 == 
NULL
) {

91 
	`error
("error compiling regular expression: %s: %s", 
err
, 
pat
 + 
offset
);

94 
pcre_extra
 *
extra
 = 
	`pcre_study
(
re
, 
PCRE_STUDY_EXTRA_NEEDED
 | 
PCRE_STUDY_JIT_COMPILE
, &
err
);

95 if (
extra
 == 
NULL
) {

96 
	`error
("error studying regular expression: %s", 
err
);

99 return (struct 
token
) {

100 .
type
 = 
TOKEN_REGEX
,

101 .
regex
 = 
re
,

102 .
extra
 = extra,

103 .
pattern
 = 
pat
,

104 .
loc
 = 
startloc


106 
	}
}

108 static struct 
token


109 
	$mkreal
(float 
real
)

111 return (struct 
token
) {

112 .
type
 = 
TOKEN_REAL
,

113 .
real
 = real,

114 .
loc
 = 
startloc


116 
	}
}

118 static struct 
token


119 
	$mkinteger
(
intmax_t
 
k
)

121 return (struct 
token
) {

122 .
type
 = 
TOKEN_INTEGER
,

123 .
integer
 = 
k
,

124 .
loc
 = 
startloc


126 
	}
}

128 static struct 
token


129 
	$mkkw
(int 
kw
)

131 return (struct 
token
) {

132 .
type
 = 
TOKEN_KEYWORD
,

133 .
keyword
 = 
kw
,

134 .
loc
 = 
startloc
,

136 
	}
}

139 
	$nextchar
(void)

141 char 
c
 = *
chars
;

143 if (
c
 == '\n') {

144 
loc
.
line
 += 1;

145 
loc
.
col
 = 0;

147 
loc
.
col
 += 1;

150 
chars
 += 1;

152 return 
c
;

153 
	}
}

155 static 
bool


156 
	$skipspace
(void)

158 
bool
 
ret
 = 
false
;

160 int 
n
 = 0;

161 while (
	`isspace
(
chars
[
n
])) {

162 if (
chars
[
n
] == '\n' && 
keep_next_newline
) {

163 
ret
 = 
true
;

164 
keep_next_newline
 = 
false
;

166 
n
 += 1;

169 if (
chars
[
n
] == '\0') {

170 
chars
 += 
n
;

172 while (
n
 --> 0) {

173 
	`nextchar
();

177 return 
ret
;

178 
	}
}

181 static struct 
token


182 
	$lexword
(void)

184 
	`vec
(char) 
module
;

185 
	`vec
(char) 
word
;

187 
	`vec_init
(
module
);

188 
	`vec_init
(
word
);

190 
bool
 
has_module
 = 
false
;

193 while (
	`isalnum
(*
chars
) || *chars == '_')

194 
	`vec_push
(
word
, 
	`nextchar
());

196 if (
chars
[0] == ':' && chars[1] == ':' && ++
has_module
) {

197 
	`nextchar
();

198 
	`nextchar
();

200 if (
module
.
count
 != 0)

201 
	`vec_push
(
module
, '/');

203 if (
word
.
count
 != 0)

204 
	`vec_push_n
(
module
, 
word
.
items
, word.
count
);

205 
word
.
count
 = 0;

207 if (!
	`isalpha
(*
chars
) && *chars != '_')

208 
	`error
("expected name after '::' in identifier");

217 if (*
chars
 == '!' || *chars == '?')

218 
	`vec_push
(
word
, 
	`nextchar
());

220 if (
has_module
 != 0)

221 
	`vec_push
(
module
, '\0');

223 
	`vec_push
(
word
, '\0');

225 char *
w
 = 
word
.
items
;

226 char *
m
 = 
module
.
items
;

228 int 
keyword
;

229 if (
keyword
 = 
	`keyword_get_number
(
w
), keyword != -1) {

230 
keep_next_newline
 |= (
keyword
 == 
KEYWORD_IMPORT
 || keyword == 
KEYWORD_EXPORT
);

231 return 
	`mkkw
(
keyword
);

233 return 
	`mkid
(
w
, 
m
);

235 
	}
}

237 static struct 
token


238 
	$lexrawstr
(void)

240 
	`vec
(char) 
str
;

241 
	`vec_init
(
str
);

243 
	`nextchar
();

245 while (*
chars
 != '\'') {

246 switch (*
chars
) {

247 case '\0': goto 
unterminated
;

249 
	`nextchar
();

250 if (*
chars
 == '\0') goto 
unterminated
;

253 
	`vec_push
(
str
, 
	`nextchar
());

257 
	`assert
(
	`nextchar
() == '\'');

259 
	`vec_push
(
str
, '\0');

261 return 
	`mkstring
(
str
.
items
);

263 
unterminated
:

265 
	`error
("unterminated string literal");

266 
	}
}

269 
	$lexexpr
(void)

271 
	`vec
(char) 
e
;

272 
	`vec_init
(
e
);

274 
	`nextchar
();

275 while (*
chars
 != '}') {

276 switch (*
chars
) {

277 case '\0': goto 
unterminated
;

279 
	`nextchar
();

280 if (*
chars
 == '\0') goto 
unterminated
;

281 if (*
chars
 == 'n') {

282 
	`nextchar
();

283 
	`vec_push
(
e
, '\n');

288 
	`vec_push
(
e
, 
	`nextchar
());

292 
	`assert
(
	`nextchar
() == '}');

294 
	`vec_push
(
e
, '\0');

296 return 
e
.
items
;

298 
unterminated
:

299 
	`error
("unterminated expression in interpolated string");

300 
	}
}

302 static struct 
token


303 
	$lexspecialstr
(void)

305 struct 
token
 
special
 = 
	`mktoken
(
TOKEN_SPECIAL_STRING
);

306 
	`vec_init
(
special
.
strings
);

307 
	`vec_init
(
special
.
expressions
);

308 
	`vec_init
(
special
.
locations
);

310 
	`vec
(char) 
str
;

311 
	`vec_init
(
str
);

314 
	`nextchar
();

316 
start
:

318 while (*
chars
 != '"') {

319 switch (*
chars
) {

320 case '\0': goto 
unterminated
;

321 case '{': goto 
expr
;

323 
	`nextchar
();

324 switch (*
chars
) {

326 goto 
unterminated
;

328 
	`nextchar
();

329 
	`vec_push
(
str
, '\n');

332 
	`nextchar
();

333 
	`vec_push
(
str
, '\r');

336 
	`nextchar
();

337 
	`vec_push
(
str
, '\t');

341 
	`vec_push
(
str
, 
	`nextchar
());

345 
	`assert
(
	`nextchar
() == '"');

347 
	`vec_push
(
str
, '\0');

348 
	`vec_push
(
special
.
strings
, 
str
.
items
);

350 return 
special
;

352 
expr
:

353 
	`vec_push
(
str
, '\0');

354 
	`vec_push
(
special
.
strings
, 
str
.
items
);

355 
	`vec_init
(
str
);

356 
	`vec_push
(
special
.
locations
, 
loc
);

357 
	`vec_push
(
special
.
expressions
, 
	`lexexpr
());

359 goto 
start
;

361 
unterminated
:

363 
	`error
("unterminated string literal");

364 
	}
}

366 static struct 
token


367 
	$lexregex
(void)

369 
	`vec
(char) 
pat
;

370 
	`vec_init
(
pat
);

372 
	`nextchar
();

374 while (*
chars
 != '/') {

375 switch (*
chars
) {

376 case '\0': goto 
unterminated
;

378 if (
chars
[1] == '\0') goto 
unterminated
;

379 if (
chars
[1] == '/') 
	`nextchar
();

382 
	`vec_push
(
pat
, 
	`nextchar
());

386 
	`assert
(
	`nextchar
() == '/');

388 int 
flags
 = 0;

390 while (
	`isalpha
(*
chars
)) {

391 switch (*
chars
) {

392 case 'i': 
flags
 |= 
PCRE_CASELESS
; break;

393 default: 
	`error
("invalid regex flag: '%c'", *
chars
);

395 
	`nextchar
();

398 
	`vec_push
(
pat
, '\0');

400 return 
	`mkregex
(
pat
.
items
, 
flags
);

402 
unterminated
:

404 
	`error
("unterminated regular expression");

405 
	}
}

407 static struct 
token


408 
	$lexnum
(void)

410 char *
end
;

411 
errno
 = 0;

412 
intmax_t
 
integer
 = 
	`strtoull
(
chars
, &
end
, 0);

414 struct 
token
 
num
;

416 if (
errno
 != 0) {

417 char const *
err
 = 
	`strerror
(
errno
);

418 
	`error
("invalid numeric literal: %c%s", 
	`tolower
(
err
[0]), err + 1);

421 if (*
end
 == '.' && end[1] != '.') {

422 
errno
 = 0;

423 float 
real
 = 
	`strtof
(
chars
, &
end
);

425 if (
errno
 != 0) {

426 char const *
err
 = 
	`strerror
(
errno
);

427 
	`error
("invalid numeric literal: %c%s", 
	`tolower
(
err
[0]), err + 1);

430 if (
	`isalnum
(*
end
))

431 
	`error
("invalid trailing character after numeric literal: %c", *
end
);

433 
num
 = 
	`mkreal
(
real
);

434 } else if (*
end
 == 'r') {

435 
integer
 = 
	`strtoull
(
end
 + 1, &end, integer);

436 
num
 = 
	`mkinteger
(
integer
);

438 if (
	`isalnum
(*
end
))

439 
	`error
("invalid trailing character after numeric literal: %c", *
end
);

440 
num
 = 
	`mkinteger
(
integer
);

443 while (
chars
 != 
end
)

444 
	`nextchar
();

446 return 
num
;

447 
	}
}

449 static struct 
token


450 
	$lexop
(void)

452 char 
op
[
MAX_OP_LEN
 + 1] = {0};

453 
size_t
 
i
 = 0;

455 while (
	`contains
(
opchars
, *
chars
)) {

456 if (
i
 == 
MAX_OP_LEN
) {

457 
	`error
("operator contains too many characters: '%s...'", 
op
);

459 
op
[
i
++] = 
	`nextchar
();

463 int 
toktype
 = 
	`operator_get_token_type
(
op
);

464 if (
toktype
 == -1) {

466 if (
op
[0] == '|') {

467 
chars
 -= (
i
 - 1);

468 
loc
.
col
 -= (
i
 - 1);

469 return 
	`mktoken
(
TOKEN_BIT_OR
);

472 struct 
token
 
t
 = 
	`mktoken
(
TOKEN_USER_OP
);

473 
t
.
identifier
 = 
	`sclone
(
op
);

474 return 
t
;

477 return 
	`mktoken
(
toktype
);

478 
	}
}

481 
	$lexcomment
(void)

484 
	`nextchar
();

485 
	`nextchar
();

487 int 
level
 = 1;

489 while (*
chars
 && 
level
 != 0) {

490 if (
chars
[0] == '/' && chars[1] == '*')

491 ++
level
;

492 if (
chars
[0] == '*' && chars[1] == '/')

493 --
level
;

494 
	`nextchar
();

497 if (
level
 != 0)

498 
	`error
("unterminated comment");

501 
	`nextchar
();

502 
	}
}

504 struct 
token


505 
	$lex_token
(enum 
lex_context
 
ctx
)

507 if (
	`setjmp
(
jb
) != 0)

508 return (struct 
token
) { .
type
 = 
TOKEN_ERROR
, .
loc
 = loc };

510 while (*
chars
 != '\0') {

511 
startloc
 = 
loc
;

512 if (
chars
[0] == '/' && chars[1] == '*') {

513 
	`lexcomment
();

514 } else if (
ctx
 == 
LEX_PREFIX
 && 
chars
[0] == '/') {

515 return 
	`lexregex
();

516 } else if (
	`isalpha
(*
chars
) || *chars == '_' || (chars[0] == ':' && chars[1] == ':')) {

517 return 
	`lexword
();

518 } else if (
	`contains
(
opchars
, *
chars
)) {

519 return 
	`lexop
();

520 } else if (
	`isdigit
(*
chars
)) {

521 return 
	`lexnum
();

522 } else if (*
chars
 == '\'') {

523 return 
	`lexrawstr
();

524 } else if (*
chars
 == '"') {

525 return 
	`lexspecialstr
();

526 } else if (
chars
[0] == '.' && chars[1] == '.') {

527 
	`nextchar
();

528 
	`nextchar
();

529 if (
chars
[0] == '.')

530 return 
	`nextchar
(), 
	`mktoken
(
TOKEN_DOT_DOT_DOT
);

532 return 
	`mktoken
(
TOKEN_DOT_DOT
);

533 } else if (
	`isspace
(*
chars
)) {

534 if (
	`skipspace
()) {

535 return 
	`mktoken
(
TOKEN_NEWLINE
);

538 return 
	`mktoken
(
	`nextchar
());

542 return (struct 
token
) { .
type
 = 
TOKEN_END
, .
loc
 = loc };

543 
	}
}

546 
	$lex_error
(void)

548 return 
errbuf
;

549 
	}
}

552 
	$lex_init
(char const *
file
)

554 
filename
 = 
file
;

555 
loc
 = (struct 
location
) { 0, 0 };

556 
keep_next_newline
 = 
false
;

557 
	`vec_init
(
states
);

558 
chars
 = 
NULL
;

559 
	}
}

562 
	$lex_start
(char const *
s
)

567 if (
s
[0] == '#' && s[1] == '!')

568 while (*
s
 != '\0' && *s++ != '\n')

571 
	`vec_push
(
states
, 
chars
);

572 
chars
 = 
s
;

573 
	}
}

576 
	$lex_end
(void)

578 
chars
 = *
	`vec_pop
(
states
);

579 
	}
}

581 static struct 
token
 *

582 
	$lex
(char const *
s
)

584 
	`lex_start
(
s
);

585 struct 
token
 *
t
 = 
	`malloc
(sizeof *t);

586 *
t
 = 
	`lex_token
(
LEX_INFIX
);

587 
	`lex_end
();

588 return 
t
;

589 
	}
}

591 
	$TEST
(
bigop
)

593 
	`claim
(
	`lex
("\n\n+++++++++++++++++")->
type
 == 
TOKEN_ERROR
);

594 
	}
}

596 
	$TEST
(
op
)

598 struct 
token
 
op
 = (
	`lex_start
("&&"), 
	`lex_token
(
LEX_INFIX
));

599 
	`claim
(
op
.
type
 == 
TOKEN_AND
);

600 
	}
}

602 
	$TEST
(
id
)

604 struct 
token
 
id
 = (
	`lex_start
("_abc123"), 
	`lex_token
(
LEX_INFIX
));

605 
	`claim
(
id
.
type
 == 
TOKEN_IDENTIFIER
);

606 
	`claim
(
	`strcmp
(
id
.
identifier
, "_abc123") == 0);

607 
	}
}

609 
	$TEST
(
str
)

611 struct 
token
 *
str
 = 
	`lex
("'test'");

612 
	`claim
(
str
->
type
 == 
TOKEN_STRING
);

613 
	`claim
(
	`strcmp
(
str
->
string
, "test") == 0);

615 
str
 = 
	`lex
("'test\\'ing'");

616 
	`claim
(
str
 != 
NULL
);

617 
	`claim
(
str
->
type
 == 
TOKEN_STRING
);

618 
	`claim
(
	`strcmp
(
str
->
string
, "test'ing") == 0);

620 
str
 = 
	`lex
("\"test'ing\"");

621 
	`claim
(
str
 != 
NULL
);

622 
	`claim
(
str
->
type
 == 
TOKEN_SPECIAL_STRING
);

623 
	`claim
(
	`strcmp
(
str
->
strings
.
items
[0], "test'ing") == 0);

624 
	}
}

626 
	$TEST
(
integer
)

628 struct 
token
 *
integer
 = 
	`lex
("010");

629 
	`claim
(
integer
 != 
NULL
);

630 
	`claim
(
integer
->
type
 == 
TOKEN_INTEGER
);

631 
	`claim
(
integer
->integer == 010);

633 
integer
 = 
	`lex
("0xFF");

634 
	`claim
(
integer
 != 
NULL
);

635 
	`claim
(
integer
->
type
 == 
TOKEN_INTEGER
);

636 
	`claim
(
integer
->integer == 0xFF);

638 
integer
 = 
	`lex
("1283");

639 
	`claim
(
integer
 != 
NULL
);

640 
	`claim
(
integer
->
type
 == 
TOKEN_INTEGER
);

641 
	`claim
(
integer
->integer == 1283);

643 
integer
 = 
	`lex
("1283ssd");

645 
	`claim
(
integer
->
type
 == 
TOKEN_ERROR
);

646 
	`claim
(
	`strstr
(
	`lex_error
(), "trailing") != 
NULL
);

647 
	}
}

649 
	$TEST
(
special
)

651 struct 
token
 *
s
 = 
	`lex
("\"4 + 5 = {4 + 5}\"");

652 
	`claim
(
s
->
type
 == 
TOKEN_SPECIAL_STRING
);

653 
	`claim
(
s
->
strings
.
count
 == 2);

654 
	`claim
(
s
->
expressions
.
count
 == 1);

655 
	}
}

657 
	$TEST
(
real
)

659 #define 
	#almostequal
(
a
, 
b
) (
	`fabs
((a) - (b)) <= 0.001)

	)

660 struct 
token
 *
real
 = 
	`lex
("10.0");

661 
	`claim
(
real
 != 
NULL
);

662 
	`claim
(
real
->
type
 == 
TOKEN_REAL
);

663 
	`claim
(
	`almostequal
(
real
->real, 10.0));

665 
real
 = 
	`lex
("0.123");

666 
	`claim
(
real
 != 
NULL
);

667 
	`claim
(
real
->
type
 == 
TOKEN_REAL
);

668 
	`claim
(
	`almostequal
(
real
->real, 0.123));

670 
real
 = 
	`lex
("0.4");

671 
	`claim
(
real
 != 
NULL
);

672 
	`claim
(
real
->
type
 == 
TOKEN_REAL
);

673 
	`claim
(
	`almostequal
(
real
->real, 0.4));

674 #undef 
almostequal


675 
	}
}

677 
	$TEST
(
keyword
)

679 struct 
token
 
kw
;

681 
	`lex_start
("return");

682 
kw
 = 
	`lex_token
(
LEX_INFIX
);

683 
	`claim
(
kw
.
type
 == 
TOKEN_KEYWORD
);

684 
	`claim
(
kw
.
keyword
 == 
KEYWORD_RETURN
);

686 
	`lex_start
("break;");

687 
kw
 = 
	`lex_token
(
LEX_INFIX
);

688 
	`claim
(
kw
.
type
 == 
TOKEN_KEYWORD
);

689 
	`claim
(
kw
.
keyword
 == 
KEYWORD_BREAK
);

691 
	`lex_start
("break_ing_news");

692 
kw
 = 
	`lex_token
(
LEX_INFIX
);

693 
	`claim
(
kw
.
type
 == 
TOKEN_IDENTIFIER
);

694 
	`claim
(
	`strcmp
(
kw
.
identifier
, "break_ing_news") == 0);

695 
	}
}

697 
	$TEST
(
invalid_op
)

699 struct 
token
 
t
;

701 
	`lex_start
("a <$> b;");

702 
t
 = 
	`lex_token
(
LEX_INFIX
);

703 
t
 = 
	`lex_token
(
LEX_INFIX
);

704 
	`claim
(
t
.
type
 == 
TOKEN_ERROR
);

705 
	`claim
(
	`strstr
(
	`lex_error
(), "invalid operator") != 
NULL
);

706 
	}
}

708 
	$TEST
(
comment
)

710 
	`claim
((
	`lex_start
("/* /* good comment */ */"), 
	`lex_token
(
LEX_INFIX
).
type
 != 
TOKEN_ERROR
));

711 
	`claim
((
	`lex_start
("/* /* /* bad comment */ */"), 
	`lex_token
(
LEX_INFIX
).
type
 == 
TOKEN_ERROR
));

712 
	`claim
(
	`strstr
(
	`lex_error
(), "unterminated comment") != 
NULL
);

713 
	}
}

	@object.c

1 #include 
	~<string.h
>

2 #include 
	~<stdio.h
>

3 #include 
	~<stdlib.h
>

4 #include 
	~<stdbool.h
>

6 #include 
	~"alloc.h
"

7 #include 
	~"util.h
"

8 #include 
	~"value.h
"

9 #include 
	~"object.h
"

10 #include 
	~"table.h
"

11 #include 
	~"gc.h
"

13 struct 
table
 *

14 
	$object_new
(void)

16 struct 
table
 *
t
 = 
	`gc_alloc_object
(sizeof *t, 
GC_OBJECT
);

17 
	`table_init
(
t
);

18 return 
t
;

19 
	}
}

22 
	$object_mark
(struct 
table
 *
o
)

24 
	`MARK
(
o
);

26 for (int 
i
 = 0; i < 
TABLE_SIZE
; ++i)

27 for (int 
v
 = 0; v < 
o
->
buckets
[
i
].
values
.
count
; ++v)

28 
	`value_mark
(&
o
->
buckets
[
i
].
values
.
items
[
v
]);

29 
	}
}

32 
	$object_free
(struct 
table
 *
o
)

34 for (int 
i
 = 0; i < 
TABLE_SIZE
; ++i)

35 
	`free
(
o
->
buckets
[
i
].
values
.
items
);

36 
	}
}

	@operators.c

1 #include 
	~<string.h
>

3 #include 
	~"alloc.h
"

4 #include 
	~"value.h
"

5 #include 
	~"operators.h
"

6 #include 
	~"class.h
"

7 #include 
	~"dict.h
"

8 #include 
	~"vm.h
"

10 static struct 
value


11 
	$str_concat
(struct 
value
 const *
s1
, struct value const *
s2
)

13 
size_t
 
n
 = 
s1
->
bytes
 + 
s2
->bytes;

14 char *
s
 = 
	`value_string_alloc
(
n
);

16 
	`memcpy
(
s
, 
s1
->
string
, s1->
bytes
);

17 
	`memcpy
(
s
 + 
s1
->
bytes
, 
s2
->
string
, s2->bytes);

19 return 
	`STRING
(
s
, 
n
);

20 
	}
}

22 struct 
value


23 
	$binary_operator_addition
(struct 
value
 const *
left
, struct value const *
right
)

26 if (
left
->
type
 == 
VALUE_OBJECT
) {

27 struct 
value
 const *
f
 = 
	`class_lookup_method
(
left
->
class
, "+");

28 if (
f
 == 
NULL
)

29 goto 
Fail
;

30 return 
	`vm_eval_function2
(
f
, 
left
, 
right
);

33 if (
left
->
type
 == 
VALUE_REAL
 && 
right
->type == 
VALUE_INTEGER
)

34 return 
	`REAL
(
left
->
real
 + 
right
->
integer
);

36 if (
left
->
type
 == 
VALUE_INTEGER
 && 
right
->type == 
VALUE_REAL
)

37 return 
	`REAL
(
left
->
integer
 + 
right
->
real
);

39 if (
left
->
type
 != 
right
->type)

40 
	`vm_panic
("the operands to + must have the same type");

42 struct 
value
 
v
;

44 switch (
left
->
type
) {

45 case 
VALUE_INTEGER
: return 
	`INTEGER
(
left
->
integer
 + 
right
->integer);

46 case 
VALUE_REAL
: return 
	`REAL
(
left
->
real
 + 
right
->real);

47 case 
VALUE_STRING
: return 
	`str_concat
(
left
, 
right
);

48 case 
VALUE_ARRAY
:

49 
v
 = 
	`ARRAY
(
	`value_array_clone
(
left
->
array
));

50 
	`value_array_extend
(
v
.
array
, 
right
->array);

51 return 
v
;

53 
Fail
:

54 
	`vm_panic
("+ applied to operands of invalid type");

57 
	}
}

59 struct 
value


60 
	$binary_operator_multiplication
(struct 
value
 const *
left
, struct value const *
right
)

63 if (
left
->
type
 == 
VALUE_OBJECT
) {

64 struct 
value
 const *
f
 = 
	`class_lookup_method
(
left
->
class
, "*");

65 if (
f
 == 
NULL
)

66 goto 
Fail
;

67 return 
	`vm_eval_function2
(
f
, 
left
, 
right
);

70 if (
left
->
type
 == 
VALUE_REAL
 && 
right
->type == 
VALUE_INTEGER
)

71 return 
	`REAL
(
left
->
real
 * 
right
->
integer
);

73 if (
left
->
type
 == 
VALUE_INTEGER
 && 
right
->type == 
VALUE_REAL
)

74 return 
	`REAL
(
left
->
integer
 * 
right
->
real
);

76 if (
left
->
type
 != 
right
->type)

77 
	`vm_panic
("the operands to * must have the same type");

79 switch (
left
->
type
) {

80 case 
VALUE_INTEGER
: return 
	`INTEGER
(
left
->
integer
 * 
right
->integer);

81 case 
VALUE_REAL
: return 
	`REAL
(
left
->
real
 * 
right
->real);

83 
Fail
:

84 
	`vm_panic
("* applied to operands of invalid type");

86 
	}
}

88 struct 
value


89 
	$binary_operator_division
(struct 
value
 const *
left
, struct value const *
right
)

91 if (
left
->
type
 == 
VALUE_OBJECT
) {

92 struct 
value
 const *
f
 = 
	`class_lookup_method
(
left
->
class
, "/");

93 if (
f
 == 
NULL
)

94 goto 
Fail
;

95 return 
	`vm_eval_function2
(
f
, 
left
, 
right
);

98 if (
left
->
type
 == 
VALUE_REAL
 && 
right
->type == 
VALUE_INTEGER
)

99 return 
	`REAL
(
left
->
real
 / 
right
->
integer
);

101 if (
left
->
type
 == 
VALUE_INTEGER
 && 
right
->type == 
VALUE_REAL
)

102 return 
	`REAL
(
left
->
integer
 / 
right
->
real
);

104 if (
left
->
type
 != 
right
->type)

105 
	`vm_panic
("the operands to / must have the same type");

107 switch (
left
->
type
) {

108 case 
VALUE_INTEGER
: return 
	`INTEGER
(
left
->
integer
 / 
right
->integer);

109 case 
VALUE_REAL
: return 
	`REAL
(
left
->
real
 / 
right
->real);

111 
Fail
:

112 
	`vm_panic
("/ applied to operands of invalid type");

114 
	}
}

116 struct 
value


117 
	$binary_operator_subtraction
(struct 
value
 const *
left
, struct value const *
right
)

119 if (
left
->
type
 == 
VALUE_OBJECT
) {

120 struct 
value
 const *
f
 = 
	`class_lookup_method
(
left
->
class
, "-");

121 if (
f
 == 
NULL
)

122 goto 
Fail
;

123 return 
	`vm_eval_function2
(
f
, 
left
, 
right
);

126 if (
left
->
type
 == 
VALUE_REAL
 && 
right
->type == 
VALUE_INTEGER
)

127 return 
	`REAL
(
left
->
real
 - 
right
->
integer
);

129 if (
left
->
type
 == 
VALUE_INTEGER
 && 
right
->type == 
VALUE_REAL
)

130 return 
	`REAL
(
left
->
integer
 - 
right
->
real
);

132 if (
left
->
type
 != 
right
->type)

133 
	`vm_panic
("the operands to - must have the same type");

135 switch (
left
->
type
) {

136 case 
VALUE_INTEGER
: return 
	`INTEGER
(
left
->
integer
 - 
right
->integer);

137 case 
VALUE_REAL
: return 
	`REAL
(
left
->
real
 - 
right
->real);

139 
Fail
:

140 
	`vm_panic
("- applied to operands of invalid type");

143 
	}
}

145 struct 
value


146 
	$binary_operator_remainder
(struct 
value
 const *
left
, struct value const *
right
)

148 if (
left
->
type
 == 
VALUE_OBJECT
) {

149 struct 
value
 const *
f
 = 
	`class_lookup_method
(
left
->
class
, "%");

150 if (
f
 == 
NULL
)

151 goto 
Fail
;

152 return 
	`vm_eval_function2
(
f
, 
left
, 
right
);

155 if (
left
->
type
 != 
right
->type)

156 
	`vm_panic
("the operands to %% must have the same type");

158 switch (
left
->
type
) {

159 case 
VALUE_INTEGER
: return 
	`INTEGER
(
left
->
integer
 % 
right
->integer);

161 
Fail
:

162 
	`vm_panic
("the operands to % must be integers");

165 
	}
}

167 struct 
value


168 
	$binary_operator_equality
(struct 
value
 const *
left
, struct value const *
right
)

171 return 
	`BOOLEAN
(
	`value_test_equality
(
left
, 
right
));

172 
	}
}

174 struct 
value


175 
	$binary_operator_non_equality
(struct 
value
 const *
left
, struct value const *
right
)

178 return 
	`BOOLEAN
(!
	`value_test_equality
(
left
, 
right
));

179 
	}
}

181 struct 
value


182 
	$binary_operator_less_than
(struct 
value
 const *
left
, struct value const *
right
)

185 if (
left
->
type
 != 
right
->type)

186 
	`vm_panic
("< applied to operands of different types");

188 switch (
left
->
type
) {

189 case 
VALUE_INTEGER
: return 
	`BOOLEAN
(
left
->
integer
 < 
right
->integer);

190 case 
VALUE_REAL
: return 
	`BOOLEAN
(
left
->
real
 < 
right
->real);

191 case 
VALUE_STRING
: return 
	`BOOLEAN
(
	`strcmp
(
left
->
string
, 
right
->string) < 0);

192 default: 
	`vm_panic
("< applied to operands of invlalid type");

194 
	}
}

196 struct 
value


197 
	$binary_operator_greater_than
(struct 
value
 const *
left
, struct value const *
right
)

200 if (
left
->
type
 != 
right
->type) {

201 
	`vm_panic
("> applied to operands of different types");

204 switch (
left
->
type
) {

205 case 
VALUE_INTEGER
: return 
	`BOOLEAN
(
left
->
integer
 > 
right
->integer);

206 case 
VALUE_REAL
: return 
	`BOOLEAN
(
left
->
real
 > 
right
->real);

207 case 
VALUE_STRING
: return 
	`BOOLEAN
(
	`strcmp
(
left
->
string
, 
right
->string) > 0);

208 default: 
	`vm_panic
("> applied to operands of invalid type");

210 
	}
}

212 struct 
value


213 
	$binary_operator_less_than_or_equal
(struct 
value
 const *
left
, struct value const *
right
)

216 if (
left
->
type
 != 
right
->type) {

217 
	`vm_panic
("<= applied to operands of different types");

220 switch (
left
->
type
) {

221 case 
VALUE_INTEGER
: return 
	`BOOLEAN
(
left
->
integer
 <= 
right
->integer);

222 case 
VALUE_REAL
: return 
	`BOOLEAN
(
left
->
real
 <= 
right
->real);

223 case 
VALUE_STRING
: return 
	`BOOLEAN
(
	`strcmp
(
left
->
string
, 
right
->string) <= 0);

224 default: 
	`vm_panic
("<= applied to operands of invalid type");

226 
	}
}

228 struct 
value


229 
	$binary_operator_greater_than_or_equal
(struct 
value
 const *
left
, struct value const *
right
)

231 if (
left
->
type
 != 
right
->type) {

232 
	`vm_panic
(">= applied to operands of different types");

235 switch (
left
->
type
) {

236 case 
VALUE_INTEGER
: return 
	`BOOLEAN
(
left
->
integer
 >= 
right
->integer);

237 case 
VALUE_REAL
: return 
	`BOOLEAN
(
left
->
real
 >= 
right
->real);

238 case 
VALUE_STRING
: return 
	`BOOLEAN
(
	`strcmp
(
left
->
string
, 
right
->string) >= 0);

239 default: 
	`vm_panic
(">= applied to operands of invalid type");

241 
	}
}

243 struct 
value


244 
	$unary_operator_not
(struct 
value
 const *
operand
)

246 return 
	`BOOLEAN
(!
	`value_truthy
(
operand
));

247 
	}
}

249 struct 
value


250 
	$unary_operator_negate
(struct 
value
 const *
operand
)

252 if (
operand
->
type
 == 
VALUE_INTEGER
) {

253 return 
	`INTEGER
(-
operand
->
integer
);

254 } else if (
operand
->
type
 == 
VALUE_REAL
) {

255 return 
	`REAL
(-
operand
->
real
);

257 
	`vm_panic
("the operand to unary - must be numeric");

259 
	}
}

	@panic.c

1 #include 
	~<stdarg.h
>

2 #include 
	~<stdio.h
>

3 #include 
	~<stdlib.h
>

4 #include 
	~<stdnoreturn.h
>

6 
noreturn
 void

7 
	$panic
(char const *
fmt
, ...)

9 
va_list
 
ap
;

11 
	`va_start
(
ap
, 
fmt
);

12 
	`vfprintf
(
stderr
, 
fmt
, 
ap
);

13 
	`fputc
('\n', 
stderr
);

14 
	`va_end
(
ap
);

16 
	`exit
(
EXIT_FAILURE
);

17 
	}
}

	@parse.c

1 #include 
	~<setjmp.h
>

2 #include 
	~<stdarg.h
>

3 #include 
	~<string.h
>

4 #include 
	~<stdbool.h
>

5 #include 
	~<assert.h
>

6 #include 
	~<errno.h
>

7 #include 
	~<math.h
>

8 #include 
	~<stdnoreturn.h
>

10 #include 
	~"vec.h
"

11 #include 
	~"token.h
"

12 #include 
	~"test.h
"

13 #include 
	~"ast.h
"

14 #include 
	~"util.h
"

15 #include 
	~"alloc.h
"

16 #include 
	~"lex.h
"

17 #include 
	~"operators.h
"

18 #include 
	~"value.h
"

19 #include 
	~"log.h
"

20 #include 
	~"vm.h
"

22 #define 
	#BINARY_OPERATOR
(
name
, 
token
, 
prec
, 
right_assoc
) \

23 static struct 
expression
 * \

24 
infix_
 ## 
	`name
(struct 
expression
 *
left
) \

26 
	`consume
(
TOKEN_
 ## 
token
); \

27 struct 
expression
 *
e
 = 
	`mkexpr
(); \

28 
e
->
type
 = 
EXPRESSION_
 ## 
token
; \

29 
e
->
left
 = left; \

30 
e
->
right
 = 
	`parse_expr
(
prec
 - (
right_assoc
 ? 1 : 0)); \

31 return 
e
; \

33 

	)

34 #define 
	#BINARY_LVALUE_OPERATOR
(
name
, 
token
, 
prec
, 
right_assoc
) \

35 static struct 
expression
 * \

36 
infix_
 ## 
	`name
(struct 
expression
 *
left
) \

38 
	`consume
(
TOKEN_
 ## 
token
); \

39 struct 
expression
 *
e
 = 
	`mkexpr
(); \

40 
e
->
type
 = 
EXPRESSION_
 ## 
token
; \

41 
e
->
target
 = 
	`assignment_lvalue
(
left
); \

42 
e
->
value
 = 
	`parse_expr
(
prec
 - (
right_assoc
 ? 1 : 0)); \

43 return 
e
; \

45 

	)

46 #define 
	#PREFIX_OPERATOR
(
name
, 
token
, 
prec
) \

47 static struct 
expression
 * \

48 
prefix_
 ## 
	`name
(void) \

50 
	`consume
(
TOKEN_
 ## 
token
); \

51 struct 
expression
 *
e
 = 
	`mkexpr
(); \

52 
e
->
type
 = 
EXPRESSION_PREFIX_
 ## 
token
; \

53 
e
->
operand
 = 
	`parse_expr
(
prec
); \

54 return 
e
; \

56 

	)

57 #define 
	#PREFIX_LVALUE_OPERATOR
(
name
, 
token
, 
prec
) \

58 static struct 
expression
 * \

59 
prefix_
 ## 
	`name
(void) \

61 
	`consume
(
TOKEN_
 ## 
token
); \

62 struct 
expression
 *
e
 = 
	`mkexpr
(); \

63 
e
->
type
 = 
EXPRESSION_PREFIX_
 ## 
token
; \

64 
e
->
operand
 = 
	`assignment_lvalue
(
	`parse_expr
(
prec
)); \

65 return 
e
; \

67 

	)

68 typedef struct 
expression
 *
	tparse_fn
();

71 
	mMAX_ERR_LEN
 = 2048

83 
	mLV_LET
,

84 
	mLV_EACH
,

85 
	mLV_ANY


88 static 
jmp_buf
 
	gjb
;

89 static char 
	gerrbuf
[
MAX_ERR_LEN
 + 1];

91 static 
	$vec
(struct 
token
) 
tokens
;

92 static int 
tokidx
 = 0;

93 enum 
lex_context
 
lex_ctx
 = 
LEX_PREFIX
;

95 static int 
depth
;

96 static int 
dot_lambda_depth
;

97 static 
bool
 
new_dot_lambda
;

98 static 
bool
 
NoEquals
 = 
false
;

100 static char const *
filename
;

102 static struct 
statement
 
BREAK_STATEMENT
 = { .
type
 = 
STATEMENT_BREAK
, .
loc
 = {42, 42} 
	}
};

103 static struct 
statement
 
	gCONTINUE_STATEMENT
 = { .
type
 = 
STATEMENT_CONTINUE
, .
	gloc
 = {42, 42} };

104 static struct 
statement
 
	gNULL_STATEMENT
 = { .
type
 = 
STATEMENT_NULL
, .
	gloc
 = {42, 42} };

106 static struct 
statement
 *

107 
parse_statement
(void);

109 static struct 
expression
 *

110 
parse_expr
(int);

112 static struct 
statement
 *

113 
parse_match_statement
(void);

115 static struct 
statement
 *

116 
parse_let_definition
(void);

118 static struct 
statement
 *

119 
parse_block
(void);

121 static struct 
expression
 *

122 
assignment_lvalue
(struct 
expression
 *
e
);

124 static struct 
expression
 *

125 
definition_lvalue
(struct 
expression
 *
e
);

127 static struct 
expression
 *

128 
infix_member_access
(struct 
expression
 *
e
);

130 
inline
 static struct 
token
 *

131 
tok
(void);

138 
	$gensym
(void)

140 static int 
sym
 = 0;

141 char 
buf
[24];

143 
	`sprintf
(
buf
, ":%d", 
sym
++);

145 return 
	`sclone
(
buf
);

146 
	}
}

148 
inline
 static struct 
expression
 *

149 
	$mkexpr
(void)

151 struct 
expression
 *
e
 = 
	`alloc
(sizeof *e);

152 
e
->
loc
 = 
	`tok
()->loc;

153 return 
e
;

154 
	}
}

156 
inline
 static struct 
statement
 *

157 
	$mkstmt
(void)

159 struct 
statement
 *
s
 = 
	`alloc
(sizeof *s);

160 
s
->
loc
 = 
	`tok
()->loc;

161 return 
s
;

162 
	}
}

164 
inline
 static struct 
statement
 *

165 
	$mkret
(struct 
expression
 *
value
)

167 struct 
statement
 *
s
 = 
	`mkstmt
();

168 
s
->
type
 = 
STATEMENT_RETURN
;

169 
	`vec_init
(
s
->
returns
);

170 
	`vec_push
(
s
->
returns
, 
value
);

171 return 
s
;

172 
	}
}

174 
inline
 static struct 
statement
 *

175 
	$mkdef
(struct 
expression
 *
lvalue
, char *
name
)

177 struct 
expression
 *
value
 = 
	`mkexpr
();

178 
value
->
type
 = 
EXPRESSION_IDENTIFIER
;

179 
value
->
identifier
 = 
name
;

180 
value
->
module
 = 
NULL
;

182 struct 
statement
 *
s
 = 
	`mkstmt
();

183 
s
->
type
 = 
STATEMENT_DEFINITION
;

184 
s
->
target
 = 
lvalue
;

185 
s
->
value
 = value;

187 return 
s
;

188 
	}
}

190 
noreturn
 static void

191 
	$error
(char const *
fmt
, ...)

193 if (
fmt
 == 
NULL
) {

194 
	`strcpy
(
errbuf
, 
	`lex_error
());

196 
va_list
 
ap
;

197 
	`va_start
(
ap
, 
fmt
);

199 int 
n
 = 0;

201 char *
err
 = 
errbuf
;

202 
n
 += 
	`sprintf
(
err
, "ParseError: %s:%d:%d: ", 
filename
, 
	`tok
()->
loc
.
line
 + 1, tok()->loc.
col
 + 1);

203 
	`vsnprintf
(
err
 + 
n
, 
MAX_ERR_LEN
 - n, 
fmt
, 
ap
);

205 
	`va_end
(
ap
);

208 
	`LOG
("Parse Error: %s", 
errbuf
);

210 
	`longjmp
(
jb
, 1);

211 
	}
}

213 
inline
 static void

214 
	$skip
(int 
n
)

216 
tokidx
 += 
n
;

217 
	}
}

219 
inline
 static void

220 
	$next
(void)

222 
	`skip
(1);

223 
	}
}

225 
inline
 static struct 
token
 *

226 
	$token
(int 
i
)

228 struct 
token
 
t
;

229 while (
tokens
.
count
 <= 
i
 + 
tokidx
) {

230 
t
 = 
	`lex_token
(
lex_ctx
);

231 if (
t
.
type
 == 
TOKEN_ERROR
) {

232 
	`error
(
NULL
);

234 
	`vec_push
(
tokens
, 
t
);

237 return &
tokens
.
items
[
tokidx
 + 
i
];

238 
	}
}

240 
inline
 static struct 
token
 *

241 
	$tok
(void)

243 return 
	`token
(0);

244 
	}
}

250 
inline
 static void

251 
	$unconsume
(int 
type
)

253 
	`vec_insert
(
tokens
, ((struct 
token
){ .
type
 = type, .
loc
 = { 42, 42 } }), 
tokidx
);

254 
	}
}

257 
	$expect
(int 
type
)

259 if (
	`tok
()->
type
 != type) {

260 
	`error
("expected %s but found %s", 
	`token_show_type
(
type
), 
	`token_show
(
	`tok
()));

262 
	}
}

266 
	$expect_keyword
(int 
type
)

268 if (
	`tok
()->
type
 != 
TOKEN_KEYWORD
 || tok()->
keyword
 != type) {

269 
	`error
("expected %s but found %s", 
	`token_show
(&(struct 
token
){ .
type
 = 
TOKEN_KEYWORD
, .
keyword
 = type }), token_show(
	`tok
()));

271 
	}
}

273 
inline
 static void

274 
	$consume
(int 
type
)

276 
	`expect
(
type
);

277 
tokidx
 += 1;

278 
	}
}

280 
inline
 static void

281 
	$consume_keyword
(int 
type
)

283 
	`expect_keyword
(
type
);

284 
tokidx
 += 1;

286 
	}
}

289 static struct 
expression
 *

290 
	$prefix_integer
(void)

292 
	`expect
(
TOKEN_INTEGER
);

294 struct 
expression
 *
e
 = 
	`mkexpr
();

295 
e
->
type
 = 
EXPRESSION_INTEGER
;

296 
e
->
integer
 = 
	`tok
()->integer;

298 
	`consume
(
TOKEN_INTEGER
);

300 return 
e
;

301 
	}
}

303 static struct 
expression
 *

304 
	$prefix_real
(void)

306 
	`expect
(
TOKEN_REAL
);

308 struct 
expression
 *
e
 = 
	`mkexpr
();

309 
e
->
type
 = 
EXPRESSION_REAL
;

310 
e
->
real
 = 
	`tok
()->real;

312 
	`consume
(
TOKEN_REAL
);

314 return 
e
;

315 
	}
}

317 static struct 
expression
 *

318 
	$prefix_string
(void)

320 
	`expect
(
TOKEN_STRING
);

322 struct 
expression
 *
e
 = 
	`mkexpr
();

323 
e
->
type
 = 
EXPRESSION_STRING
;

324 
e
->
string
 = 
	`tok
()->string;

326 
	`consume
(
TOKEN_STRING
);

328 return 
e
;

329 
	}
}

331 static struct 
expression
 *

332 
	$prefix_special_string
(void)

334 
	`expect
(
TOKEN_SPECIAL_STRING
);

336 struct 
expression
 *
e
 = 
	`mkexpr
();

337 
e
->
type
 = 
EXPRESSION_SPECIAL_STRING
;

338 
	`vec_init
(
e
->
expressions
);

340 
e
->
strings
.
items
 = 
	`tok
()->strings.items;

341 
e
->
strings
.
count
 = 
	`tok
()->strings.count;

343 char **
exprs
 = 
	`tok
()->
expressions
.
items
;

344 int 
count
 = 
	`tok
()->
expressions
.count;

346 struct 
location
 *
locs
 = 
	`tok
()->
locations
.
items
;

348 
	`consume
(
TOKEN_SPECIAL_STRING
);

350 for (int 
i
 = 0; i < 
count
; ++i) {

351 
	`lex_start
(
exprs
[
i
]);

352 
	`vec_push
(
e
->
expressions
, 
	`parse_expr
(0));

353 if (
	`tok
()->
type
 != 
TOKEN_END
) {

357 
	`tok
()->
loc
 = 
locs
[
i
];

358 
	`error
("expression in interpolated string has trailing tokens: %s", 
exprs
[
i
]);

360 
	`consume
(
TOKEN_END
);

361 
	`lex_end
();

364 return 
e
;

365 
	}
}

367 static struct 
expression
 *

368 
	$prefix_dollar
(void)

370 
	`consume
('$');

372 struct 
expression
 *
e
 = 
	`mkexpr
();

374 
	`expect
(
TOKEN_IDENTIFIER
);

376 
e
->
type
 = 
EXPRESSION_MATCH_NOT_NIL
;

377 
e
->
identifier
 = 
	`tok
()->identifier;

378 
e
->
module
 = 
	`tok
()->module;

380 if (
e
->
module
 != 
NULL
)

381 
	`error
("unpexpected module in lvalue");

383 
	`consume
(
TOKEN_IDENTIFIER
);

385 return 
e
;

386 
	}
}

388 static struct 
expression
 *

389 
	$prefix_identifier
(void)

391 
	`expect
(
TOKEN_IDENTIFIER
);

393 struct 
expression
 *
e
 = 
	`mkexpr
();

395 
e
->
type
 = 
EXPRESSION_IDENTIFIER
;

396 
e
->
identifier
 = 
	`tok
()->identifier;

397 
e
->
module
 = 
	`tok
()->module;

399 
	`consume
(
TOKEN_IDENTIFIER
);

401 return 
e
;

402 
	}
}

404 static struct 
expression
 *

405 
	$prefix_function
(void)

407 
	`consume_keyword
(
KEYWORD_FUNCTION
);

409 struct 
expression
 *
e
 = 
	`mkexpr
();

410 
e
->
type
 = 
EXPRESSION_FUNCTION
;

411 
	`vec_init
(
e
->
params
);

413 if (
	`tok
()->
type
 == 
TOKEN_IDENTIFIER
) {

414 
e
->
name
 = 
	`tok
()->
identifier
;

415 
	`next
();

417 
e
->
name
 = 
NULL
;

420 
	`consume
('(');

422 if (
	`tok
()->
type
 == ')') {

423 
	`next
();

424 goto 
body
;

426 
	`expect
(
TOKEN_IDENTIFIER
);

427 
	`vec_push
(
e
->
params
, 
	`sclone
(
	`tok
()->
identifier
));

428 
	`consume
(
TOKEN_IDENTIFIER
);

431 while (
	`tok
()->
type
 == ',') {

432 
	`next
();

433 
	`expect
(
TOKEN_IDENTIFIER
);

434 
	`vec_push
(
e
->
params
, 
	`sclone
(
	`tok
()->
identifier
));

435 
	`next
();

438 
	`consume
(')');

440 
body
:

442 
e
->
body
 = 
	`parse_statement
();

444 return 
e
;

445 
	}
}

447 static struct 
expression
 *

448 
	$prefix_star
(void)

450 
	`consume
(
TOKEN_STAR
);

452 struct 
expression
 *
e
 = 
	`mkexpr
();

453 
e
->
type
 = 
EXPRESSION_MATCH_REST
;

455 
	`expect
(
TOKEN_IDENTIFIER
);

456 
e
->
identifier
 = 
	`tok
()->identifier;

457 if (
	`tok
()->
module
 != 
NULL
)

458 
	`error
("unexpected module qualifier in lvalue");

460 
	`consume
(
TOKEN_IDENTIFIER
);

462 return 
e
;

463 
	}
}

465 static struct 
expression
 *

466 
	$prefix_match
(void)

468 
	`consume_keyword
(
KEYWORD_MATCH
);

470 struct 
expression
 *
e
 = 
	`mkexpr
();

471 
e
->
type
 = 
EXPRESSION_MATCH
;

473 
e
->
subject
 = 
	`parse_expr
(0);

475 
	`consume
('{');

477 
	`vec_init
(
e
->
patterns
);

478 
	`vec_init
(
e
->
conds
);

479 
	`vec_init
(
e
->
thens
);

481 
	`vec_push
(
e
->
patterns
, 
	`parse_expr
(0));

482 if (
	`tok
()->
type
 == 
TOKEN_BIT_OR
) {

483 
	`next
();

484 
	`vec_push
(
e
->
conds
, 
	`parse_expr
(0));

486 
	`vec_push
(
e
->
conds
, 
NULL
);

489 
	`consume
(
TOKEN_FAT_ARROW
);

490 
	`vec_push
(
e
->
thens
, 
	`parse_expr
(0));

492 while (
	`tok
()->
type
 == ',') {

493 
	`next
();

494 
	`vec_push
(
e
->
patterns
, 
	`parse_expr
(0));

495 if (
	`tok
()->
type
 == 
TOKEN_BIT_OR
) {

496 
	`next
();

497 
	`vec_push
(
e
->
conds
, 
	`parse_expr
(0));

499 
	`vec_push
(
e
->
conds
, 
NULL
);

502 
	`consume
(
TOKEN_FAT_ARROW
);

503 
	`vec_push
(
e
->
thens
, 
	`parse_expr
(0));

506 
	`consume
('}');

508 return 
e
;

509 
	}
}

511 static struct 
expression
 *

512 
	$prefix_parenthesis
(void)

519 
	`consume
('(');

524 if (
	`tok
()->
type
 == ')') {

525 
	`next
();

526 struct 
expression
 *
list
 = 
	`mkexpr
();

527 
list
->
type
 = 
EXPRESSION_LIST
;

528 
list
->
only_identifiers
 = 
true
;

529 
	`vec_init
(
list
->
es
);

530 return 
list
;

533 struct 
expression
 *
e
 = 
	`parse_expr
(0);

535 if (
	`tok
()->
type
 == ',') {

536 struct 
expression
 *
list
 = 
	`mkexpr
();

537 
list
->
only_identifiers
 = 
true
;

542 if (
e
->
type
 != 
EXPRESSION_IDENTIFIER
) {

543 
list
->
only_identifiers
 = 
false
;

546 
list
->
type
 = 
EXPRESSION_LIST
;

547 
	`vec_init
(
list
->
es
);

548 
	`vec_push
(
list
->
es
, 
e
);

550 while (
	`tok
()->
type
 == ',') {

551 
	`next
();

552 struct 
expression
 *
e
 = 
	`parse_expr
(0);

553 if (
e
->
type
 != 
EXPRESSION_IDENTIFIER
) {

554 
list
->
only_identifiers
 = 
false
;

556 
	`vec_push
(
list
->
es
, 
e
);

559 
	`consume
(')');

561 return 
list
;

563 
	`consume
(')');

564 return 
e
;

566 
	}
}

568 static struct 
expression
 *

569 
	$prefix_true
(void)

571 
	`consume_keyword
(
KEYWORD_TRUE
);

573 struct 
expression
 *
e
 = 
	`mkexpr
();

574 
e
->
type
 = 
EXPRESSION_BOOLEAN
;

575 
e
->
boolean
 = 
true
;

577 return 
e
;

578 
	}
}

580 static struct 
expression
 *

581 
	$prefix_false
(void)

583 
	`consume_keyword
(
KEYWORD_FALSE
);

585 struct 
expression
 *
e
 = 
	`mkexpr
();

586 
e
->
type
 = 
EXPRESSION_BOOLEAN
;

587 
e
->
boolean
 = 
false
;

589 return 
e
;

590 
	}
}

592 static struct 
expression
 *

593 
	$prefix_nil
(void)

595 
	`consume_keyword
(
KEYWORD_NIL
);

597 struct 
expression
 *
e
 = 
	`mkexpr
();

598 
e
->
type
 = 
EXPRESSION_NIL
;

600 return 
e
;

601 
	}
}

603 static struct 
expression
 *

604 
	$prefix_regex
(void)

606 struct 
expression
 *
e
 = 
	`mkexpr
();

607 
e
->
type
 = 
EXPRESSION_REGEX
;

608 
e
->
regex
 = 
	`tok
()->regex;

609 
e
->
extra
 = 
	`tok
()->extra;

610 
e
->
pattern
 = 
	`tok
()->pattern;

612 
	`consume
(
TOKEN_REGEX
);

614 return 
e
;

615 
	}
}

618 static struct 
expression
 *

619 
	$prefix_array
(void)

621 
	`consume
('[');

623 struct 
expression
 *
e
 = 
	`mkexpr
();

624 
e
->
type
 = 
EXPRESSION_ARRAY
;

625 
	`vec_init
(
e
->
elements
);

627 if (
	`tok
()->
type
 == ']') {

628 
	`next
();

629 return 
e
;

631 
	`vec_push
(
e
->
elements
, 
	`parse_expr
(0));

634 while (
	`tok
()->
type
 == ',') {

635 
	`next
();

636 
	`vec_push
(
e
->
elements
, 
	`parse_expr
(0));

639 
	`consume
(']');

641 return 
e
;

642 
	}
}

644 static struct 
expression
 *

645 
	$prefix_tick
(void)

647 
	`consume
('`');

649 
	`expect
(
TOKEN_IDENTIFIER
);

651 if (
	`tok
()->
module
 != 
NULL
)

652 
	`error
("unexpected module qualifier in ` pattern");

654 struct 
expression
 *
e
 = 
	`mkexpr
();

656 
e
->
type
 = 
EXPRESSION_TICK
;

657 
e
->
identifier
 = 
	`tok
()->identifier;

658 
e
->
module
 = 
NULL
;

660 
	`next
();

662 return 
e
;

663 
	}
}

665 static struct 
expression
 *

666 
	$prefix_dot
(void)

668 if (
dot_lambda_depth
 > 0 && !
new_dot_lambda
) {

669 struct 
expression
 *
e
 = 
	`mkexpr
();

670 
e
->
type
 = 
EXPRESSION_IDENTIFIER
;

671 
e
->
identifier
 = "<object>";

672 
e
->
module
 = 
NULL
;

673 return 
	`infix_member_access
(
e
);

675 
new_dot_lambda
 = 
false
;

676 ++
dot_lambda_depth
;

677 
	`unconsume
(
TOKEN_ARROW
);

678 
	`unconsume
(
TOKEN_IDENTIFIER
);

679 
	`tok
()->
identifier
 = "<object>";

680 
	`tok
()->
module
 = 
NULL
;

681 return 
	`prefix_identifier
();

683 
	}
}

685 static struct 
expression
 *

686 
	$prefix_incrange
(void)

688 struct 
expression
 *
e
 = 
	`mkexpr
();

689 
e
->
type
 = 
EXPRESSION_DOT_DOT_DOT
;

691 struct 
expression
 *
zero
 = 
	`mkexpr
();

692 
zero
->
type
 = 
EXPRESSION_INTEGER
;

693 
zero
->
integer
 = 0;

695 
	`consume
(
TOKEN_DOT_DOT_DOT
);

697 
e
->
left
 = 
zero
;

698 
e
->
right
 = 
	`parse_expr
(0);

700 return 
e
;

701 
	}
}

703 static struct 
expression
 *

704 
	$prefix_range
(void)

706 struct 
expression
 *
e
 = 
	`mkexpr
();

707 
e
->
type
 = 
EXPRESSION_DOT_DOT
;

709 struct 
expression
 *
zero
 = 
	`mkexpr
();

710 
zero
->
type
 = 
EXPRESSION_INTEGER
;

711 
zero
->
integer
 = 0;

713 
	`consume
(
TOKEN_DOT_DOT
);

715 
e
->
left
 = 
zero
;

716 
e
->
right
 = 
	`parse_expr
(0);

718 return 
e
;

719 
	}
}

721 static struct 
expression
 *

722 
	$prefix_hash
(void)

724 struct 
expression
 *
e
 = 
	`mkexpr
();

725 
e
->
type
 = 
EXPRESSION_IDENTIFIER
;

726 
e
->
identifier
 = "#";

727 
e
->
module
 = 
NULL
;

729 
	`consume
('#');

731 return 
e
;

732 
	}
}

734 static struct 
expression
 *

735 
	$prefix_implicit_lambda
(void)

737 
	`consume
(
TOKEN_BIT_OR
);

739 struct 
expression
 *
f
 = 
	`mkexpr
();

740 
f
->
type
 = 
EXPRESSION_FUNCTION
;

741 
f
->
name
 = 
NULL
;

742 
	`vec_init
(
f
->
params
);

743 
	`vec_push
(
f
->
params
, "#");

745 struct 
expression
 *
e
 = 
	`parse_expr
(0);

746 
f
->
body
 = 
	`mkret
(
e
);

748 
	`consume
(
TOKEN_BIT_OR
);

750 return 
f
;

751 
	}
}

753 static struct 
expression
 *

754 
	$prefix_object
(void)

756 
	`consume
('{');

758 struct 
expression
 *
e
 = 
	`mkexpr
();

759 
e
->
type
 = 
EXPRESSION_DICT
;

761 
	`vec_init
(
e
->
keys
);

762 
	`vec_init
(
e
->
values
);

764 if (
	`tok
()->
type
 == '}') {

765 
	`next
();

766 return 
e
;

768 
	`vec_push
(
e
->
keys
, 
	`parse_expr
(0));

769 if (
	`tok
()->
type
 == ':') {

770 
	`next
();

771 
	`vec_push
(
e
->
values
, 
	`parse_expr
(0));

773 
	`vec_push
(
e
->
values
, 
NULL
);

777 while (
	`tok
()->
type
 == ',') {

778 
	`next
();

779 
	`vec_push
(
e
->
keys
, 
	`parse_expr
(0));

780 if (
	`tok
()->
type
 == ':') {

781 
	`next
();

782 
	`vec_push
(
e
->
values
, 
	`parse_expr
(0));

784 
	`vec_push
(
e
->
values
, 
NULL
);

788 
	`consume
('}');

790 return 
e
;

791 
	}
}

793 
	$PREFIX_OPERATOR
(
at
, 
AT
, 9)

794 
	$PREFIX_OPERATOR
(
minus
, 
MINUS
, 9)

795 
	$PREFIX_OPERATOR
(
bang
, 
BANG
, 0)

797 
	$PREFIX_LVALUE_OPERATOR
(
inc
, 
INC
, 6)

798 
	$PREFIX_LVALUE_OPERATOR
(
dec
, 
DEC
, 6)

802 static struct 
expression
 *

803 
	$infix_function_call
(struct 
expression
 *
left
)

805 struct 
expression
 *
e
 = 
	`mkexpr
();

806 
e
->
type
 = 
EXPRESSION_FUNCTION_CALL
;

807 
e
->
function
 = 
left
;

808 
	`vec_init
(
e
->
args
);

810 
	`consume
('(');

812 
lex_ctx
 = 
LEX_PREFIX
;

814 if (
	`tok
()->
type
 == ')') {

815 
	`next
();

816 return 
e
;

818 
	`vec_push
(
e
->
args
, 
	`parse_expr
(0));

821 while (
	`tok
()->
type
 == ',') {

822 
	`next
();

823 
	`vec_push
(
e
->
args
, 
	`parse_expr
(0));

826 
	`consume
(')');

828 return 
e
;

829 
	}
}

831 static struct 
expression
 *

832 
	$infix_user_op
(struct 
expression
 *
left
)

834 struct 
expression
 *
e
 = 
	`mkexpr
();

836 
e
->
type
 = 
EXPRESSION_FUNCTION_CALL
;

837 
e
->
function
 = 
	`mkexpr
();

838 
e
->
function
->
type
 = 
EXPRESSION_IDENTIFIER
;

839 
e
->
function
->
identifier
 = 
	`tok
()->identifier;

840 
e
->
function
->
module
 = 
NULL
;

841 
	`consume
(
TOKEN_USER_OP
);

843 
	`vec_init
(
e
->
args
);

844 
	`vec_push
(
e
->
args
, 
left
);

845 
	`vec_push
(
e
->
args
, 
	`parse_expr
(2));

847 return 
e
;

848 
	}
}

850 static struct 
expression
 *

851 
	$infix_list
(struct 
expression
 *
left
)

854 struct 
expression
 *
e
 = 
	`mkexpr
();

855 
e
->
type
 = 
EXPRESSION_LIST
;

856 
	`vec_init
(
e
->
es
);

857 
	`vec_push
(
e
->
es
, 
left
);

859 
NoEquals
 = 
true
;

861 while (
	`tok
()->
type
 == ',') {

862 
	`next
();

863 
	`vec_push
(
e
->
es
, 
	`parse_expr
(1));

866 
NoEquals
 = 
false
;

868 return 
e
;

869 
	}
}

871 static struct 
expression
 *

872 
	$infix_subscript
(struct 
expression
 *
left
)

874 
	`consume
('[');

876 struct 
expression
 *
e
 = 
	`mkexpr
();

877 
e
->
type
 = 
EXPRESSION_SUBSCRIPT
;

878 
e
->
container
 = 
left
;

879 
e
->
subscript
 = 
	`parse_expr
(0);

881 
	`consume
(']');

883 return 
e
;

884 
	}
}

886 static struct 
expression
 *

887 
	$infix_member_access
(struct 
expression
 *
left
)

889 
	`consume
('.');

891 struct 
expression
 *
e
 = 
	`mkexpr
();

892 
e
->
object
 = 
left
;

894 
	`expect
(
TOKEN_IDENTIFIER
);

896 if (
	`token
(1)->
type
 != '(') {

897 
e
->
type
 = 
EXPRESSION_MEMBER_ACCESS
;

898 
e
->
member_name
 = 
	`sclone
(
	`tok
()->
identifier
);

899 
	`consume
(
TOKEN_IDENTIFIER
);

900 return 
e
;

903 
new_dot_lambda
 = 
true
;

904 
e
->
type
 = 
EXPRESSION_METHOD_CALL
;

905 
e
->
method_name
 = 
	`sclone
(
	`tok
()->
identifier
);

906 
	`consume
(
TOKEN_IDENTIFIER
);

907 
	`vec_init
(
e
->
method_args
);

909 
	`consume
('(');

911 
lex_ctx
 = 
LEX_PREFIX
;

913 if (
	`tok
()->
type
 == ')')

914 goto 
end
;

916 
	`vec_push
(
e
->
method_args
, 
	`parse_expr
(0));

918 while (
	`tok
()->
type
 == ',') {

919 
	`next
();

920 
	`vec_push
(
e
->
method_args
, 
	`parse_expr
(0));

923 
end
:

924 
	`consume
(')');

925 
new_dot_lambda
 = 
false
;

926 return 
e
;

927 
	}
}

929 static struct 
expression
 *

930 
	$infix_squiggly_arrow
(struct 
expression
 *
left
)

932 struct 
expression
 *
e
 = 
	`mkexpr
();

933 
e
->
type
 = 
EXPRESSION_VIEW_PATTERN
;

935 
	`consume
(
TOKEN_SQUIGGLY_ARROW
);

937 
e
->
left
 = left;

938 
e
->
right
 = 
	`parse_expr
(0);

940 return 
e
;

941 
	}
}

943 static struct 
expression
 *

944 
	$infix_arrow_function
(struct 
expression
 *
left
)

950 if (
left
->
type
 != 
EXPRESSION_LIST
)

951 
left
 = 
	`definition_lvalue
(left);

953 
	`consume
(
TOKEN_ARROW
);

955 struct 
expression
 *
e
 = 
	`mkexpr
();

956 
e
->
type
 = 
EXPRESSION_FUNCTION
;

957 
e
->
name
 = 
NULL
;

958 
	`vec_init
(
e
->
params
);

970 if (
left
->
type
 == 
EXPRESSION_IDENTIFIER
 || (left->type == 
EXPRESSION_LIST
 && left->
only_identifiers
)) {

971 if (
left
->
type
 == 
EXPRESSION_IDENTIFIER
) {

972 
	`vec_push
(
e
->
params
, 
left
->
identifier
);

974 for (int 
i
 = 0; i < 
left
->
es
.
count
; ++i) {

975 
	`vec_push
(
e
->
params
, 
left
->
es
.
items
[
i
]->
identifier
);

979 
e
->
body
 = 
	`mkret
(
	`parse_expr
(0));

981 return 
e
;

987 struct 
statement
 *
body
 = 
	`mkstmt
();

988 
body
->
type
 = 
STATEMENT_BLOCK
;

989 
	`vec_init
(
body
->
statements
);

991 if (
left
->
type
 == 
EXPRESSION_LIST
) {

992 for (int 
i
 = 0; i < 
left
->
es
.
count
; ++i) {

993 char *
name
 = 
	`gensym
();

994 
	`vec_push
(
e
->
params
, 
name
);

995 
	`vec_push
(
body
->
statements
, 
	`mkdef
(
left
->
es
.
items
[
i
], 
name
));

998 char *
name
 = 
	`gensym
();

999 
	`vec_push
(
e
->
params
, 
name
);

1000 
	`vec_push
(
body
->
statements
, 
	`mkdef
(
left
, 
name
));

1003 
	`vec_push
(
body
->
statements
, 
	`mkret
(
	`parse_expr
(0)));

1005 
e
->
body
 = body;

1007 return 
e
;

1009 
	}
}

1011 static struct 
expression
 *

1012 
	$infix_conditional
(struct 
expression
 *
left
)

1014 struct 
expression
 *
e
 = 
	`mkexpr
();

1015 
e
->
type
 = 
EXPRESSION_CONDITIONAL
;

1017 
e
->
then
 = 
left
;

1018 
	`consume_keyword
(
KEYWORD_IF
);

1019 
e
->
cond
 = 
	`parse_expr
(0);

1020 
	`consume_keyword
(
KEYWORD_ELSE
);

1021 
e
->
otherwise
 = 
	`parse_expr
(0);

1023 return 
e
;

1024 
	}
}

1026 static struct 
expression
 *

1027 
	$postfix_inc
(struct 
expression
 *
left
)

1029 struct 
expression
 *
e
 = 
	`mkexpr
();

1031 
	`consume
(
TOKEN_INC
);

1033 
e
->
type
 = 
EXPRESSION_POSTFIX_INC
;

1034 
e
->
operand
 = 
	`assignment_lvalue
(
left
);

1036 return 
e
;

1037 
	}
}

1039 static struct 
expression
 *

1040 
	$postfix_dec
(struct 
expression
 *
left
)

1042 struct 
expression
 *
e
 = 
	`mkexpr
();

1044 
	`consume
(
TOKEN_DEC
);

1046 
e
->
type
 = 
EXPRESSION_POSTFIX_DEC
;

1047 
e
->
operand
 = 
	`assignment_lvalue
(
left
);

1049 return 
e
;

1050 
	}
}

1052 
	$BINARY_OPERATOR
(
star
, 
STAR
, 8, 
false
)

1053 
	$BINARY_OPERATOR
(
div
, 
DIV
, 8, 
false
)

1054 
	$BINARY_OPERATOR
(
percent
, 
PERCENT
, 8, 
false
)

1056 
	$BINARY_OPERATOR
(
plus
, 
PLUS
, 7, 
false
)

1057 
	$BINARY_OPERATOR
(
minus
, 
MINUS
, 7, 
false
)

1059 
	$BINARY_OPERATOR
(
range
, 
DOT_DOT
, 6, 
false
)

1060 
	$BINARY_OPERATOR
(
incrange
, 
DOT_DOT_DOT
, 6, 
false
)

1062 
	$BINARY_OPERATOR
(
lt
, 
LT
, 6, 
false
)

1063 
	$BINARY_OPERATOR
(
gt
, 
GT
, 6, 
false
)

1064 
	$BINARY_OPERATOR
(
geq
, 
GEQ
, 6, 
false
)

1065 
	$BINARY_OPERATOR
(
leq
, 
LEQ
, 6, 
false
)

1066 
	$BINARY_OPERATOR
(
cmp
, 
CMP
, 6, 
false
)

1068 
	$BINARY_OPERATOR
(
not_eq
, 
NOT_EQ
, 5, 
false
)

1069 
	$BINARY_OPERATOR
(
dbl_eq
, 
DBL_EQ
, 5, 
false
)

1071 
	$BINARY_OPERATOR
(
and
, 
AND
, 4, 
false
)

1073 
	$BINARY_OPERATOR
(
or
, 
OR
, 3, 
false
)

1075 
	$BINARY_LVALUE_OPERATOR
(
eq
, 
EQ
, 1, 
true
)

1076 
	$BINARY_LVALUE_OPERATOR
(
plus_eq
, 
PLUS_EQ
, 1, 
true
)

1077 
	$BINARY_LVALUE_OPERATOR
(
star_eq
, 
STAR_EQ
, 1, 
true
)

1078 
	$BINARY_LVALUE_OPERATOR
(
div_eq
, 
DIV_EQ
, 1, 
true
)

1079 
	$BINARY_LVALUE_OPERATOR
(
minus_eq
, 
MINUS_EQ
, 1, 
true
)

1082 static 
parse_fn
 *

1083 
	$get_prefix_parser
(void)

1085 
lex_ctx
 = 
LEX_PREFIX
;

1087 switch (
	`tok
()->
type
) {

1088 case 
TOKEN_INTEGER
: return 
prefix_integer
;

1089 case 
TOKEN_REAL
: return 
prefix_real
;

1090 case 
TOKEN_STRING
: return 
prefix_string
;

1091 case 
TOKEN_SPECIAL_STRING
: return 
prefix_special_string
;

1092 case 
TOKEN_REGEX
: return 
prefix_regex
;

1094 case 
TOKEN_IDENTIFIER
: return 
prefix_identifier
;

1095 case 
TOKEN_KEYWORD
: goto 
keyword
;

1097 case 
TOKEN_BIT_OR
: return 
prefix_implicit_lambda
;

1098 case '#': return 
prefix_hash
;

1100 case '(': return 
prefix_parenthesis
;

1101 case '[': return 
prefix_array
;

1102 case '{': return 
prefix_object
;

1104 case '$': return 
prefix_dollar
;

1105 case '.': return 
prefix_dot
;

1106 case '`': return 
prefix_tick
;

1108 case 
TOKEN_DOT_DOT
: return 
prefix_range
;

1109 case 
TOKEN_DOT_DOT_DOT
: return 
prefix_incrange
;

1111 case 
TOKEN_BANG
: return 
prefix_bang
;

1112 case 
TOKEN_AT
: return 
prefix_at
;

1113 case 
TOKEN_MINUS
: return 
prefix_minus
;

1114 case 
TOKEN_INC
: return 
prefix_inc
;

1115 case 
TOKEN_DEC
: return 
prefix_dec
;

1117 case 
TOKEN_STAR
: return 
prefix_star
;

1119 default: return 
NULL
;

1122 
keyword
:

1124 switch (
	`tok
()->
keyword
) {

1125 case 
KEYWORD_MATCH
: return 
prefix_match
;

1126 case 
KEYWORD_FUNCTION
: return 
prefix_function
;

1127 case 
KEYWORD_TRUE
: return 
prefix_true
;

1128 case 
KEYWORD_FALSE
: return 
prefix_false
;

1129 case 
KEYWORD_NIL
: return 
prefix_nil
;

1130 default: return 
NULL
;

1132 
	}
}

1134 static 
parse_fn
 *

1135 
	$get_infix_parser
(void)

1137 
lex_ctx
 = 
LEX_INFIX
;

1139 switch (
	`tok
()->
type
) {

1140 case 
TOKEN_KEYWORD
: goto 
keyword
;

1141 case '(': return 
infix_function_call
;

1142 case '.': return 
infix_member_access
;

1143 case '[': return 
infix_subscript
;

1144 case ',': return 
infix_list
;

1145 case 
TOKEN_INC
: return 
postfix_inc
;

1146 case 
TOKEN_DEC
: return 
postfix_dec
;

1147 case 
TOKEN_ARROW
: return 
infix_arrow_function
;

1148 case 
TOKEN_SQUIGGLY_ARROW
: return 
infix_squiggly_arrow
;

1149 case 
TOKEN_DOT_DOT
: return 
infix_range
;

1150 case 
TOKEN_DOT_DOT_DOT
: return 
infix_incrange
;

1151 case 
TOKEN_PLUS_EQ
: return 
infix_plus_eq
;

1152 case 
TOKEN_STAR_EQ
: return 
infix_star_eq
;

1153 case 
TOKEN_DIV_EQ
: return 
infix_div_eq
;

1154 case 
TOKEN_MINUS_EQ
: return 
infix_minus_eq
;

1155 case 
TOKEN_EQ
: return 
infix_eq
;

1156 case 
TOKEN_STAR
: return 
infix_star
;

1157 case 
TOKEN_DIV
: return 
infix_div
;

1158 case 
TOKEN_PERCENT
: return 
infix_percent
;

1159 case 
TOKEN_PLUS
: return 
infix_plus
;

1160 case 
TOKEN_MINUS
: return 
infix_minus
;

1161 case 
TOKEN_LT
: return 
infix_lt
;

1162 case 
TOKEN_GT
: return 
infix_gt
;

1163 case 
TOKEN_GEQ
: return 
infix_geq
;

1164 case 
TOKEN_LEQ
: return 
infix_leq
;

1165 case 
TOKEN_CMP
: return 
infix_cmp
;

1166 case 
TOKEN_NOT_EQ
: return 
infix_not_eq
;

1167 case 
TOKEN_DBL_EQ
: return 
infix_dbl_eq
;

1168 case 
TOKEN_OR
: return 
infix_or
;

1169 case 
TOKEN_AND
: return 
infix_and
;

1170 case 
TOKEN_USER_OP
: return 
infix_user_op
;

1171 default: return 
NULL
;

1174 
keyword
:

1176 switch (
	`tok
()->
keyword
) {

1177 case 
KEYWORD_IF
: return 
infix_conditional
;

1178 default: return 
NULL
;

1180 
	}
}

1183 
	$get_infix_prec
(void)

1185 
lex_ctx
 = 
LEX_INFIX
;

1187 if (
	`tok
()->
type
 == 
TOKEN_USER_OP
) {

1191 switch (
	`tok
()->
type
) {

1197 case 
TOKEN_INC
: return 10;

1198 case 
TOKEN_DEC
: return 10;

1200 case 
TOKEN_PERCENT
: return 9;

1201 case 
TOKEN_DIV
: return 9;

1202 case 
TOKEN_STAR
: return 9;

1204 case 
TOKEN_MINUS
: return 8;

1205 case 
TOKEN_PLUS
: return 8;

1207 case 
TOKEN_DOT_DOT
: return 7;

1208 case 
TOKEN_DOT_DOT_DOT
: return 7;

1210 case 
TOKEN_CMP
: return 7;

1211 case 
TOKEN_GEQ
: return 7;

1212 case 
TOKEN_LEQ
: return 7;

1213 case 
TOKEN_GT
: return 7;

1214 case 
TOKEN_LT
: return 7;

1216 case 
TOKEN_NOT_EQ
: return 6;

1217 case 
TOKEN_DBL_EQ
: return 6;

1219 case 
TOKEN_AND
: return 5;

1221 case 
TOKEN_OR
: return 4;

1223 case 
TOKEN_EQ
: return 
NoEquals
 ? -3 : 2;

1224 case 
TOKEN_PLUS_EQ
: return 2;

1225 case 
TOKEN_STAR_EQ
: return 2;

1226 case 
TOKEN_DIV_EQ
: return 2;

1227 case 
TOKEN_MINUS_EQ
: return 2;

1228 case 
TOKEN_ARROW
: return 2;

1231 case 
TOKEN_SQUIGGLY_ARROW
: return 2;

1235 case 
TOKEN_KEYWORD
: goto 
keyword
;

1240 
keyword
:

1242 switch (
	`tok
()->
keyword
) {

1243 case 
KEYWORD_IF
: return 3;

1246 
	}
}

1248 static struct 
expression
 *

1249 
	$definition_lvalue
(struct 
expression
 *
e
)

1251 switch (
e
->
type
) {

1252 case 
EXPRESSION_IDENTIFIER
:

1253 case 
EXPRESSION_TAG_APPLICATION
:

1254 return 
e
;

1255 case 
EXPRESSION_ARRAY
:

1256 if (
e
->
elements
.
count
 == 0)

1258 for (
size_t
 
i
 = 0; i < 
e
->
elements
.
count
; ++i)

1259 
e
->
elements
.
items
[
i
] = 
	`assignment_lvalue
(e->elements.items[i]);

1260 return 
e
;

1263 
	`error
("expression is not a valid definition lvalue");

1264 
	}
}

1266 static struct 
expression
 *

1267 
	$assignment_lvalue
(struct 
expression
 *
e
)

1269 switch (
e
->
type
) {

1270 case 
EXPRESSION_IDENTIFIER
:

1271 case 
EXPRESSION_MATCH_NOT_NIL
:

1272 case 
EXPRESSION_SUBSCRIPT
:

1273 case 
EXPRESSION_TAG_APPLICATION
:

1274 case 
EXPRESSION_MEMBER_ACCESS
:

1275 case 
EXPRESSION_FUNCTION_CALL
:

1276 case 
EXPRESSION_LIST
:

1277 return 
e
;

1278 case 
EXPRESSION_ARRAY
:

1279 for (
size_t
 
i
 = 0; i < 
e
->
elements
.
count
; ++i)

1280 
e
->
elements
.
items
[
i
] = 
	`assignment_lvalue
(e->elements.items[i]);

1281 return 
e
;

1283 
	`error
("expression is not a valid assignment lvalue");

1285 
	}
}

1290 static struct 
expression
 *

1291 
	$parse_definition_lvalue
(int 
context
)

1293 struct 
expression
 *
e
, *
elem
;

1294 int 
save
 = 
tokidx
;

1296 switch (
	`tok
()->
type
) {

1297 case 
TOKEN_IDENTIFIER
:

1298 
e
 = 
	`mkexpr
();

1300 
e
->
type
 = 
EXPRESSION_IDENTIFIER
;

1301 
e
->
identifier
 = 
	`tok
()->identifier;

1302 
e
->
module
 = 
	`tok
()->module;

1304 
	`next
();

1306 if (
	`tok
()->
type
 == '(') {

1307 struct 
expression
 *
f
 = 
	`mkexpr
(); f->
type
 = 
EXPRESSION_FUNCTION_CALL
; f->
function
 = 
e
; e = f;

1308 
lex_ctx
 = 
LEX_INFIX
;

1309 
	`next
();

1310 
	`vec_init
(
f
->
args
);

1311 
	`vec_push
(
f
->
args
, 
	`parse_definition_lvalue
(
LV_ANY
));

1312 while (
	`tok
()->
type
 == ',') {

1313 
	`next
();

1314 
	`vec_push
(
f
->
args
, 
	`parse_definition_lvalue
(
LV_ANY
));

1316 if (
f
->
args
.
items
[0] == 
NULL
) goto 
error
;

1317 
	`consume
(')');

1318 } else if (
e
->
module
 != 
NULL
) {

1319 
	`error
("unexpected module in lvalue");

1323 return 
	`prefix_tick
();

1325 
	`next
();

1326 
e
 = 
	`mkexpr
();

1327 
e
->
type
 = 
EXPRESSION_MATCH_NOT_NIL
;

1328 
e
->
identifier
 = 
	`tok
()->identifier;

1329 
e
->
module
 = 
	`tok
()->module;

1330 if (
e
->
module
 != 
NULL
)

1331 
	`error
("unexpected module in lvalue");

1332 
	`consume
(
TOKEN_IDENTIFIER
);

1335 
	`next
();

1336 
e
 = 
	`mkexpr
();

1337 
e
->
type
 = 
EXPRESSION_ARRAY
;

1338 
	`vec_init
(
e
->
elements
);

1339 if (
	`tok
()->
type
 == ']') {

1340 
	`next
();

1343 if (
elem
 = 
	`parse_definition_lvalue
(
LV_ANY
), elem == 
NULL
) {

1344 
	`vec_empty
(
e
->
elements
);

1345 goto 
error
;

1347 
	`vec_push
(
e
->
elements
, 
elem
);

1350 while (
	`tok
()->
type
 == ',') {

1351 
	`next
();

1352 if (
elem
 = 
	`parse_definition_lvalue
(
LV_ANY
), elem == 
NULL
) {

1353 
	`vec_empty
(
e
->
elements
);

1354 goto 
error
;

1356 
	`vec_push
(
e
->
elements
, 
elem
);

1360 if (
	`tok
()->
type
 != ']') {

1361 
	`vec_empty
(
e
->
elements
);

1362 goto 
error
;

1365 
	`consume
(']');

1368 
	`next
();

1369 
e
 = 
	`parse_definition_lvalue
(
LV_ANY
);

1370 if (
e
 == 
NULL
 || 
	`tok
()->
type
 != ')') {

1371 goto 
error
;

1373 
	`consume
(')');

1376 return 
NULL
;

1379 switch (
context
) {

1380 case 
LV_LET
:

1381 if (
	`tok
()->
type
 != 
TOKEN_EQ
)

1382 goto 
error
;

1384 case 
LV_EACH
:

1385 if (
	`tok
()->
type
 == 
TOKEN_KEYWORD
 && tok()->
keyword
 == 
KEYWORD_IN
)

1387 if (
	`tok
()->
type
 != ',')

1388 goto 
error
;

1389 if (
	`token
(1)->
type
 != 
TOKEN_IDENTIFIER
)

1390 goto 
error
;

1391 if (
	`token
(2)->
type
 != 
TOKEN_KEYWORD
)

1392 goto 
error
;

1393 if (
	`token
(2)->
keyword
 != 
KEYWORD_IN
)

1394 goto 
error
;

1400 return 
e
;

1402 
error
:

1403 
	`free
(
e
);

1404 
tokidx
 = 
save
;

1405 return 
NULL
;

1406 
	}
}

1408 static struct 
statement
 *

1409 
	$parse_for_loop
(void)

1411 
	`consume_keyword
(
KEYWORD_FOR
);

1413 struct 
statement
 *
s
 = 
	`mkstmt
();

1414 
s
->
type
 = 
STATEMENT_FOR_LOOP
;

1420 if (
	`tok
()->
type
 != '(') {

1421 
s
->
type
 = 
STATEMENT_EACH_LOOP
;

1423 
s
->
each
.
target
 = 
	`parse_definition_lvalue
(
LV_EACH
);

1424 if (
s
->
each
.
target
 == 
NULL
)

1425 
	`error
("expected lvalue in for-each loop");

1427 if (
	`tok
()->
type
 == ',' && 
	`token
(1)->type == 
TOKEN_IDENTIFIER
) {

1428 
s
->
each
.
counter
 = 
	`mkexpr
();

1429 
s
->
each
.
counter
->
type
 = 
EXPRESSION_IDENTIFIER
;

1430 
s
->
each
.
counter
->
identifier
 = 
	`token
(1)->identifier;

1431 
s
->
each
.
counter
->
module
 = 
NULL
;

1432 
	`skip
(2);

1434 
s
->
each
.
counter
 = 
NULL
;

1437 
	`consume_keyword
(
KEYWORD_IN
);

1439 
s
->
each
.
array
 = 
	`parse_expr
(0);

1440 
s
->
each
.
body
 = 
	`parse_statement
();

1442 return 
s
;

1445 
	`consume
('(');

1447 
s
->
for_loop
.
init
 = 
	`parse_statement
();

1449 if (
	`tok
()->
type
 == ';')

1450 
s
->
for_loop
.
cond
 = 
NULL
;

1452 
s
->
for_loop
.
cond
 = 
	`parse_expr
(0);

1454 
	`consume
(';');

1456 if (
	`tok
()->
type
 == ')')

1457 
s
->
for_loop
.
next
 = 
NULL
;

1459 
s
->
for_loop
.
next
 = 
	`parse_expr
(0);

1461 
	`consume
(')');

1463 
s
->
for_loop
.
body
 = 
	`parse_statement
();

1465 return 
s
;

1466 
	}
}

1468 static struct 
statement
 *

1469 
	$parse_while_loop
(void)

1471 
	`consume_keyword
(
KEYWORD_WHILE
);

1476 if (
	`tok
()->
type
 == 
TOKEN_KEYWORD
 && tok()->
keyword
 == 
KEYWORD_MATCH
) {

1477 struct 
statement
 *
m
 = 
	`parse_match_statement
();

1478 
m
->
type
 = 
STATEMENT_WHILE_MATCH
;

1479 return 
m
;

1485 if (
	`tok
()->
type
 == 
TOKEN_KEYWORD
 && tok()->
keyword
 == 
KEYWORD_LET
) {

1486 
	`next
();

1488 struct 
statement
 *
s
 = 
	`mkstmt
();

1490 
s
->
type
 = 
STATEMENT_WHILE_LET
;

1491 
s
->
while_let
.
pattern
 = 
	`parse_definition_lvalue
(
LV_LET
);

1493 
	`consume
(
TOKEN_EQ
);

1495 
s
->
while_let
.
e
 = 
	`parse_expr
(0);

1496 
s
->
while_let
.
block
 = 
	`parse_block
();

1498 return 
s
;

1505 struct 
statement
 *
s
 = 
	`mkstmt
();

1506 
s
->
type
 = 
STATEMENT_WHILE_LOOP
;

1508 
	`consume
('(');

1509 
s
->
while_loop
.
cond
 = 
	`parse_expr
(0);

1510 
	`consume
(')');

1512 
s
->
while_loop
.
body
 = 
	`parse_statement
();

1514 return 
s
;

1515 
	}
}

1517 static struct 
statement
 *

1518 
	$parse_if_statement
(void)

1520 
	`consume_keyword
(
KEYWORD_IF
);

1522 struct 
statement
 *
s
 = 
	`mkstmt
();

1527 if (
	`tok
()->
type
 == 
TOKEN_KEYWORD
 && tok()->
keyword
 == 
KEYWORD_LET
) {

1528 
	`next
();

1529 
s
->
type
 = 
STATEMENT_IF_LET
;

1530 
s
->
if_let
.
pattern
 = 
	`parse_definition_lvalue
(
LV_LET
);

1531 
	`consume
(
TOKEN_EQ
);

1532 
s
->
if_let
.
e
 = 
	`parse_expr
(0);

1533 
s
->
if_let
.
then
 = 
	`parse_block
();

1534 if (
	`tok
()->
type
 == 
TOKEN_KEYWORD
 && tok()->
keyword
 == 
KEYWORD_ELSE
) {

1535 
	`next
();

1536 
s
->
if_let
.
otherwise
 = 
	`parse_block
();

1538 
s
->
if_let
.
otherwise
 = 
NULL
;

1540 return 
s
;

1543 
s
->
type
 = 
STATEMENT_CONDITIONAL
;

1545 
	`consume
('(');

1546 
s
->
conditional
.
cond
 = 
	`parse_expr
(0);

1547 
	`consume
(')');

1549 
s
->
conditional
.
then_branch
 = 
	`parse_statement
();

1551 if (
	`tok
()->
type
 != 
TOKEN_KEYWORD
 || tok()->
keyword
 != 
KEYWORD_ELSE
) {

1552 
s
->
conditional
.
else_branch
 = 
NULL
;

1553 return 
s
;

1556 
	`consume_keyword
(
KEYWORD_ELSE
);

1558 
s
->
conditional
.
else_branch
 = 
	`parse_statement
();

1560 return 
s
;

1561 
	}
}

1563 static struct 
statement
 *

1564 
	$parse_match_statement
(void)

1566 
	`consume_keyword
(
KEYWORD_MATCH
);

1568 struct 
statement
 *
s
 = 
	`mkstmt
();

1569 
s
->
type
 = 
STATEMENT_MATCH
;

1571 
s
->
match
.
e
 = 
	`parse_expr
(0);

1573 
	`consume
('{');

1575 
	`vec_init
(
s
->
match
.
patterns
);

1576 
	`vec_init
(
s
->
match
.
conds
);

1577 
	`vec_init
(
s
->
match
.
statements
);

1579 
	`vec_push
(
s
->
match
.
patterns
, 
	`parse_expr
(0));

1580 if (
	`tok
()->
type
 == 
TOKEN_BIT_OR
) {

1581 
	`next
();

1582 
	`vec_push
(
s
->
match
.
conds
, 
	`parse_expr
(0));

1584 
	`vec_push
(
s
->
match
.
conds
, 
NULL
);

1587 
	`consume
(
TOKEN_FAT_ARROW
);

1588 
	`vec_push
(
s
->
match
.
statements
, 
	`parse_statement
());

1590 while (
	`tok
()->
type
 == ',') {

1591 
	`next
();

1592 
	`vec_push
(
s
->
match
.
patterns
, 
	`parse_expr
(0));

1593 if (
	`tok
()->
type
 == 
TOKEN_BIT_OR
) {

1594 
	`next
();

1595 
	`vec_push
(
s
->
match
.
conds
, 
	`parse_expr
(0));

1597 
	`vec_push
(
s
->
match
.
conds
, 
NULL
);

1599 
	`consume
(
TOKEN_FAT_ARROW
);

1600 
	`vec_push
(
s
->
match
.
statements
, 
	`parse_statement
());

1603 
	`consume
('}');

1605 return 
s
;

1606 
	}
}

1608 static struct 
statement
 *

1609 
	$parse_function_definition
(void)

1611 struct 
expression
 *
f
 = 
	`prefix_function
();

1612 if (
f
->
name
 == 
NULL
)

1613 
	`error
("unnamed function definitions cannot be used as statements");

1615 struct 
expression
 *
target
 = 
	`mkexpr
();

1616 
target
->
type
 = 
EXPRESSION_IDENTIFIER
;

1617 
target
->
identifier
 = 
f
->
name
;

1619 struct 
statement
 *
s
 = 
	`mkstmt
();

1620 
s
->
type
 = 
STATEMENT_FUNCTION_DEFINITION
;

1621 
s
->
target
 = target;

1622 
s
->
value
 = 
f
;

1624 return 
s
;

1625 
	}
}

1627 static struct 
statement
 *

1628 
	$parse_operator_definition
(void)

1630 if (
	`token
(1)->
type
 != 
TOKEN_USER_OP
) {

1631 
	`consume_keyword
(
KEYWORD_OPERATOR
);

1632 
	`consume
(
TOKEN_USER_OP
);

1635 
	`tok
()->
keyword
 = 
KEYWORD_FUNCTION
;

1636 
	`token
(1)->
type
 = 
TOKEN_IDENTIFIER
;

1638 return 
	`parse_function_definition
();

1639 
	}
}

1641 static struct 
statement
 *

1642 
	$parse_return_statement
(void)

1644 
	`consume_keyword
(
KEYWORD_RETURN
);

1646 struct 
statement
 *
s
 = 
	`mkstmt
();

1647 
s
->
type
 = 
STATEMENT_RETURN
;

1648 
	`vec_init
(
s
->
returns
);

1650 while (
	`tok
()->
type
 != ';') {

1651 
Expr
:

1652 
	`vec_push
(
s
->
returns
, 
	`parse_expr
(0));

1653 if (
	`tok
()->
type
 == ',') {

1654 
	`next
();

1655 goto 
Expr
;

1659 
	`consume
(';');

1661 return 
s
;

1662 
	}
}

1664 static struct 
statement
 *

1665 
	$parse_let_definition
(void)

1668 struct 
statement
 *
s
 = 
	`mkstmt
();

1669 
s
->
type
 = 
STATEMENT_DEFINITION
;

1671 
	`consume_keyword
(
KEYWORD_LET
);

1673 struct 
expression
 *
target
 = 
	`parse_definition_lvalue
(
LV_LET
);

1674 if (
target
 == 
NULL
)

1675 
	`error
("failed to parse lvalue in 'let' definition");

1677 
	`consume
(
TOKEN_EQ
);

1679 struct 
expression
 *
value
 = 
	`parse_expr
(0);

1681 
	`consume
(';');

1683 
s
->
target
 = target;

1684 
s
->
value
 = value;

1686 return 
s
;

1687 
	}
}

1689 static struct 
statement
 *

1690 
	$parse_break_statement
(void)

1692 
	`consume_keyword
(
KEYWORD_BREAK
);

1693 
	`consume
(';');

1694 return &
BREAK_STATEMENT
;

1695 
	}
}

1697 static struct 
statement
 *

1698 
	$parse_continue_statement
(void)

1700 
	`consume_keyword
(
KEYWORD_CONTINUE
);

1701 
	`consume
(';');

1702 return &
CONTINUE_STATEMENT
;

1703 
	}
}

1705 static struct 
statement
 *

1706 
	$parse_null_statement
()

1708 
	`consume
(';');

1709 return &
NULL_STATEMENT
;

1710 
	}
}

1712 static struct 
expression
 *

1713 
	$parse_expr
(int 
prec
)

1715 struct 
expression
 *
e
;

1717 if (++
depth
 > 256)

1718 
	`error
("exceeded maximum recursion depth of 256");

1721 
parse_fn
 *
f
 = 
	`get_prefix_parser
();

1722 if (
f
 == 
NULL
)

1723 
	`error
("expected expression but found %s", 
	`token_show
(
	`tok
()));

1725 int 
old_dot_lambda_depth
 = 
dot_lambda_depth
;

1727 
e
 = 
	`f
();

1729 while (
prec
 < 
	`get_infix_prec
()) {

1730 
f
 = 
	`get_infix_parser
();

1731 if (
f
 == 
NULL
)

1732 
	`error
("unexpected token after expression: %s", 
	`token_show
(
	`tok
()));

1733 
e
 = 
	`f
(e);

1736 if (
dot_lambda_depth
 > 
old_dot_lambda_depth
)

1737 --
dot_lambda_depth
;

1739 --
depth
;

1741 return 
e
;

1742 
	}
}

1744 static struct 
statement
 *

1745 
	$parse_block
(void)

1747 struct 
statement
 *
s
 = 
	`mkstmt
();

1749 
	`consume
('{');

1751 
s
->
type
 = 
STATEMENT_BLOCK
;

1752 
	`vec_init
(
s
->
statements
);

1754 while (
	`tok
()->
type
 != '}') {

1755 
	`vec_push
(
s
->
statements
, 
	`parse_statement
());

1758 
	`consume
('}');

1760 return 
s
;

1761 
	}
}

1763 static struct 
statement
 *

1764 
	$parse_class_definition
(void)

1766 
bool
 
tag
 = 
	`tok
()->
keyword
 == 
KEYWORD_TAG
;

1768 
	`consume_keyword
(
tag
 ? 
KEYWORD_TAG
 : 
KEYWORD_CLASS
);

1770 
	`expect
(
TOKEN_IDENTIFIER
);

1772 struct 
statement
 *
s
 = 
	`mkstmt
();

1773 
s
->
type
 = 
tag
 ? 
STATEMENT_TAG_DEFINITION
 : 
STATEMENT_CLASS_DEFINITION
;

1774 
s
->
tag
.
name
 = 
	`tok
()->
identifier
;

1775 
	`vec_init
(
s
->
tag
.
methods
);

1777 
	`next
();

1779 if (
	`tok
()->
type
 == ':') {

1780 
	`next
();

1781 
	`expect
(
TOKEN_IDENTIFIER
);

1782 
s
->
tag
.
super
 = 
	`mkexpr
();

1783 
s
->
tag
.
super
->
type
 = 
EXPRESSION_IDENTIFIER
;

1784 
s
->
tag
.
super
->
identifier
 = 
	`tok
()->identifier;

1785 
s
->
tag
.
super
->
module
 = 
	`tok
()->module;

1786 
	`next
();

1788 
s
->
tag
.
super
 = 
NULL
;

1792 if (
tag
 && 
	`tok
()->
type
 == ',' && 
	`token
(1)->type == 
TOKEN_IDENTIFIER
) {

1793 
	`next
();

1794 
	`unconsume
(
TOKEN_KEYWORD
);

1795 
	`tok
()->
keyword
 = 
KEYWORD_TAG
;

1796 
	`unconsume
(';');

1799 if (
tag
 && 
	`tok
()->
type
 == ';') {

1800 
	`next
();

1802 
	`consume
('{');

1803 while (
	`tok
()->
type
 != '}') {

1807 switch (
	`tok
()->
type
) {

1808 case 
TOKEN_DBL_EQ
: 
	`tok
()->
type
 = 
TOKEN_IDENTIFIER
; tok()->
identifier
 = "=="; break;

1809 case 
TOKEN_CMP
: 
	`tok
()->
type
 = 
TOKEN_IDENTIFIER
; tok()->
identifier
 = "<=>"; break;

1810 case 
TOKEN_PLUS
: 
	`tok
()->
type
 = 
TOKEN_IDENTIFIER
; tok()->
identifier
 = "+"; break;

1811 case 
TOKEN_DIV
: 
	`tok
()->
type
 = 
TOKEN_IDENTIFIER
; tok()->
identifier
 = "/"; break;

1812 case 
TOKEN_MINUS
: 
	`tok
()->
type
 = 
TOKEN_IDENTIFIER
; tok()->
identifier
 = "-"; break;

1813 case 
TOKEN_STAR
: 
	`tok
()->
type
 = 
TOKEN_IDENTIFIER
; tok()->
identifier
 = "*"; break;

1814 case 
TOKEN_PERCENT
: 
	`tok
()->
type
 = 
TOKEN_IDENTIFIER
; tok()->
identifier
 = "%"; break;

1821 
	`unconsume
(
TOKEN_KEYWORD
);

1822 
	`tok
()->
keyword
 = 
KEYWORD_FUNCTION
;

1824 
	`vec_push
(
s
->
tag
.
methods
, 
	`prefix_function
());

1826 
	`consume
('}');

1829 return 
s
;

1830 
	}
}

1832 static struct 
statement
 *

1833 
	$parse_throw
(void)

1835 
	`consume_keyword
(
KEYWORD_THROW
);

1837 struct 
statement
 *
s
 = 
	`mkstmt
();

1838 
s
->
type
 = 
STATEMENT_THROW
;

1839 
s
->
throw
 = 
	`parse_expr
(0);

1841 
	`consume
(';');

1843 return 
s
;

1844 
	}
}

1846 static struct 
statement
 *

1847 
	$parse_try
(void)

1849 
	`consume_keyword
(
KEYWORD_TRY
);

1851 struct 
statement
 *
s
 = 
	`mkstmt
();

1852 
s
->
type
 = 
STATEMENT_TRY
;

1854 
s
->
try
.s = 
	`parse_statement
();

1856 
	`vec_init
(
s
->
try
.
patterns
);

1857 
	`vec_init
(
s
->
try
.
handlers
);

1859 while (
	`tok
()->
type
 == 
TOKEN_KEYWORD
 && tok()->
keyword
 == 
KEYWORD_CATCH
) {

1860 
	`next
();

1861 
	`vec_push
(
s
->
try
.
patterns
, 
	`parse_expr
(0));

1862 
	`vec_push
(
s
->
try
.
handlers
, 
	`parse_statement
());

1865 if (
	`tok
()->
type
 == 
TOKEN_KEYWORD
 && tok()->
keyword
 == 
KEYWORD_FINALLY
) {

1866 
	`next
();

1867 
s
->
try
.
finally
 = 
	`parse_statement
();

1869 
s
->
try
.
finally
 = 
NULL
;

1872 return 
s
;

1873 
	}
}

1875 static struct 
statement
 *

1876 
	$parse_export
(void)

1878 
	`consume_keyword
(
KEYWORD_EXPORT
);

1880 struct 
statement
 *
s
 = 
	`mkstmt
();

1881 
s
->
type
 = 
STATEMENT_EXPORT
;

1883 
	`vec_init
(
s
->
exports
);

1885 while (
	`tok
()->
type
 == 
TOKEN_IDENTIFIER
) {

1886 
	`vec_push
(
s
->
exports
, 
	`tok
()->
identifier
);

1887 
	`next
();

1888 if (
	`tok
()->
type
 == ',')

1889 
	`next
();

1891 
	`expect
(
TOKEN_NEWLINE
);

1894 
	`consume
(
TOKEN_NEWLINE
);

1896 return 
s
;

1897 
	}
}

1899 static struct 
statement
 *

1900 
	$parse_import
(void)

1902 struct 
statement
 *
s
 = 
	`mkstmt
();

1903 
s
->
type
 = 
STATEMENT_IMPORT
;

1905 
	`consume_keyword
(
KEYWORD_IMPORT
);

1907 
	`expect
(
TOKEN_IDENTIFIER
);

1908 char *
mod
 = 
	`tok
()->
module
;

1909 char *
id
 = 
	`tok
()->
identifier
;

1910 
	`next
();

1912 int 
modlen
 = (
mod
 == 
NULL
) ? 0 : 
	`strlen
(mod);

1913 int 
idlen
 = 
	`strlen
(
id
);

1915 char *
module
 = 
	`alloc
(
modlen
 + 
idlen
 + 2);

1916 if (
mod
 != 
NULL
) {

1917 
	`strcpy
(
module
, 
mod
);

1918 
	`strcat
(
module
, "/");

1919 
	`strcat
(
module
, 
id
);

1921 
	`strcpy
(
module
, 
id
);

1924 
s
->
import
.
module
 = module;

1926 if (
	`tok
()->
type
 == 
TOKEN_IDENTIFIER
 && 
	`strcmp
(tok()->
identifier
, "as") == 0) {

1927 
	`next
();

1928 
	`expect
(
TOKEN_IDENTIFIER
);

1929 
s
->
import
.
as
 = 
	`tok
()->
identifier
;

1930 
	`next
();

1932 
s
->
import
.
as
 = 
module
;

1935 
	`vec_init
(
s
->
import
.
identifiers
);

1937 if (
	`tok
()->
type
 == '(') {

1938 
	`next
();

1939 if (
	`tok
()->
type
 == 
TOKEN_DOT_DOT
) {

1940 
	`next
();

1941 
	`vec_push
(
s
->
import
.
identifiers
, "..");

1942 } else while (
	`tok
()->
type
 == 
TOKEN_IDENTIFIER
) {

1943 
	`vec_push
(
s
->
import
.
identifiers
, 
	`tok
()->
identifier
);

1944 
	`next
();

1945 if (
	`tok
()->
type
 == ',')

1946 
	`next
();

1948 
	`expect
(')');

1950 
	`consume
(')');

1953 
	`consume
(
TOKEN_NEWLINE
);

1955 return 
s
;

1956 
	}
}

1958 static struct 
statement
 *

1959 
	$parse_statement
(void)

1961 struct 
statement
 *
s
;

1963 
lex_ctx
 = 
LEX_PREFIX
;

1965 switch (
	`tok
()->
type
) {

1966 case '{': return 
	`parse_block
();

1967 case ';': return 
	`parse_null_statement
();

1968 case 
TOKEN_KEYWORD
: goto 
keyword
;

1969 default: goto 
expression
;

1972 
keyword
:

1974 switch (
	`tok
()->
keyword
) {

1975 case 
KEYWORD_CLASS
: return 
	`parse_class_definition
();

1976 case 
KEYWORD_TAG
: return 
	`parse_class_definition
();

1977 case 
KEYWORD_FOR
: return 
	`parse_for_loop
();

1978 case 
KEYWORD_WHILE
: return 
	`parse_while_loop
();

1979 case 
KEYWORD_IF
: return 
	`parse_if_statement
();

1980 case 
KEYWORD_FUNCTION
: return 
	`parse_function_definition
();

1981 case 
KEYWORD_OPERATOR
: return 
	`parse_operator_definition
();

1982 case 
KEYWORD_MATCH
: return 
	`parse_match_statement
();

1983 case 
KEYWORD_RETURN
: return 
	`parse_return_statement
();

1984 case 
KEYWORD_LET
: return 
	`parse_let_definition
();

1985 case 
KEYWORD_BREAK
: return 
	`parse_break_statement
();

1986 case 
KEYWORD_CONTINUE
: return 
	`parse_continue_statement
();

1987 case 
KEYWORD_TRY
: return 
	`parse_try
();

1988 case 
KEYWORD_THROW
: return 
	`parse_throw
();

1989 default: goto 
expression
;

1992 
expression
:

1994 
s
 = 
	`mkstmt
();

1995 
s
->
type
 = 
STATEMENT_EXPRESSION
;

1996 
s
->
expression
 = 
	`parse_expr
(-1);

1997 
	`consume
(';');

1999 return 
s
;

2000 
	}
}

2003 
	$parse_error
(void)

2005 return 
errbuf
;

2006 
	}
}

2008 struct 
statement
 **

2009 
	$parse
(char const *
source
, char const *
file
)

2011 
	`vec
(struct 
statement
 *) 
program
;

2012 
	`vec_init
(
program
);

2014 
depth
 = 0;

2016 
filename
 = 
file
;

2018 
	`vec_init
(
tokens
);

2019 
tokidx
 = 0;

2020 
lex_ctx
 = 
LEX_PREFIX
;

2022 
	`lex_init
(
file
);

2023 
	`lex_start
(
source
);

2025 if (
	`setjmp
(
jb
) != 0) {

2026 
	`vec_empty
(
program
);

2027 
	`lex_end
();

2028 return 
NULL
;

2031 while (
	`tok
()->
type
 == 
TOKEN_KEYWORD
 && tok()->
keyword
 == 
KEYWORD_IMPORT
)

2032 
	`vec_push
(
program
, 
	`parse_import
());

2034 while (
	`tok
()->
type
 == 
TOKEN_KEYWORD
 && tok()->
keyword
 == 
KEYWORD_EXPORT
)

2035 
	`vec_push
(
program
, 
	`parse_export
());

2037 while (
	`tok
()->
type
 != 
TOKEN_END
)

2038 
	`vec_push
(
program
, 
	`parse_statement
());

2040 
	`vec_push
(
program
, 
NULL
);

2042 
	`lex_end
();

2044 return 
program
.
items
;

2045 
	}
}

2047 #define 
	#parse
(
s
) 
	`parse
(s, "<test>")

	)

2049 
	$TEST
(
break_statement
)

2051 char const *
source
 = "break;";

2052 struct 
statement
 **
p
 = 
	`parse
(
source
);

2053 struct 
statement
 *
s
 = 
p
[0];

2055 
	`claim
(
p
[1] == 
NULL
);

2057 
	`claim
(
s
 != 
NULL
);

2058 
	`claim
(
s
->
type
 == 
STATEMENT_BREAK
);

2059 
	`claim
(
s
 == &
BREAK_STATEMENT
);

2060 
	}
}

2062 
	$TEST
(
parse_error
)

2064 char const *
source
 = "function a (,) { }";

2065 struct 
statement
 **
p
 = 
	`parse
(
source
);

2066 
	`claim
(
p
 == 
NULL
);

2068 
	`claim
(
	`strstr
(
	`parse_error
(), "but found token ','"));

2069 
	}
}

2071 
	$TEST
(
trivial_function
)

2073 
	`claim
(
	`parse
("function f();") != 
NULL
);

2074 
	}
}

2076 
	$TEST
(
number
)

2078 
	`claim
(
	`parse
("45.3;") != 
NULL
);

2079 
	}
}

2081 
	$TEST
(
string
)

2083 
	`claim
(
	`parse
("'hello, world!';") != 
NULL
);

2084 
	}
}

2086 
	$TEST
(
function_call
)

2088 struct 
statement
 **
s
;

2090 
	`claim
((
s
 = 
	`parse
("f();")) != 
NULL
);

2092 
	`claim
((
s
 = 
	`parse
("f(43);")) != 
NULL
);

2094 
	`claim
((
s
 = 
	`parse
("f(a, b, g(c));")) != 
NULL
);

2095 
	}
}

2097 
	$TEST
(
parenthesized_expression
)

2099 
	`claim
(
	`parse
("(((3)));") != 
NULL
);

2100 
	}
}

2102 
	$TEST
(
plus_op
)

2104 struct 
statement
 *
s
 = 
	`parse
("a + 4 + f();")[0];

2105 
	`claim
(
s
->
type
 == 
STATEMENT_EXPRESSION
);

2106 
	`claim
(
s
->
expression
->
type
 == 
EXPRESSION_PLUS
);

2107 
	`claim
(
s
->
expression
->
left
->
type
 == 
EXPRESSION_PLUS
);

2108 
	`claim
(
s
->
expression
->
left
->left->
type
 == 
EXPRESSION_IDENTIFIER
);

2109 
	`claim
(
s
->
expression
->
left
->
right
->
type
 == 
EXPRESSION_INTEGER
);

2110 
	}
}

2112 
	$TEST
(
object_literal
)

2115 struct 
statement
 *
s
 = 
	`parse
("1 + {};")[0];

2116 
	`claim
(
s
->
type
 == 
STATEMENT_EXPRESSION
);

2117 
	`claim
(
s
->
expression
->
type
 == 
EXPRESSION_PLUS
);

2118 
	`claim
(
s
->
expression
->
right
->
type
 == 
EXPRESSION_DICT
);

2119 
	`claim
(
s
->
expression
->
right
->
keys
.
count
 == 0);

2120 
	`claim
(
s
->
expression
->
right
->
values
.
count
 == 0);

2122 
s
 = 
	`parse
("1 + {4 + 3: 'test'};")[0];

2123 
	`claim
(
s
->
type
 == 
STATEMENT_EXPRESSION
);

2124 
	`claim
(
s
->
expression
->
type
 == 
EXPRESSION_PLUS
);

2125 
	`claim
(
s
->
expression
->
right
->
type
 == 
EXPRESSION_DICT
);

2126 
	`claim
(
s
->
expression
->
right
->
keys
.
count
 == 1);

2127 
	`claim
(
s
->
expression
->
right
->
values
.
count
 == 1);

2128 
	`claim
(
s
->
expression
->
right
->
keys
.
items
[0]->
type
 == 
EXPRESSION_PLUS
);

2129 
	`claim
(
s
->
expression
->
right
->
values
.
items
[0]->
type
 == 
EXPRESSION_STRING
);

2130 
	}
}

2132 
	$TEST
(
array_literal
)

2134 struct 
statement
 *
s
 = 
	`parse
("[1, 2, 3];")[0];

2135 
	`claim
(
s
->
type
 == 
STATEMENT_EXPRESSION
);

2136 
	`claim
(
s
->
expression
->
type
 == 
EXPRESSION_ARRAY
);

2137 
	`claim
(
s
->
expression
->
elements
.
count
 == 3);

2138 
	}
}

2140 
	$TEST
(
test_programs
)

2142 char *
test_progs
[] = {

2148 for (
size_t
 
i
 = 0; i < sizeof 
test_progs
 / sizeof test_progs[0]; ++i) {

2149 struct 
statement
 **
p
 = 
	`parse
(
	`slurp
(
test_progs
[
i
]));

2150 if (
p
 == 
NULL
) {

2151 
	`printf
("\n%s: %s\n", 
test_progs
[
i
], 
	`parse_error
());

2152 
	`claim
(
false
);

2155 
	}
}

2157 
	$TEST
(
method_call
)

2159 struct 
statement
 **
p
 = 
	`parse
("buffer.verticalSplit();");

2160 
	`claim
(
p
 != 
NULL
);

2162 struct 
statement
 *
s
 = 
p
[0];

2163 
	`claim
(
s
->
type
 == 
STATEMENT_EXPRESSION
);

2164 
	`claim
(
s
->
expression
->
type
 == 
EXPRESSION_METHOD_CALL
);

2165 
	`claim
(
s
->
expression
->
object
->
type
 == 
EXPRESSION_IDENTIFIER
);

2166 
	`claim
(
	`strcmp
(
s
->
expression
->
object
->
identifier
, "buffer") == 0);

2167 
	`claim
(
	`strcmp
(
s
->
expression
->
method_name
, "verticalSplit") == 0);

2168 
	`claim
(
s
->
expression
->
method_args
.
count
 == 0);

2169 
	}
}

2171 
	$TEST
(
let
)

2173 
	`claim
(
	`parse
("let a = 12;") != 
NULL
);

2174 
	`claim
(
	`parse
("let [a, b] = [12, 14];") != 
NULL
);

2175 
	`claim
(
	`parse
("let [[a1, a2], b] = [[12, 19], 14];") != 
NULL
);

2177 
	`claim
(
	`parse
("let a[3] = 5;") == 
NULL
);

2178 
	`claim
(
	`strstr
(
	`parse_error
(), "failed to parse lvalue in 'let' definition") != 
NULL
);

2179 
	}
}

2181 
	$TEST
(
each_loop
)

2183 struct 
statement
 **
p
 = 
	`parse
("for (a in as) print(a);");

2184 
	`claim
(
p
 != 
NULL
);

2186 struct 
statement
 *
s
 = 
p
[0];

2187 
	`claim
(
s
->
type
 == 
STATEMENT_EACH_LOOP
);

2188 
	`claim
(
s
->
each
.
array
->
type
 == 
EXPRESSION_IDENTIFIER
);

2189 
	`claim
(
s
->
each
.
target
->
type
 == 
EXPRESSION_IDENTIFIER
);

2190 
	`claim
(
s
->
each
.
body
->
type
 == 
STATEMENT_EXPRESSION
);

2191 
	`claim
(
s
->
each
.
body
->
expression
->
type
 == 
EXPRESSION_FUNCTION_CALL
);

2192 
	}
}

2194 
	$TEST
(
arrow
)

2196 struct 
statement
 **
p
 = 
	`parse
("let f = (a, b) -> a + b;");

2197 
	`claim
(
p
 != 
NULL
);

2199 struct 
statement
 *
s
 = 
p
[0];

2200 
	`claim
(
s
->
type
 == 
STATEMENT_DEFINITION
);

2201 
	`claim
(
s
->
value
->
type
 == 
EXPRESSION_FUNCTION
);

2202 
	`claim
(
s
->
value
->
params
.
count
 == 2);

2203 
	`claim
(
s
->
value
->
body
->
type
 == 
STATEMENT_RETURN
);

2204 
	`claim
(
s
->
value
->
body
->
returns
.
items
[0]->
type
 == 
EXPRESSION_PLUS
);

2205 
	}
}

2207 
	$TEST
(
import
)

2209 struct 
statement
 **
p
 = 
	`parse
("import editor::buffer as buffer\n");

2210 
	`claim
(
p
 != 
NULL
);

2212 struct 
statement
 *
s
 = 
p
[0];

2213 
	`claim
(
s
->
type
 == 
STATEMENT_IMPORT
);

2214 
	`printf
("module: %s", 
s
->
import
.
module
);

2215 
	`claim
(
	`strcmp
(
s
->
import
.
module
, "editor/buffer") == 0);

2216 
	`claim
(
	`strcmp
(
s
->
import
.
as
, "buffer") == 0);

2217 
	}
}

2219 
	$TEST
(
div_vs_regex
)

2221 
	`claim
(
	`parse
("print(100 / 5 / 2);") != 
NULL
);

2222 
	}
}

2224 
	$TEST
(
regex
)

2226 
	`parse
("/hello/;");

2227 
	`printf
("%s\n", 
	`parse_error
());

2228 
	}
}

2230 
	$TEST
(
match
)

2232 
	`claim
(
	`parse
("match g(4, [4]) { Add([a, b]) | a != 0 => return a + b;, Mul([a, b]) => a * b; }") != 
NULL
);

2233 
	}
}

2235 
	$TEST
(
special_string
)

2237 
	`claim
(
	`parse
("let s = \"{a +}\";") == 
NULL
);

2238 
	`claim
(
	`parse
("let s = \"{a + 4}\";") != 
NULL
);

2239 
	}
}

2241 
	$TEST
(
method_defs
)

2243 
	`claim
(
	`parse
("tag Foo;") != 
NULL
);

2244 
	`claim
(
	`parse
("tag Baz {}") != 
NULL
);

2245 
	`claim
(
	`parse
("tag Baz { foo(a, b, c) { return 42 * 10; } }") != 
NULL
);

2247 
	`claim
(
	`parse
("tag Bar") == 
NULL
);

2248 
	`claim
(
	`parse
("tag Blah { 5 }") == 
NULL
);

2249 
	`claim
(
	`parse
("tag Blah {") == 
NULL
);

2250 
	}
}

	@scope.c

1 #include 
	~<stdint.h
>

2 #include 
	~<string.h
>

4 #include 
	~"scope.h
"

5 #include 
	~"alloc.h
"

6 #include 
	~"util.h
"

8 static int 
	gSYMBOL
;

10 
inline
 static struct 
symbol
 *

11 
	$local_lookup
(struct 
scope
 const *
s
, char const *
id
)

13 
uint64_t
 
h
 = 
	`strhash
(
id
);

14 int 
i
 = 
h
 % 
SYMBOL_TABLE_SIZE
;

16 for (struct 
symbol
 *
sym
 = 
s
->
table
[
i
]; sym != 
NULL
; sym = sym->
next
)

17 if (
sym
->
hash
 == 
h
 && 
	`strcmp
(sym->
identifier
, 
id
) == 0)

18 return 
sym
;

20 return 
NULL
;

21 
	}
}

23 struct 
scope
 *

24 
	$scope_new
(struct 
scope
 *
parent
, 
bool
 
is_function
)

26 struct 
scope
 *
s
 = 
	`alloc
(sizeof *s);

28 
s
->
is_function
 = is_function;

29 
s
->
parent
 = parent;

30 
s
->
function
 = (
is_function
 || 
parent
 == 
NULL
) ? s : parent->function;

31 
s
->
external
 = 
false
;

33 
	`vec_init
(
s
->
function_symbols
);

35 for (int 
i
 = 0; i < 
SYMBOL_TABLE_SIZE
; ++i)

36 
s
->
table
[
i
] = 
NULL
;

38 return 
s
;

39 
	}
}

41 struct 
symbol
 *

42 
	$scope_lookup
(struct 
scope
 const *
s
, char const *
id
)

44 while (
s
 != 
NULL
) {

45 struct 
symbol
 *
sym
 = 
	`local_lookup
(
s
, 
id
);

46 if (
sym
 != 
NULL
)

47 return 
sym
;

48 
s
 = s->
parent
;

51 return 
NULL
;

52 
	}
}

54 
bool


55 
	$scope_locally_defined
(struct 
scope
 const *
s
, char const *
id
)

57 return 
	`local_lookup
(
s
, 
id
) != 
NULL
;

58 
	}
}

60 struct 
symbol
 *

61 
	$scope_add
(struct 
scope
 *
s
, char const *
id
)

63 
uint64_t
 
h
 = 
	`strhash
(
id
);

64 int 
i
 = 
h
 % 
SYMBOL_TABLE_SIZE
;

66 struct 
symbol
 *
sym
 = 
	`alloc
(sizeof *sym);

68 
sym
->
identifier
 = 
id
;

69 
sym
->
symbol
 = 
SYMBOL
++;

70 
sym
->
public
 = 
false
;

71 
sym
->
tag
 = -1;

72 
sym
->
class
 = -1;

73 
sym
->
scope
 = 
s
;

75 
sym
->
hash
 = 
h
;

76 
sym
->
next
 = 
s
->
table
[
i
];

78 
	`vec_push
(
s
->
function
->
function_symbols
, 
sym
);

80 
s
->
table
[
i
] = 
sym
;

82 return 
sym
;

83 
	}
}

86 
	$scope_insert
(struct 
scope
 *
s
, struct 
symbol
 *
sym
)

88 struct 
symbol
 *
newsym
 = 
	`alloc
(sizeof *newsym);

89 *
newsym
 = *
sym
;

91 
newsym
->
scope
 = 
s
;

92 
newsym
->
public
 = 
false
;

94 int 
i
 = 
sym
->
hash
 % 
SYMBOL_TABLE_SIZE
;

95 
newsym
->
next
 = 
s
->
table
[
i
];

96 
s
->
table
[
i
] = 
newsym
;

97 
	}
}

100 
	$scope_copy_public
(struct 
scope
 *
dst
, struct scope const *
src
)

102 for (int 
i
 = 0; i < 
SYMBOL_TABLE_SIZE
; ++i) {

103 for (struct 
symbol
 *
s
 = 
src
->
table
[
i
]; s != 
NULL
; s = s->
next
) {

104 struct 
symbol
 *
conflict
 = 
	`scope_lookup
(
dst
, 
s
->
identifier
);

105 if (
conflict
 != 
NULL
 && conflict->
public
)

106 return 
conflict
->
identifier
;

110 for (int 
i
 = 0; i < 
SYMBOL_TABLE_SIZE
; ++i)

111 for (struct 
symbol
 *
s
 = 
src
->
table
[
i
]; s != 
NULL
; s = s->
next
)

112 if (
s
->
public
)

113 
	`scope_insert
(
dst
, 
s
);

115 return 
NULL
;

116 
	}
}

118 
bool


119 
	$scope_is_subscope
(struct 
scope
 const *
sub
, struct scope const *scope)

121 while (
sub
 != 
NULL
) {

122 if (
sub
->
parent
 == 
scope
)

123 return 
true
;

124 
sub
 = sub->
parent
;

127 return 
false
;

128 
	}
}

131 
	$scope_get_symbol
(void)

133 return 
SYMBOL
;

134 
	}
}

137 
	$scope_set_symbol
(int 
s
)

139 
SYMBOL
 = 
s
;

140 
	}
}

	@str.c

1 #include 
	~<string.h
>

3 #include 
	~<utf8proc.h
>

5 #include 
	~"utf8.h
"

6 #include 
	~"value.h
"

7 #include 
	~"util.h
"

8 #include 
	~"gc.h
"

9 #include 
	~"vm.h
"

11 static struct 
stringpos
 
	glimitpos
;

12 static struct 
stringpos
 
	goutpos
;

14 
inline
 static void

15 
	$stringcount
(char const *
s
, int 
byte_lim
, int 
grapheme_lim
)

17 
limitpos
.
bytes
 = 
byte_lim
;

18 
limitpos
.
graphemes
 = 
grapheme_lim
;

19 
	`utf8_stringcount
(
s
, 
byte_lim
, &
outpos
, &
limitpos
);

20 
	}
}

22 
inline
 static 
bool


23 
	$is_prefix
(char const *
big
, int 
blen
, char const *
small
, int 
slen
)

25 return (
blen
 >= 
slen
) && (
	`memcmp
(
big
, 
small
, slen) == 0);

26 
	}
}

28 
inline
 static char const *

29 
	$sfind
(char const *
big
, int 
blen
, char const *
small
, int 
slen
)

31 register int 
i
;

33 while (
blen
 >= 
slen
) {

34 for (
i
 = 0; i < 
slen
; ++i) {

35 if (
big
[
i
] != 
small
[i]) {

36 goto 
next
;

40 return 
big
;

42 
next
:

43 ++
big
;

44 --
blen
;

47 return 
NULL
;

49 
	}
}

51 static struct 
value


52 
	$string_length
(struct 
value
 *
string
, 
value_vector
 *
args
)

54 if (
args
->
count
 != 0)

55 
	`vm_panic
("str.len() expects no arguments but got %zu", 
args
->
count
);

57 
	`stringcount
(
string
->string, string->
bytes
, -1);

59 return 
	`INTEGER
(
outpos
.
graphemes
);

60 
	}
}

62 static struct 
value


63 
	$string_size
(struct 
value
 *
string
, 
value_vector
 *
args
)

65 if (
args
->
count
 != 0)

66 
	`vm_panic
("str.size() expects no arguments but got %zu", 
args
->
count
);

68 return 
	`INTEGER
(
string
->
bytes
);

69 
	}
}

71 static struct 
value


72 
	$string_slice
(struct 
value
 *
string
, 
value_vector
 *
args
)

74 if (
args
->
count
 == 0 || args->count > 2)

75 
	`vm_panic
("str.slice() expects 1 or 2 arguments but got %zu", 
args
->
count
);

77 struct 
value
 
start
 = 
args
->
items
[0];

79 if (
start
.
type
 != 
VALUE_INTEGER
)

80 
	`vm_panic
("non-integer passed as first argument to str.slice()");

82 char const *
s
 = 
string
->string;

83 int 
i
 = 
start
.
integer
;

84 int 
n
;

86 if (
args
->
count
 == 2) {

87 struct 
value
 
len
 = 
args
->
items
[1];

88 if (
len
.
type
 != 
VALUE_INTEGER
)

89 
	`vm_panic
("non-integer passed as second argument to str.slice()");

90 if (
len
.
integer
 < 0)

91 
	`vm_panic
("negative integer passed as second argument to str.slice()");

92 
n
 = 
len
.
integer
;

94 
n
 = -1;

97 
	`stringcount
(
s
, 
string
->
bytes
, -1);

99 if (
i
 < 0)

100 
i
 += 
outpos
.
graphemes
;

102 if (
i
 < 0 || i > 
outpos
.
graphemes
)

103 return 
NIL
;

105 
	`stringcount
(
s
, 
string
->
bytes
, 
i
);

107 
i
 = 
outpos
.
bytes
;

109 
	`stringcount
(
s
 + 
i
, 
limitpos
.
bytes
 - 
outpos
.bytes, 
n
);

111 return 
	`STRING_VIEW
(*
string
, 
i
, 
outpos
.
bytes
);

112 
	}
}

114 static struct 
value


115 
	$string_search
(struct 
value
 *
string
, 
value_vector
 *
args
)

117 if (
args
->
count
 != 1 && args->count != 2)

118 
	`vm_panic
("str.search() expects 1 or 2 arguments but got %zu", 
args
->
count
);

120 struct 
value
 
pattern
 = 
args
->
items
[0];

122 if (
pattern
.
type
 != 
VALUE_STRING
 && pattern.type != 
VALUE_REGEX
)

123 
	`vm_panic
("the pattern argument to str.search() must be a string or a regex");

125 int 
offset
;

126 if (
args
->
count
 == 1)

127 
offset
 = 0;

128 else if (
args
->
items
[1].
type
 == 
VALUE_INTEGER
)

129 
offset
 = 
args
->
items
[1].
integer
;

131 
	`vm_panic
("the second argument to str.search() must be an integer");

133 if (
offset
 < 0) {

134 
	`stringcount
(
string
->string, string->
bytes
, -1);

135 
offset
 += 
outpos
.
graphemes
;

138 if (
offset
 < 0)

139 
	`vm_panic
("invalid offset passed to str.search()");

141 
	`stringcount
(
string
->string, string->
bytes
, 
offset
);

142 if (
outpos
.
graphemes
 != 
offset
)

143 return 
NIL
;

145 char const *
s
 = 
string
->string + 
outpos
.
bytes
;

146 int 
bytes
 = 
string
->bytes - 
outpos
.bytes;

148 int 
n
;

150 if (
pattern
.
type
 == 
VALUE_STRING
) {

151 char const *
match
 = 
	`memmem
(
s
, 
bytes
, 
pattern
.
string
, pattern.bytes);

153 if (
match
 == 
NULL
)

154 return 
NIL
;

156 
n
 = 
match
 - 
s
;

158 
pcre
 *
re
 = 
pattern
.
regex
;

159 int 
rc
;

160 int 
out
[3];

162 
rc
 = 
	`pcre_exec
(
re
, 
NULL
, 
s
, 
bytes
, 0, 0, 
out
, 3);

164 if (
rc
 == -1)

165 return 
NIL
;

167 if (
rc
 < -1)

168 
	`vm_panic
("error executing regular expression");

170 
n
 = 
out
[0];

173 
	`stringcount
(
s
, 
n
, -1);

175 return 
	`INTEGER
(
offset
 + 
outpos
.
graphemes
);

176 
	}
}

178 static struct 
value


179 
	$string_split
(struct 
value
 *
string
, 
value_vector
 *
args
)

181 if (
args
->
count
 != 1)

182 
	`vm_panic
("the split method on strings expects 1 argument but got %zu", 
args
->
count
);

184 char const *
s
 = 
string
->string;

185 int 
len
 = 
string
->
bytes
;

187 struct 
value
 
pattern
 = 
args
->
items
[0];

189 if (
pattern
.
type
 == 
VALUE_INTEGER
) {

190 int 
i
 = 
pattern
.
integer
;

191 int 
n
 = 
	`utf8_charcount
(
s
, 
len
);

192 if (
i
 < 0)

193 
i
 += 
n
;

194 if (
i
 < 0)

195 
i
 = 0;

196 if (
i
 > 
n
)

197 
i
 = 
n
;

198 
	`stringcount
(
s
, 
len
, 
i
);

199 struct 
array
 *
parts
 = 
	`value_array_new
();

200 
	`NOGC
(
parts
);

201 
	`value_array_push
(
parts
, 
	`STRING_VIEW
(*
string
, 0, 
outpos
.
bytes
));

202 
	`value_array_push
(
parts
, 
	`STRING_VIEW
(*
string
, 
outpos
.
bytes
, 
len
 - outpos.bytes));

203 
	`OKGC
(
parts
);

204 return 
	`ARRAY
(
parts
);

207 if (
pattern
.
type
 != 
VALUE_REGEX
 && pattern.type != 
VALUE_STRING
)

208 
	`vm_panic
("invalid argument to the split method on string");

210 struct 
value
 
result
 = 
	`ARRAY
(
	`value_array_new
());

211 
	`NOGC
(
result
.
array
);

213 if (
pattern
.
type
 == 
VALUE_STRING
) {

214 char const *
p
 = 
pattern
.
string
;

215 int 
n
 = 
pattern
.
bytes
;

217 if (
n
 == 0)

218 goto 
end
;

220 int 
i
 = 0;

221 while (
i
 < 
len
 && 
	`is_prefix
(
s
 + i, len - i, 
p
, 
n
))

222 
i
 += 
n
;

224 while (
i
 < 
len
) {

226 struct 
value
 
str
 = 
	`STRING_VIEW
(*
string
, 
i
, 0);

228 while (
i
 < 
len
 && !
	`is_prefix
(
s
 + i, len - i, 
p
, 
n
)) {

229 ++
str
.
bytes
;

230 ++
i
;

233 
	`value_array_push
(
result
.
array
, 
str
);

235 while (
i
 < 
len
 && 
	`is_prefix
(
s
 + i, len - i, 
p
, 
n
))

236 
i
 += 
n
;

239 
pcre
 *
re
 = 
pattern
.
regex
;

240 int 
len
 = 
string
->
bytes
;

241 int 
start
 = 0;

242 int 
out
[3];

244 while (
start
 < 
len
) {

245 if (
	`pcre_exec
(
re
, 
NULL
, 
s
, 
len
, 
start
, 0, 
out
, 3) != 1)

246 
out
[0] = out[1] = 
len
;

248 if (
out
[0] == out[1] && out[1] != 
len
) {

249 ++
out
[0];

250 ++
out
[1];

253 int 
n
 = 
out
[0] - 
start
;

255 if (
n
 > 0)

256 
	`value_array_push
(
result
.
array
, 
	`STRING_VIEW
(*
string
, 
start
, 
n
));

258 
start
 = 
out
[1];

262 
end
:

263 
	`OKGC
(
result
.
array
);

264 return 
result
;

265 
	}
}

267 static struct 
value


268 
	$string_replace
(struct 
value
 *
string
, 
value_vector
 *
args
)

270 
	`vec
(char) 
chars
;

271 
size_t
 const 
header
 = 
	`offsetof
(struct 
alloc
, 
data
);

274 
	`vec_init
(
chars
);

275 
	`vec_reserve
(
chars
, 
header
);

276 
chars
.
count
 = chars.
capacity
;

278 if (
args
->
count
 != 2)

279 
	`vm_panic
("the replace method on strings expects 2 arguments but got %zu", 
args
->
count
);

281 struct 
value
 
pattern
 = 
args
->
items
[0];

282 struct 
value
 
replacement
 = 
args
->
items
[1];

284 if (
pattern
.
type
 != 
VALUE_REGEX
 && pattern.type != 
VALUE_STRING
)

285 
	`vm_panic
("the pattern argument to string's replace method must be a regex or a string");

287 if (
replacement
.
type
 != 
VALUE_STRING
 && !
	`CALLABLE
(replacement))

288 
	`vm_panic
("the replacement argument to string's replace method must be callable or a string");

290 char const *
s
 = 
string
->string;

292 if (
pattern
.
type
 == 
VALUE_STRING
) {

294 if (
replacement
.
type
 != 
VALUE_STRING
)

295 
	`vm_panic
("non-string replacement passed to string's replace method with a string pattern");

297 char const *
p
 = 
pattern
.
string
;

298 char const *
r
 = 
replacement
.
string
;

300 int 
len
 = 
string
->
bytes
;

301 int 
plen
 = 
pattern
.
bytes
;

302 char const *
m
;

304 while ((
m
 = 
	`sfind
(
s
, 
len
, 
p
, 
plen
)) != 
NULL
) {

305 
	`vec_push_n
(
chars
, 
s
, 
m
 - s);

307 
	`vec_push_n
(
chars
, 
r
, 
replacement
.
bytes
);

309 
len
 -= (
m
 - 
s
 + 
plen
);

310 
s
 = 
m
 + 
plen
;

313 
	`vec_push_n
(
chars
, 
s
, 
len
);

314 } else if (
replacement
.
type
 == 
VALUE_STRING
) {

315 
pcre
 *
re
 = 
pattern
.
regex
;

316 char const *
r
 = 
replacement
.
string
;

317 int 
len
 = 
string
->
bytes
;

318 int 
start
 = 0;

319 int 
out
[3];

321 while (
	`pcre_exec
(
re
, 
NULL
, 
s
, 
len
, 
start
, 0, 
out
, 3) == 1) {

323 
	`vec_push_n
(
chars
, 
s
 + 
start
, 
out
[0] - start);

325 
	`vec_push_n
(
chars
, 
r
, 
replacement
.
bytes
);

327 
start
 = 
out
[1];

330 
	`vec_push_n
(
chars
, 
s
 + 
start
, 
len
 - start);

333 
pcre
 *
re
 = 
pattern
.
regex
;

334 int 
len
 = 
string
->
bytes
;

335 int 
start
 = 0;

336 int 
out
[30];

337 int 
rc
;

339 while ((
rc
 = 
	`pcre_exec
(
re
, 
NULL
, 
s
, 
len
, 
start
, 0, 
out
, 30)) > 0) {

341 
	`vec_push_n
(
chars
, 
s
 + 
start
, 
out
[0] - start);

343 struct 
value
 
match
;

345 if (
rc
 == 1) {

346 
match
 = 
	`STRING_VIEW
(*
string
, 
out
[0], out[1] - out[0]);

348 
match
 = 
	`ARRAY
(
	`value_array_new
());

349 
	`NOGC
(
match
.
array
);

351 int 
j
 = 0;

352 for (int 
i
 = 0; i < 
rc
; ++i, 
j
 += 2)

353 
	`vec_push
(*
match
.
array
, 
	`STRING_VIEW
(*
string
, 
out
[
j
], out[j + 1] - out[j]));

356 struct 
value
 
repstr
 = 
	`vm_eval_function
(&
replacement
, &
match
);

357 if (
repstr
.
type
 != 
VALUE_STRING
)

358 
	`vm_panic
("non-string returned by the replacement function passed to string's replace method");

360 if (
match
.
type
 == 
VALUE_ARRAY
)

361 
	`OKGC
(
match
.
array
);

363 
	`vec_push_n
(
chars
, 
repstr
.
string
, repstr.
bytes
);

365 
start
 = 
out
[1];

368 
	`vec_push_n
(
chars
, 
s
 + 
start
, 
len
 - start);

371 struct 
alloc
 *
a
 = (void *)
chars
.
items
;

372 
a
->
type
 = 
GC_STRING
;

373 
a
->
mark
 = 
GC_NONE
;

374 return 
	`STRING
(
chars
.
items
 + 
header
, chars.
count
 - header);

375 
	}
}

377 static struct 
value


378 
	$string_is_match
(struct 
value
 *
string
, 
value_vector
 *
args
)

380 if (
args
->
count
 != 1)

381 
	`vm_panic
("the match? method on strings expects 1 argument but got %zu", 
args
->
count
);

383 struct 
value
 
pattern
 = 
args
->
items
[0];

385 if (
pattern
.
type
 != 
VALUE_REGEX
)

386 
	`vm_panic
("non-regex passed to the match? method on string");

388 int 
len
 = 
string
->
bytes
;

389 int 
rc
;

391 
rc
 = 
	`pcre_exec
(

392 
pattern
.
regex
,

393 
NULL
,

394 
string
->string,

395 
len
,

398 
NULL
,

402 if (
rc
 < -1)

403 
	`vm_panic
("error while executing regular expression");

405 return 
	`BOOLEAN
(
rc
 != -1);

406 
	}
}

408 static struct 
value


409 
	$string_match
(struct 
value
 *
string
, 
value_vector
 *
args
)

411 if (
args
->
count
 != 1)

412 
	`vm_panic
("the match method on strings expects 1 argument but got %zu", 
args
->
count
);

414 struct 
value
 
pattern
 = 
args
->
items
[0];

416 if (
pattern
.
type
 != 
VALUE_REGEX
)

417 
	`vm_panic
("non-regex passed to the match method on string");

419 static int 
ovec
[30];

420 int 
len
 = 
string
->
bytes
;

421 int 
rc
;

423 
rc
 = 
	`pcre_exec
(

424 
pattern
.
regex
,

425 
NULL
,

426 
string
->string,

427 
len
,

430 
ovec
,

434 if (
rc
 < -1)

435 
	`vm_panic
("error while executing regular expression");

437 if (
rc
 == -1)

438 return 
NIL
;

440 struct 
value
 
match
;

442 if (
rc
 == 1) {

443 
match
 = 
	`STRING_VIEW
(*
string
, 
ovec
[0], ovec[1] - ovec[0]);

445 
match
 = 
	`ARRAY
(
	`value_array_new
());

446 
	`NOGC
(
match
.
array
);

447 
	`value_array_reserve
(
match
.
array
, 
rc
);

449 int 
j
 = 0;

450 for (int 
i
 = 0; i < 
rc
; ++i, 
j
 += 2)

451 
	`vec_push
(*
match
.
array
, 
	`STRING_VIEW
(*
string
, 
ovec
[
j
], ovec[j + 1] - ovec[j]));

453 
	`OKGC
(
match
.
array
);

456 return 
match
;

457 
	}
}

459 static struct 
value


460 
	$string_matches
(struct 
value
 *
string
, 
value_vector
 *
args
)

462 if (
args
->
count
 != 1)

463 
	`vm_panic
("the matches method on strings expects 1 argument but got %zu", 
args
->
count
);

465 struct 
value
 
pattern
 = 
args
->
items
[0];

467 if (
pattern
.
type
 != 
VALUE_REGEX
)

468 
	`vm_panic
("non-regex passed to the matches method on string");

470 struct 
value
 
result
 = 
	`ARRAY
(
	`value_array_new
());

471 
	`gc_push
(&
result
);

473 static int 
ovec
[30];

474 char const *
s
 = 
string
->string;

475 int 
len
 = 
string
->
bytes
;

476 int 
offset
 = 0;

477 int 
rc
;

479 while ((
rc
 = 
	`pcre_exec
(

480 
pattern
.
regex
,

481 
pattern
.
extra
,

482 
s
,

483 
len
,

486 
ovec
,

490 if (
rc
 == 1) {

491 
	`value_array_push
(
result
.
array
, 
	`STRING_VIEW
(*
string
, 
offset
 + 
ovec
[0], ovec[1] - ovec[0]));

493 struct 
value
 
match
 = 
	`ARRAY
(
	`value_array_new
());

494 
	`NOGC
(
match
.
array
);

496 
	`value_array_reserve
(
match
.
array
, 
rc
);

498 int 
j
 = 0;

499 for (int 
i
 = 0; i < 
rc
; ++i, 
j
 += 2)

500 
	`value_array_push
(
match
.
array
, 
	`STRING_VIEW
(*
string
, 
ovec
[
j
] + 
offset
, ovec[j + 1] - ovec[j]));

502 
	`value_array_push
(
result
.
array
, 
match
);

503 
	`OKGC
(
match
.
array
);

506 
s
 += 
ovec
[1];

507 
offset
 += 
ovec
[1];

508 
len
 -= 
ovec
[1];

511 if (
rc
 < -1)

512 
	`vm_panic
("error while executing regular expression");

514 
	`gc_pop
();

516 return 
result
;

517 
	}
}

519 static struct 
value


520 
	$string_byte
(struct 
value
 *
string
, 
value_vector
 *
args
)

522 if (
args
->
count
 != 1)

523 
	`vm_panic
("str.byte() expects 1 argument but got %zu", 
args
->
count
);

525 struct 
value
 
i
 = 
args
->
items
[0];

527 if (
i
.
type
 != 
VALUE_INTEGER
)

528 
	`vm_panic
("non-integer passed to str.byte()");

530 if (
i
.
integer
 < 0)

531 
i
.
integer
 += 
string
->
bytes
;

533 if (
i
.
integer
 < 0 || i.integer >= 
string
->
bytes
)

534 return 
NIL
;

536 return 
	`INTEGER
(
string
->string[
i
.
integer
]);

537 
	}
}

539 static struct 
value


540 
	$string_char
(struct 
value
 *
string
, 
value_vector
 *
args
)

542 if (
args
->
count
 != 1)

543 
	`vm_panic
("the char method on strings expects 1 argument but got %zu", 
args
->
count
);

545 struct 
value
 
i
 = 
args
->
items
[0];

547 if (
i
.
type
 != 
VALUE_INTEGER
)

548 
	`vm_panic
("non-integer passed to the char method on string");

550 if (
i
.
integer
 < 0)

551 
i
.
integer
 += 
	`utf8_charcount
(
string
->string, string->
bytes
);

554 
	`stringcount
(
string
->string, string->
bytes
, 
i
.
integer
);

556 if (
outpos
.
graphemes
 != 
i
.
integer
)

557 return 
NIL
;

559 int 
offset
 = 
outpos
.
bytes
;

561 
	`stringcount
(
string
->string + 
offset
, string->
bytes
 - offset, 1);

563 if (
outpos
.
graphemes
 != 1)

564 return 
NIL
;

566 return 
	`STRING_VIEW
(*
string
, 
offset
, 
outpos
.
bytes
);

567 
	}
}

569 static struct 
value


570 
	$string_chars
(struct 
value
 *
string
, 
value_vector
 *
args
)

572 if (
args
->
count
 != 0)

573 
	`vm_panic
("str.chars() expects no arguments but got %zu", 
args
->
count
);

575 struct 
value
 
result
 = 
	`ARRAY
(
	`value_array_new
());

576 
	`NOGC
(
result
.
array
);

578 int 
i
 = 0;

579 int 
n
 = 
string
->
bytes
;

581 while (
n
 > 0) {

582 
	`stringcount
(
string
->string + 
i
, 
n
, 1);

583 
	`value_array_push
(
result
.
array
, 
	`STRING_VIEW
(*
string
, 
i
, 
outpos
.
bytes
));

584 
i
 += 
outpos
.
bytes
;

585 
n
 -= 
outpos
.
bytes
;

588 
	`OKGC
(
result
.
array
);

590 return 
result
;

591 
	}
}

593 static struct 
value


594 
	$string_bytes
(struct 
value
 *
string
, 
value_vector
 *
args
)

596 if (
args
->
count
 != 0)

597 
	`vm_panic
("str.bytes() expects no arguments but got %zu", 
args
->
count
);

599 struct 
value
 
result
 = 
	`ARRAY
(
	`value_array_new
());

600 
	`NOGC
(
result
.
array
);

602 for (char const *
c
 = 
string
->string; *c != '\0'; ++c) {

603 
	`value_array_push
(
result
.
array
, 
	`INTEGER
(*
c
));

606 
	`OKGC
(
result
.
array
);

608 return 
result
;

609 
	}
}

611 static struct 
value


612 
	$string_lower
(struct 
value
 *
string
, 
value_vector
 *
args
)

614 if (
args
->
count
 != 0)

615 
	`vm_panic
("str.lower() expects no arguments but got %zu", 
args
->
count
);

617 
utf8proc_int32_t
 
c
;

619 
utf8proc_uint8_t
 *
s
 = (utf8proc_uint8_t *) 
string
->string;

620 
size_t
 
len
 = 
string
->
bytes
;

622 
size_t
 
outlen
 = 0;

623 char *
result
 = 
	`value_string_alloc
(4 * 
string
->
bytes
);

625 while (
len
 > 0) {

626 int 
n
 = 
	`utf8proc_iterate
(
s
, 
len
, &
c
);

627 
s
 += 
n
;

628 
len
 -= 
n
;

629 
c
 = 
	`utf8proc_tolower
(c);

630 
outlen
 += 
	`utf8proc_encode_char
(
c
, (
utf8proc_uint8_t
 *)
result
 + outlen);

633 return 
	`STRING
(
result
, 
outlen
);

634 
	}
}

636 static struct 
value


637 
	$string_upper
(struct 
value
 *
string
, 
value_vector
 *
args
)

639 if (
args
->
count
 != 0)

640 
	`vm_panic
("str.upper() expects no arguments but got %zu", 
args
->
count
);

642 
utf8proc_int32_t
 
c
;

644 
utf8proc_uint8_t
 *
s
 = (utf8proc_uint8_t *) 
string
->string;

645 
size_t
 
len
 = 
string
->
bytes
;

647 
size_t
 
outlen
 = 0;

648 char *
result
 = 
	`value_string_alloc
(4 * 
string
->
bytes
);

650 while (
len
 > 0) {

651 int 
n
 = 
	`utf8proc_iterate
(
s
, 
len
, &
c
);

652 
s
 += 
n
;

653 
len
 -= 
n
;

654 
c
 = 
	`utf8proc_toupper
(c);

655 
outlen
 += 
	`utf8proc_encode_char
(
c
, (
utf8proc_uint8_t
 *)
result
 + outlen);

658 return 
	`STRING
(
result
, 
outlen
);

659 
	}
}

661 static struct 
value


662 
	$string_pad_left
(struct 
value
 *
string
, 
value_vector
 *
args
)

664 if (
args
->
count
 != 1 && args->count != 2)

665 
	`vm_panic
("str.padLeft() expects 1 or 2 arguments but got %zu", 
args
->
count
);

667 struct 
value
 
len
 = 
args
->
items
[0];

668 if (
len
.
type
 != 
VALUE_INTEGER
)

669 
	`vm_panic
("the first argument to str.padLeft() must be an integer");

671 
	`stringcount
(
string
->string, string->
bytes
, -1);

672 int 
string_len
 = 
outpos
.
graphemes
;

674 if (
string_len
 >= 
len
.
integer
)

675 return *
string
;

677 char const *
pad
;

678 int 
pad_bytes
;

679 int 
pad_len
;

681 if (
args
->
count
 == 1) {

682 
pad
 = " ";

683 
pad_bytes
 = 
pad_len
 = 1;

685 if (
args
->
items
[1].
type
 != 
VALUE_STRING
)

686 
	`vm_panic
("the second argument to str.padLeft() must be a string");

687 
pad
 = 
args
->
items
[1].
string
;

688 
pad_bytes
 = 
args
->
items
[1].
bytes
;

689 
	`stringcount
(
pad
, 
pad_bytes
, -1);

690 
pad_len
 = 
outpos
.
graphemes
;

693 int 
n
 = (
len
.
integer
 - 
string_len
) / 
pad_len
 + 1;

694 char *
result
 = 
	`value_string_alloc
(
string
->
bytes
 + 
pad_bytes
 * 
n
);

696 int 
current
 = 0;

697 int 
bytes
 = 0;

698 while (
current
 + 
pad_len
 <= 
len
.
integer
 - 
string_len
) {

699 
	`memcpy
(
result
 + 
bytes
, 
pad
, 
pad_bytes
);

700 
current
 += 
pad_len
;

701 
bytes
 += 
pad_bytes
;

704 if (
current
 != 
len
.
integer
 - 
string_len
) {

705 
	`stringcount
(
pad
, 
pad_bytes
, 
len
.
integer
 - 
string_len
 - 
current
);

706 
	`memcpy
(
result
 + 
bytes
, 
pad
, 
outpos
.bytes);

707 
bytes
 += 
outpos
.bytes;

710 
	`memcpy
(
result
 + 
bytes
, 
string
->string, string->bytes);

711 
bytes
 += 
string
->bytes;

713 return 
	`STRING
(
result
, 
bytes
);

714 
	}
}

716 static struct 
value


717 
	$string_pad_right
(struct 
value
 *
string
, 
value_vector
 *
args
)

719 if (
args
->
count
 != 1 && args->count != 2)

720 
	`vm_panic
("str.padRight() expects 1 or 2 arguments but got %zu", 
args
->
count
);

722 struct 
value
 
len
 = 
args
->
items
[0];

723 if (
len
.
type
 != 
VALUE_INTEGER
)

724 
	`vm_panic
("the first argument to str.padRight() must be an integer");

726 
	`stringcount
(
string
->string, string->
bytes
, -1);

727 int 
current
 = 
outpos
.
graphemes
;

729 if (
current
 >= 
len
.
integer
)

730 return *
string
;

732 char const *
pad
;

733 int 
pad_bytes
;

734 int 
pad_len
;

736 if (
args
->
count
 == 1) {

737 
pad
 = " ";

738 
pad_bytes
 = 
pad_len
 = 1;

740 if (
args
->
items
[1].
type
 != 
VALUE_STRING
)

741 
	`vm_panic
("the second argument to str.padRight() must be a string");

742 
pad
 = 
args
->
items
[1].
string
;

743 
pad_bytes
 = 
args
->
items
[1].
bytes
;

744 
	`stringcount
(
pad
, 
pad_bytes
, -1);

745 
pad_len
 = 
outpos
.
graphemes
;

748 int 
n
 = (
len
.
integer
 - 
current
) / 
pad_len
 + 1;

749 char *
result
 = 
	`value_string_alloc
(
string
->
bytes
 + 
pad_bytes
 * 
n
);

750 int 
bytes
 = 
string
->bytes;

751 
	`memcpy
(
result
, 
string
->string, 
bytes
);

753 while (
current
 + 
pad_len
 <= 
len
.
integer
) {

754 
	`memcpy
(
result
 + 
bytes
, 
pad
, 
pad_bytes
);

755 
current
 += 
pad_len
;

756 
bytes
 += 
pad_bytes
;

759 if (
current
 != 
len
.
integer
) {

760 
	`stringcount
(
pad
, 
pad_bytes
, 
len
.
integer
 - 
current
);

761 
	`memcpy
(
result
 + 
bytes
, 
pad
, 
outpos
.bytes);

762 
bytes
 += 
outpos
.bytes;

765 return 
	`STRING
(
result
, 
bytes
);

766 
	}
}

768 
DEFINE_METHOD_TABLE
(

769 { .
name
 = "byte", .
func
 = 
string_byte
 },

770 { .
name
 = "bytes", .
func
 = 
string_bytes
 },

771 { .
name
 = "char", .
func
 = 
string_char
 },

772 { .
name
 = "chars", .
func
 = 
string_chars
 },

773 { .
name
 = "len", .
func
 = 
string_length
 },

774 { .
name
 = "lower", .
func
 = 
string_lower
 },

775 { .
name
 = "match!", .
func
 = 
string_match
 },

776 { .
name
 = "match?", .
func
 = 
string_is_match
 },

777 { .
name
 = "matches", .
func
 = 
string_matches
 },

778 { .
name
 = "padLeft", .
func
 = 
string_pad_left
 },

779 { .
name
 = "padRight", .
func
 = 
string_pad_right
 },

780 { .
name
 = "replace", .
func
 = 
string_replace
 },

781 { .
name
 = "search", .
func
 = 
string_search
 },

782 { .
name
 = "size", .
func
 = 
string_size
 },

783 { .
name
 = "slice", .
func
 = 
string_slice
 },

784 { .
name
 = "split", .
func
 = 
string_split
 },

785 { .
name
 = "upper", .
func
 = 
string_upper
 },

788 
DEFINE_METHOD_LOOKUP
(
string
)

	@table.c

1 #include 
	~"value.h
"

2 #include 
	~"table.h
"

3 #include 
	~"vec.h
"

4 #include 
	~"util.h
"

7 
	$table_init
(struct 
table
 *
t
)

9 for (int 
i
 = 0; i < 
TABLE_SIZE
; ++i) {

10 
	`vec_init
(
t
->
buckets
[
i
].
hashes
);

11 
	`vec_init
(
t
->
buckets
[
i
].
names
);

12 
	`vec_init
(
t
->
buckets
[
i
].
values
);

14 
	}
}

16 struct 
value
 *

17 
	$table_add
(struct 
table
 *
t
, char const *
name
, struct 
value
 
f
)

19 
uint64_t
 
h
 = 
	`strhash
(
name
);

20 int 
i
 = 
h
 % 
TABLE_SIZE
;

22 struct 
value
 *
m
 = 
	`table_lookup
(
t
, 
name
);

24 if (
m
 == 
NULL
) {

25 
	`vec_push
(
t
->
buckets
[
i
].
hashes
, 
h
);

26 
	`vec_push
(
t
->
buckets
[
i
].
names
, 
name
);

27 
	`vec_push
(
t
->
buckets
[
i
].
values
, 
f
);

28 return 
	`vec_last
(
t
->
buckets
[
i
].
values
);

30 *
m
 = 
f
;

31 return 
m
;

33 
	}
}

36 
	$table_copy
(struct 
table
 *
dst
, struct table const *
src
)

38 struct 
bucket
 *
dt
 = 
dst
->
buckets
;

39 struct 
bucket
 const *
st
 = 
src
->
buckets
;

41 for (int 
i
 = 0; i < 
TABLE_SIZE
; ++i) {

42 if (
st
[
i
].
hashes
.
count
 == 0)

44 
	`vec_push_n
(

45 
dt
[
i
].
hashes
,

46 
st
[
i
].
hashes
.
items
,

47 
st
[
i
].
hashes
.
count


49 
	`vec_push_n
(

50 
dt
[
i
].
names
,

51 
st
[
i
].
names
.
items
,

52 
st
[
i
].
names
.
count


54 
	`vec_push_n
(

55 
dt
[
i
].
values
,

56 
st
[
i
].
values
.
items
,

57 
st
[
i
].
values
.
count


60 
	}
}

62 struct 
value
 *

63 
	$table_lookup
(struct 
table
 const *
t
, char const *
name
)

65 
uint64_t
 
h
 = 
	`strhash
(
name
);

66 int 
i
 = 
h
 % 
TABLE_SIZE
;

68 struct 
bucket
 const *
b
 = &
t
->
buckets
[
i
];

70 for (int 
i
 = 0; i < 
b
->
hashes
.
count
; ++i) {

71 if (
b
->
hashes
.
items
[
i
] != 
h
)

73 if (
	`strcmp
(
b
->
names
.
items
[
i
], 
name
) == 0)

74 return &
b
->
values
.
items
[
i
];

77 return 
NULL
;

78 
	}
}

	@tags.c

1 #include 
	~<stdbool.h
>

2 #include 
	~<string.h
>

4 #include 
	~"value.h
"

5 #include 
	~"alloc.h
"

6 #include 
	~"log.h
"

7 #include 
	~"util.h
"

8 #include 
	~"vec.h
"

9 #include 
	~"table.h
"

11 struct 
	gtags
;

13 struct 
	slink
 {

14 int 
	mtag
;

15 struct 
tags
 *
	mt
;

18 struct 
	stags
 {

19 int 
	mn
;

20 int 
	mtag
;

21 struct 
tags
 *
	mnext
;

22 
vec
(struct 
link
) 
	mlinks
;

25 static int 
	gtagcount
 = 0;

26 static 
	$vec
(struct 
tags
 *) 
lists
;

27 static 
	$vec
(char const *) 
names
;

28 static 
	$vec
(struct 
table
) 
tables
;

30 static struct 
tags
 *

31 
	$mklist
(int 
tag
, struct 
tags
 *
next
)

33 struct 
tags
 *
t
 = 
	`alloc
(sizeof *t);

35 
	`vec_init
(
t
->
links
);

36 
t
->
n
 = 
lists
.
count
;

37 
t
->
tag
 = tag;

38 
t
->
next
 = next;

40 
	`vec_push
(
lists
, 
t
);

42 return 
t
;

43 
	}
}

46 
	$tags_init
(void)

48 
	`mklist
(
tagcount
++, 
NULL
);

49 
	}
}

52 
	$tags_new
(char const *
tag
)

54 
	`LOG
("making new tag: %s -> %d", 
tag
, 
tagcount
);

56 
	`vec_push
(
names
, 
tag
);

58 struct 
table
 table;

59 
	`table_init
(&
table
);

60 
	`vec_push
(
tables
, 
table
);

62 
	`mklist
(
tagcount
, 
lists
.
items
[0]);

63 return 
tagcount
++;

64 
	}
}

66 
bool


67 
	$tags_same
(int 
t1
, int 
t2
)

69 return (
lists
.
items
[
t1
]->
tag
 == lists.items[
t2
]->tag);

70 
	}
}

73 
	$tags_push
(int 
n
, int 
tag
)

76 
	`LOG
("tags_push: n = %d, tag = %d", 
n
, 
tag
);

78 struct 
tags
 *
t
 = 
lists
.
items
[
n
];

80 for (int 
i
 = 0; i < 
t
->
links
.
count
; ++i)

81 if (
t
->
links
.
items
[
i
].
tag
 == tag)

82 return 
t
->
links
.
items
[
i
].t->
n
;

84 struct 
tags
 *
new
 = 
	`mklist
(
tag
, 
t
);

85 
	`vec_push
(
t
->
links
, ((struct 
link
){ .t = 
new
, .
tag
 = tag }));

87 return 
new
->
n
;

88 
	}
}

91 
	$tags_pop
(int 
n
)

93 return 
lists
.
items
[
n
]->
next
->n;

94 
	}
}

97 
	$tags_first
(int 
tags
)

99 return 
lists
.
items
[
tags
]->
tag
;

100 
	}
}

106 
	$tags_wrap
(char const *
s
, int 
tags
)

108 static 
	`vec
(char) 
cs
;

110 struct 
tags
 *
list
 = 
lists
.
items
[tags];

111 int 
n
 = 0;

112 while (
list
->
tag
 != 0) {

113 char const *
name
 = 
names
.
items
[
list
->
tag
 - 1];

114 
	`vec_push_n
(
cs
, 
name
, 
	`strlen
(name));

115 
	`vec_push
(
cs
, '(');

116 
list
 = list->
next
;

117 ++
n
;

120 
	`vec_push_n
(
cs
, 
s
, 
	`strlen
(s));

122 while (
n
 --> 0)

123 
	`vec_push
(
cs
, ')');

125 
	`vec_push
(
cs
, '\0');

127 
cs
.
count
 = 0;

129 return 
cs
.
items
;

130 
	}
}

133 
	$tags_lookup
(char const *
name
)

135 for (int 
i
 = 0; i < 
names
.
count
; ++i)

136 if (
	`strcmp
(
names
.
items
[
i
], 
name
) == 0)

137 return 
i
 + 1;

140 
	}
}

143 
	$tags_name
(int 
tag
)

145 return 
names
.
items
[
tag
 - 1];

146 
	}
}

149 
	$tags_add_method
(int 
tag
, char const *
name
, struct 
value
 
f
)

151 
	`LOG
("tag = %d", 
tag
);

152 
	`LOG
("adding method %s to tag %s", 
name
, 
names
.
items
[
tag
 - 1]);

153 
	`table_add
(&
tables
.
items
[
tag
 - 1], 
name
, 
f
);

154 
	}
}

157 
	$tags_copy_methods
(int 
dst
, int 
src
)

159 struct 
table
 *
dt
 = &
tables
.
items
[
dst
 - 1];

160 struct 
table
 const *
st
 = &
tables
.
items
[
src
 - 1];

161 
	`table_copy
(
dt
, 
st
);

162 
	}
}

164 struct 
value
 *

165 
	$tags_lookup_method
(int 
tag
, char const *
name
)

167 struct 
table
 const *
t
 = &
tables
.
items
[
tag
 - 1];

168 return 
	`table_lookup
(
t
, 
name
);

169 
	}
}

	@token.c

1 #include 
	~<string.h
>

2 #include 
	~<stdio.h
>

3 #include 
	~<stdlib.h
>

4 #include 
	~<inttypes.h
>

6 #include 
	~"token.h
"

7 #include 
	~"alloc.h
"

8 #include 
	~"util.h
"

10 static char 
	gtoken_show_buffer
[512];

13 char const *
	mstring
;

14 int 
	mkw_num
;

15 } 
	gkeywords
[] = {

16 { "break", 
KEYWORD_BREAK
 },

17 { "class", 
KEYWORD_CLASS
 },

18 { "continue", 
KEYWORD_CONTINUE
 },

19 { "else", 
KEYWORD_ELSE
 },

20 { "export", 
KEYWORD_EXPORT
 },

21 { "false", 
KEYWORD_FALSE
 },

22 { "for", 
KEYWORD_FOR
 },

23 { "function", 
KEYWORD_FUNCTION
 },

24 { "if", 
KEYWORD_IF
 },

25 { "import", 
KEYWORD_IMPORT
 },

26 { "in", 
KEYWORD_IN
 },

27 { "let", 
KEYWORD_LET
 },

28 { "match", 
KEYWORD_MATCH
 },

29 { "nil", 
KEYWORD_NIL
 },

30 { "return", 
KEYWORD_RETURN
 },

31 { "tag", 
KEYWORD_TAG
 },

32 { "true", 
KEYWORD_TRUE
 },

33 { "while", 
KEYWORD_WHILE
 },

34 { "try", 
KEYWORD_TRY
 },

35 { "catch", 
KEYWORD_CATCH
 },

36 { "finally", 
KEYWORD_FINALLY
 },

37 { "throw", 
KEYWORD_THROW
 },

38 { "operator", 
KEYWORD_OPERATOR
 },

42 char const *
	mop
;

43 int 
	mtoktype
;

44 } 
	goperators
[] = {

45 { "+", 
TOKEN_PLUS
 },

46 { "-", 
TOKEN_MINUS
 },

47 { "*", 
TOKEN_STAR
 },

48 { "/", 
TOKEN_DIV
 },

49 { "%", 
TOKEN_PERCENT
 },

50 { "!=", 
TOKEN_NOT_EQ
 },

51 { "!", 
TOKEN_BANG
 },

52 { "==", 
TOKEN_DBL_EQ
 },

53 { "=", 
TOKEN_EQ
 },

54 { "->", 
TOKEN_ARROW
 },

55 { "=>", 
TOKEN_FAT_ARROW
 },

56 { "~>", 
TOKEN_SQUIGGLY_ARROW
 },

57 { "&&", 
TOKEN_AND
 },

58 { "||", 
TOKEN_OR
 },

59 { "|", 
TOKEN_BIT_OR
 },

60 { "<=>", 
TOKEN_CMP
 },

61 { "<=", 
TOKEN_LEQ
 },

62 { ">=", 
TOKEN_GEQ
 },

63 { "<", 
TOKEN_LT
 },

64 { ">", 
TOKEN_GT
 },

65 { "@", 
TOKEN_AT
 },

66 { "++", 
TOKEN_INC
 },

67 { "--", 
TOKEN_DEC
 },

68 { "+=", 
TOKEN_PLUS_EQ
 },

69 { "*=", 
TOKEN_STAR_EQ
 },

70 { "/=", 
TOKEN_DIV_EQ
 },

71 { "-=", 
TOKEN_MINUS_EQ
 },

73 { "..", 
TOKEN_DOT_DOT
 },

74 { "...", 
TOKEN_DOT_DOT_DOT
 },

79 
	$operator_get_token_type
(char const *
s
)

81 for (
size_t
 
i
 = 0; i < sizeof 
operators
 / sizeof operators[0]; ++i)

82 if (
	`strcmp
(
s
, 
operators
[
i
].
op
) == 0)

83 return 
operators
[
i
].
toktype
;

86 
	}
}

89 
	$keyword_get_number
(char const *
s
)

91 for (
size_t
 
i
 = 0; i < sizeof 
keywords
 / sizeof keywords[0]; ++i)

92 if (
	`strcmp
(
s
, 
keywords
[
i
].
string
) == 0)

93 return 
keywords
[
i
].
kw_num
;

96 
	}
}

99 
	$keyword_show
(int 
kw
)

101 for (
size_t
 
i
 = 0; i < sizeof 
keywords
 / sizeof keywords[0]; ++i)

102 if (
keywords
[
i
].
kw_num
 == 
kw
)

103 return 
keywords
[
i
].
string
;

105 return 
NULL
;

106 
	}
}

109 
	$token_show_type
(int 
type
)

111 switch (
type
) {

112 case 
TOKEN_PLUS
: return "operator '+'";

113 case 
TOKEN_MINUS
: return "operator '-'";

114 case 
TOKEN_STAR
: return "operator '*'";

115 case 
TOKEN_DIV
: return "operator '/'";

116 case 
TOKEN_PERCENT
: return "operator '%'";

117 case 
TOKEN_NOT_EQ
: return "operator '!='";

118 case 
TOKEN_BANG
: return "operator '!'";

119 case 
TOKEN_DBL_EQ
: return "operator '=='";

120 case 
TOKEN_PLUS_EQ
: return "operator '+='";

121 case 
TOKEN_STAR_EQ
: return "operator '*='";

122 case 
TOKEN_DIV_EQ
: return "operator '/='";

123 case 
TOKEN_MINUS_EQ
: return "operator '-='";

124 case 
TOKEN_PERCENT_EQ
: return "operator '%='";

125 case 
TOKEN_EQ
: return "token '='";

126 case 
TOKEN_ARROW
: return "token '->'";

127 case 
TOKEN_FAT_ARROW
: return "token '=>'";

128 case 
TOKEN_SQUIGGLY_ARROW
: return "token '~>'";

129 case 
TOKEN_DOT_DOT
: return "token '..'";

130 case 
TOKEN_DOT_DOT_DOT
: return "token '...'";

131 case 
TOKEN_AND
: return "operator '&&'";

132 case 
TOKEN_OR
: return "operator '||'";

133 case 
TOKEN_BIT_OR
: return "token '|'";

134 case 
TOKEN_CMP
: return "operator '<=>'";

135 case 
TOKEN_LEQ
: return "operator '<='";

136 case 
TOKEN_GEQ
: return "operator '>='";

137 case 
TOKEN_LT
: return "operator '<'";

138 case 
TOKEN_GT
: return "operator '>'";

139 case 
TOKEN_AT
: return "operator '@'";

140 case 
TOKEN_INC
: return "operator '++'";

141 case 
TOKEN_DEC
: return "operator '--'";

142 case 
TOKEN_IDENTIFIER
: return "identifier";

143 case 
TOKEN_USER_OP
: return "user-defined operator";

144 case 
TOKEN_STRING
: return "string";

145 case 
TOKEN_INTEGER
: return "integer";

146 case 
TOKEN_REAL
: return "real";

147 case 
TOKEN_NEWLINE
: return "newline";

148 case 
TOKEN_KEYWORD
: return "keyword";

149 case 
TOKEN_END
: return "end of input";

150 default: 
	`snprintf
(
token_show_buffer
, 512, "token '%c'", 
type
); return 
	`sclone
(token_show_buffer);

152 
	}
}

155 
	$token_show
(struct 
token
 const *
t
)

157 switch (
t
->
type
) {

158 case 
TOKEN_IDENTIFIER
: 
	`snprintf
(
token_show_buffer
, 512, "identifier '%s'", 
t
->
identifier
); break;

159 case 
TOKEN_STRING
: 
	`snprintf
(
token_show_buffer
, 512, "string '%s'", 
t
->
string
); break;

160 case 
TOKEN_INTEGER
: 
	`snprintf
(
token_show_buffer
, 512, "integer '%"
PRIiMAX
"'", 
t
->
integer
); break;

161 case 
TOKEN_REAL
: 
	`snprintf
(
token_show_buffer
, 512, "real '%f'", 
t
->
real
); break;

162 case 
TOKEN_KEYWORD
: 
	`snprintf
(
token_show_buffer
, 512, "keyword '%s'", 
	`keyword_show
(
t
->
keyword
)); break;

163 case 
TOKEN_USER_OP
: 
	`snprintf
(
token_show_buffer
, 512, "operator '%s'", 
t
->
identifier
); break;

164 default: return 
	`token_show_type
(
t
->
type
);

167 return 
	`sclone
(
token_show_buffer
);

168 
	}
}

	@util.c

1 #include 
	~<stdio.h
>

2 #include 
	~<stddef.h
>

3 #include 
	~<string.h
>

4 #include 
	~<stdint.h
>

5 #include 
	~<stdbool.h
>

7 #include 
	~"panic.h
"

8 #include 
	~"alloc.h
"

10 
uintmax_t


11 
	$umax
(
uintmax_t
 
a
, uintmax_t 
b
)

13 return (
a
 > 
b
) ? a : b;

14 
	}
}

16 
uintmax_t


17 
	$umin
(
uintmax_t
 
a
, uintmax_t 
b
)

19 return (
a
 < 
b
) ? a : b;

20 
	}
}

22 
intmax_t


23 
	$max
(
intmax_t
 
a
, intmax_t 
b
)

25 return (
a
 > 
b
) ? a : b;

26 
	}
}

28 
intmax_t


29 
	$min
(
intmax_t
 
a
, intmax_t 
b
)

31 return (
a
 < 
b
) ? a : b;

32 
	}
}

35 
	$sclone
(char const *
s
)

37 
size_t
 
n
 = 
	`strlen
(
s
);

38 char *
new
 = 
	`alloc
(
n
 + 1);

39 
	`memcpy
(
new
, 
s
, 
n
 + 1);

40 return 
new
;

41 
	}
}

43 
bool


44 
	$contains
(char const *
s
, char 
c
)

46 return (
c
 != '\0') && (
	`strchr
(
s
, c) != 
NULL
);

47 
	}
}

50 
	$slurp
(char const *
path
)

52 
FILE
 *
f
 = 
	`fopen
(
path
, "r");

53 if (
f
 == 
NULL
) {

54 return 
NULL
;

57 int 
used
 = 0;

58 int 
capacity
 = 512;

59 char *
contents
 = 
	`alloc
(
capacity
);

61 int 
n
;

62 static char 
buffer
[4096];

63 while ((
n
 = 
	`fread
(
buffer
, 1, sizeof buffer, 
f
)) != 0) {

64 if (
n
 + 
used
 >= 
capacity
) {

65 
capacity
 += 
n
;

66 
capacity
 *= 2;

67 
	`resize
(
contents
, 
capacity
);

70 
	`memcpy
(
contents
 + 
used
, 
buffer
, 
n
);

71 
used
 += 
n
;

74 
	`fclose
(
f
);

76 if (
used
 == 0)

79 
contents
[
used
] = '\0';

80 return 
contents
;

81 
	}
}

	@value.c

1 #include 
	~<string.h
>

2 #include 
	~<stdlib.h
>

3 #include 
	~<assert.h
>

4 #include 
	~<stdbool.h
>

5 #include 
	~<inttypes.h
>

6 #include 
	~<math.h
>

8 #include 
	~"value.h
"

9 #include 
	~"test.h
"

10 #include 
	~"util.h
"

11 #include 
	~"dict.h
"

12 #include 
	~"object.h
"

13 #include 
	~"tags.h
"

14 #include 
	~"class.h
"

15 #include 
	~"log.h
"

16 #include 
	~"gc.h
"

17 #include 
	~"vm.h
"

19 static 
bool


20 
	$arrays_equal
(struct 
value
 const *
v1
, struct value const *
v2
)

22 if (
v1
->
array
->
count
 != 
v2
->array->count)

23 return 
false
;

25 
size_t
 
n
 = 
v1
->
array
->
count
;

27 for (
size_t
 
i
 = 0; i < 
n
; ++i)

28 if (!
	`value_test_equality
(&
v1
->
array
->
items
[
i
], &
v2
->array->items[i]))

29 return 
false
;

31 return 
true
;

32 
	}
}

39 
inline
 static unsigned long

40 
	$str_hash
(char const *
str
, int 
n
)

42 unsigned long 
hash
 = 5381;

44 while (
n
 > 0)

45 
hash
 = ((hash << 5) + hash) + 
str
[--
n
];

47 return 
hash
;

48 
	}
}

50 
inline
 static unsigned long

51 
	$int_hash
(
intmax_t
 
k
)

53 unsigned long 
hash
 = 5381;

54 char const *
bytes
 = (char const *) &
k
;

55 char 
c
;

57 for (int 
i
 = 0; i < sizeof 
k
; ++i) {

58 
c
 = 
bytes
[
i
];

59 
hash
 = ((hash << 5) + hash) + 
c
;

62 return 
hash
;

63 
	}
}

65 
inline
 static unsigned long

66 
	$ptr_hash
(void const *
p
)

68 unsigned long 
hash
 = 5381;

69 char const *
bytes
 = (char const *) &
p
;

70 char 
c
;

72 for (int 
i
 = 0; i < sizeof 
p
; ++i) {

73 
c
 = 
bytes
[
i
];

74 
hash
 = ((hash << 5) + hash) + 
c
;

77 return 
hash
;

78 
	}
}

80 
inline
 static unsigned long

81 
	$flt_hash
(float 
flt
)

83 unsigned long 
hash
 = 5381;

84 char const *
bytes
 = (char const *) &
flt
;

85 char 
c
;

87 for (int 
i
 = 0; i < sizeof 
flt
; ++i) {

88 
c
 = 
bytes
[
i
];

89 
hash
 = ((hash << 5) + hash) + 
c
;

92 return 
hash
;

93 
	}
}

96 
	$ary_hash
(struct 
value
 const *
a
)

98 unsigned long 
hash
 = 5381;

100 for (int 
i
 = 0; i < 
a
->
array
->
count
; ++i) {

101 unsigned long 
c
 = 
	`value_hash
(&
a
->
array
->
items
[
i
]);

102 
hash
 = ((hash << 5) + hash) + 
c
;

105 return 
hash
;

106 
	}
}

108 
inline
 static unsigned long

109 
	$hash
(struct 
value
 const *
val
)

111 switch (
val
->
type
 & ~
VALUE_TAGGED
) {

112 case 
VALUE_NIL
: return 0xDEADBEEFULL;

113 case 
VALUE_BOOLEAN
: return 
val
->
boolean
 ? 0xABCULL : 0xDEFULL;

114 case 
VALUE_STRING
: return 
	`str_hash
(
val
->
string
, val->
bytes
);

115 case 
VALUE_INTEGER
: return 
	`int_hash
(
val
->
integer
);

116 case 
VALUE_REAL
: return 
	`flt_hash
(
val
->
real
);

117 case 
VALUE_ARRAY
: return 
	`ary_hash
(
val
);

118 case 
VALUE_DICT
: return 
	`ptr_hash
(
val
->
dict
);

119 case 
VALUE_OBJECT
: return 
	`ptr_hash
(
val
->
object
);

120 case 
VALUE_METHOD
: return 
	`ptr_hash
(
val
->
method
) ^ ptr_hash(val->
this
);

121 case 
VALUE_BUILTIN_METHOD
: return 
	`ptr_hash
(
val
->
builtin_method
) ^ ptr_hash(val->
this
);

122 case 
VALUE_BUILTIN_FUNCTION
: return 
	`ptr_hash
(
val
->
code
);

123 case 
VALUE_FUNCTION
: return 
	`ptr_hash
(
val
->
builtin_function
);

124 case 
VALUE_REGEX
: return 
	`ptr_hash
(
val
->
regex
);

125 case 
VALUE_TAG
: return (((unsigned long)
val
->
tag
) * 91238) ^ 0x123AEDDULL;

126 case 
VALUE_CLASS
: return (((unsigned long)
val
->
class
) * 2048) ^ 0xAABB1012ULL;

127 default: 
	`vm_panic
("attempt to hash invalid value");

129 
	}
}

132 
	$value_hash
(struct 
value
 const *
val
)

134 return (((unsigned long)
val
->
tags
) << 14) + 
	`hash
(val);

135 
	}
}

138 
	$show_array
(struct 
value
 const *
a
)

140 static 
	`vec
(struct 
array
 *) 
show_arrays
;

142 for (int 
i
 = 0; i < 
show_arrays
.
count
; ++i)

143 if (
show_arrays
.
items
[
i
] == 
a
->
array
)

144 return 
	`sclone
("[...]");

146 
	`vec_push
(
show_arrays
, 
a
->
array
);

148 
size_t
 
capacity
 = 1;

149 
size_t
 
len
 = 1;

150 
size_t
 
n
;

151 char *
s
 = 
	`alloc
(2);

152 
	`strcpy
(
s
, "[");

154 #define 
	#add
(
str
) \

155 
n
 = 
	`strlen
(
str
); \

156 if (
len
 + 
n
 >= 
capacity
) {\

157 
capacity
 = 2 * (
len
 + 
n
) + 1; \

158 
	`resize
(
s
, 
capacity
); \

160 
	`strcpy
(
s
 + 
len
, 
str
); \

161 
len
 += 
n
;

	)

163 for (
size_t
 
i
 = 0; i < 
a
->
array
->
count
; ++i) {

164 char *
val
 = 
	`value_show
(&
a
->
array
->
items
[
i
]);

165 
	`add
(
i
 == 0 ? "" : ", ");

166 
	`add
(
val
);

167 
	`free
(
val
);

170 
	`add
("]");

171 #undef 
add


173 --
show_arrays
.
count
;

175 return 
s
;

176 
	}
}

179 
	$show_string
(char const *
s
, 
size_t
 
n
)

181 
	`vec
(char) 
v
;

182 
	`vec_init
(
v
);

184 
	`vec_push
(
v
, '\'');

186 for (char const *
c
 = 
s
; c < s + 
n
; ++c) switch (*c) {

188 
	`vec_push
(
v
, '\\');

189 
	`vec_push
(
v
, 't');

192 
	`vec_push
(
v
, '\\');

193 
	`vec_push
(
v
, 'r');

196 
	`vec_push
(
v
, '\\');

197 
	`vec_push
(
v
, 'n');

200 
	`vec_push
(
v
, '\\');

202 
	`vec_push
(
v
, *
c
);

205 
	`vec_push
(
v
, '\'');

206 
	`vec_push
(
v
, '\0');

208 return 
v
.
items
;

209 
	}
}

212 
	$value_show
(struct 
value
 const *
v
)

214 static char 
buffer
[1024];

215 char *
s
 = 
NULL
;

217 switch (
v
->
type
 & ~
VALUE_TAGGED
) {

218 case 
VALUE_INTEGER
:

219 
	`snprintf
(
buffer
, 1024, "%"
PRIiMAX
, 
v
->
integer
);

221 case 
VALUE_REAL
:

222 
	`snprintf
(
buffer
, 1024, "%g", 
v
->
real
);

224 case 
VALUE_STRING
:

225 
s
 = 
	`show_string
(
v
->
string
, v->
bytes
);

227 case 
VALUE_BOOLEAN
:

228 
	`snprintf
(
buffer
, 1024, "%s", 
v
->
boolean
 ? "true" : "false");

230 case 
VALUE_NIL
:

231 
	`snprintf
(
buffer
, 1024, "%s", "nil");

233 case 
VALUE_ARRAY
:

234 
s
 = 
	`show_array
(
v
);

236 case 
VALUE_REGEX
:

237 
	`snprintf
(
buffer
, 1024, "/%s/", 
v
->
pattern
);

239 case 
VALUE_DICT
:

240 
	`snprintf
(
buffer
, 1024, "<dict at %p>", (void *) 
v
->
dict
);

242 case 
VALUE_FUNCTION
:

243 
	`snprintf
(
buffer
, 1024, "<function at %p>", (void *) 
v
->
code
);

245 case 
VALUE_METHOD
:

246 if (
v
->
this
 == 
NULL
)

247 
	`snprintf
(
buffer
, 1024, "<method '%s' at %p>", 
v
->
name
, (void *)v->
method
);

249 
	`snprintf
(
buffer
, 1024, "<method '%s' at %p bound to <value at %p>>", 
v
->
name
, (void *)v->
method
, (void *)v->
this
);

251 case 
VALUE_BUILTIN_METHOD
:

252 
	`snprintf
(
buffer
, 1024, "<bound builtin method '%s'>", 
v
->
name
);

254 case 
VALUE_BUILTIN_FUNCTION
:

255 
	`snprintf
(
buffer
, 1024, "<builtin function>");

257 case 
VALUE_CLASS
:

258 
	`snprintf
(
buffer
, 1024, "<class %s>", 
	`class_name
(
v
->
class
));

260 case 
VALUE_OBJECT
:

261 
	`snprintf
(
buffer
, 1024, "<%s object at %p>", 
	`class_name
(
v
->
class
), (void *)v->
object
);

263 case 
VALUE_TAG
:

264 
	`snprintf
(
buffer
, 1024, "%s", 
	`tags_name
(
v
->
tag
));

266 case 
VALUE_BLOB
:

267 
	`snprintf
(
buffer
, 1024, "<blob at %p (%zu bytes)>", (void *) 
v
->
blob
, v->blob->
count
);

269 case 
VALUE_SENTINEL
:

272 return 
	`sclone
("< !!! >");

275 char *
result
 = 
	`sclone
(
	`tags_wrap
(
s
 == 
NULL
 ? 
buffer
 : s, 
v
->
type
 & 
VALUE_TAGGED
 ? v->
tags
 : 0));

276 
	`free
(
s
);

278 return 
result
;

279 
	}
}

282 
	$value_compare
(void const *
_v1
, void const *
_v2
)

284 struct 
value
 const *
v1
 = 
_v1
;

285 struct 
value
 const *
v2
 = 
_v2
;

287 if (
v1
->
type
 != 
v2
->type)

288 
	`vm_panic
("attempt to compare values of different types");

290 switch (
v1
->
type
) {

291 case 
VALUE_INTEGER
: return (
v1
->
integer
 - 
v2
->integer);

292 case 
VALUE_REAL
: return (
v1
->
real
 < 
v2
->real) ? -1 : (v1->real != v2->real);

293 case 
VALUE_STRING
: return 
	`memcmp
(
v1
->
string
, 
v2
->string, 
	`min
(v1->
bytes
, v2->bytes));

294 case 
VALUE_ARRAY
:

295 for (int 
i
 = 0; i < 
v1
->
array
->
count
 && i < 
v2
->array->count; ++i) {

296 int 
o
 = 
	`value_compare
(&
v1
->
array
->
items
[
i
], &
v2
->array->items[i]);

297 if (
o
 != 0)

298 return 
o
;

300 return ((int)
v1
->
array
->
count
) - ((int)
v2
->array->count);

301 case 
VALUE_OBJECT
:;

302 struct 
value
 const *
cmpfn
 = 
	`class_lookup_method
(
v1
->
class
, "<=>");

303 if (
cmpfn
 == 
NULL
)

304 goto 
Fail
;

305 struct 
value
 
v
 = 
	`vm_eval_function2
(
cmpfn
, 
v1
, 
v2
);

306 if (
v
.
type
 != 
VALUE_INTEGER
)

307 
	`vm_panic
("user-defined %s.<=> method returned non-integer", 
	`class_name
(
v1
->
class
));

308 return 
v
.
integer
;

310 
Fail
:

311 
	`vm_panic
("attempt to compare values of invalid types: %s and %s", 
	`value_show
(
v1
), value_show(
v2
));

313 
	}
}

315 
bool


316 
	$value_truthy
(struct 
value
 const *
v
)

318 switch (
v
->
type
) {

319 case 
VALUE_REAL
: return 
v
->
real
 != 0.0f;

320 case 
VALUE_BOOLEAN
: return 
v
->
boolean
;

321 case 
VALUE_INTEGER
: return (
v
->
integer
 != 0);

322 case 
VALUE_STRING
: return (
v
->
string
[0] != '\0');

323 case 
VALUE_ARRAY
: return (
v
->
array
->
count
 != 0);

324 case 
VALUE_REGEX
: return 
true
;

325 case 
VALUE_FUNCTION
: return 
true
;

326 case 
VALUE_BUILTIN_FUNCTION
: return 
true
;

327 case 
VALUE_DICT
: return 
true
;

328 case 
VALUE_CLASS
: return 
true
;

329 case 
VALUE_OBJECT
: return 
true
;

330 case 
VALUE_METHOD
: return 
true
;

331 default: return 
false
;

333 
	}
}

335 
bool


336 
	$value_apply_predicate
(struct 
value
 *
p
, struct value *
v
)

338 struct 
value
 
b
;

340 switch (
p
->
type
) {

341 case 
VALUE_FUNCTION
:

342 case 
VALUE_BUILTIN_FUNCTION
:

343 
b
 = 
	`vm_eval_function
(
p
, 
v
);

344 return 
	`value_truthy
(&
b
);

345 case 
VALUE_REGEX
:

346 if (
v
->
type
 != 
VALUE_STRING
)

347 
	`vm_panic
("regex applied as predicate to non-string");

349 char const *
s
 = 
v
->
string
;

350 int 
len
 = 
v
->
bytes
;

351 int 
rc
;

353 
rc
 = 
	`pcre_exec
(

354 
p
->
regex
,

355 
NULL
,

356 
s
,

357 
len
,

360 
NULL
,

364 if (
rc
 < -1)

365 
	`vm_panic
("error while executing regular expression");

367 return 
rc
 == 0;

369 case 
VALUE_TAG
:

370 return 
	`tags_first
(
v
->
tags
) == 
p
->
tag
;

371 case 
VALUE_CLASS
:

372 return 
v
->
type
 == 
VALUE_OBJECT
 && v->
class
 == 
p
->class;

374 
	`vm_panic
("invalid type of value used as a predicate");

376 
	}
}

378 struct 
value


379 
	$value_apply_callable
(struct 
value
 *
f
, struct value *
v
)

381 switch (
f
->
type
) {

382 case 
VALUE_FUNCTION
:

383 case 
VALUE_BUILTIN_FUNCTION
:

384 case 
VALUE_METHOD
:

385 case 
VALUE_BUILTIN_METHOD
:

386 return 
	`vm_eval_function
(
f
, 
v
);

387 case 
VALUE_REGEX
:

388 if (
v
->
type
 != 
VALUE_STRING
)

389 
	`vm_panic
("regex applied as predicate to non-string");

391 static int 
ovec
[30];

392 char const *
s
 = 
v
->
string
;

393 int 
len
 = 
v
->
bytes
;

394 int 
rc
;

396 
rc
 = 
	`pcre_exec
(

397 
f
->
regex
,

398 
NULL
,

399 
s
,

400 
len
,

403 
ovec
,

407 if (
rc
 < -1)

408 
	`vm_panic
("error while executing regular expression");

410 if (
rc
 == -1)

411 return 
NIL
;

413 struct 
value
 
match
;

415 if (
rc
 == 1) {

416 
match
 = 
	`STRING_VIEW
(*
v
, 
ovec
[0], ovec[1] - ovec[0]);

418 
match
 = 
	`ARRAY
(
	`value_array_new
());

419 
	`NOGC
(
match
.
array
);

420 
	`value_array_reserve
(
match
.
array
, 
rc
);

422 int 
j
 = 0;

423 for (int 
i
 = 0; i < 
rc
; ++i, 
j
 += 2)

424 
	`value_array_push
(
match
.
array
, 
	`STRING_VIEW
(*
v
, 
ovec
[
j
], ovec[j + 1] - ovec[j]));

426 
	`OKGC
(
match
.
array
);

429 return 
match
;

430 case 
VALUE_TAG
:

432 struct 
value
 
result
 = *
v
;

433 
result
.
tags
 = 
	`tags_push
(result.tags, 
f
->
tag
);

434 
result
.
type
 |= 
VALUE_TAGGED
;

435 return 
result
;

437 case 
VALUE_CLASS
:

439 struct 
value
 
result
 = 
	`OBJECT
(
	`object_new
(), 
f
->
class
);

440 struct 
value
 *
init
 = 
	`class_lookup_method
(
f
->
class
, "init");

441 if (
init
 != 
NULL
)

442 
	`vm_eval_function
(&
	`METHOD
(
NULL
, 
init
, &
result
), 
v
);

443 return 
result
;

446 
	`vm_panic
("invalid type of value used as a predicate");

448 
	}
}

450 
bool


451 
	$value_test_equality
(struct 
value
 const *
v1
, struct value const *
v2
)

453 if (
v1
->
type
 != 
v2
->type)

454 return 
false
;

456 switch (
v1
->
type
 & ~
VALUE_TAGGED
) {

457 case 
VALUE_REAL
: if (
v1
->
real
 != 
v2
->real) return 
false
; break;

458 case 
VALUE_BOOLEAN
: if (
v1
->
boolean
 != 
v2
->boolean) return 
false
; break;

459 case 
VALUE_INTEGER
: if (
v1
->
integer
 != 
v2
->integer) return 
false
; break;

460 case 
VALUE_STRING
: if (
v1
->
bytes
 != 
v2
->bytes || 
	`memcmp
(v1->
string
, v2->string, v1->bytes) != 0) return 
false
; break;

461 case 
VALUE_ARRAY
: if (!
	`arrays_equal
(
v1
, 
v2
)) return 
false
; break;

462 case 
VALUE_REGEX
: if (
v1
->
regex
 != 
v2
->regex) return 
false
; break;

463 case 
VALUE_FUNCTION
: if (
v1
->
code
 != 
v2
->code) return 
false
; break;

464 case 
VALUE_BUILTIN_FUNCTION
: if (
v1
->
builtin_function
 != 
v2
->builtin_function) return 
false
; break;

465 case 
VALUE_DICT
: if (
v1
->
dict
 != 
v2
->dict) return 
false
; break;

466 case 
VALUE_OBJECT
: if (
v1
->
object
 != 
v2
->object) return 
false
; break;

467 case 
VALUE_METHOD
: if (
v1
->
method
 != 
v2
->method || v1->
this
 != v2->this) return 
false
; break;

468 case 
VALUE_BUILTIN_METHOD
: if (
v1
->
builtin_method
 != 
v2
->builtin_method || v1->
this
 != v2->this) return 
false
; break;

469 case 
VALUE_TAG
: if (
v1
->
tag
 != 
v2
->tag) return 
false
; break;

470 case 
VALUE_BLOB
: if (
v1
->
blob
->
items
 != 
v2
->blob->items) return 
false
; break;

471 case 
VALUE_NIL
: break;

474 if (
v1
->
tags
 != 
v2
->tags)

475 return 
false
;

477 return 
true
;

478 
	}
}

480 
inline
 static void

481 
	$value_array_mark
(struct 
array
 *
a
)

483 
	`MARK
(
a
);

485 for (int 
i
 = 0; i < 
a
->
count
; ++i)

486 
	`value_mark
(&
a
->
items
[
i
]);

487 
	}
}

489 
inline
 static void

490 
	$function_mark_references
(struct 
value
 *
v
)

492 for (
size_t
 
i
 = 0; i < 
v
->
refs
->
count
; ++i) {

493 struct 
variable
 *
var
 = (struct variable *)
v
->
refs
->refs[
i
].
pointer
;

494 if (
	`MARKED
(
var
))

496 
	`MARK
(
var
);

497 
	`value_mark
(&
var
->
value
);

500 
	`MARK
(
v
->
refs
);

501 
	}
}

504 
	$value_clone_string
(char const *
src
, int 
n
)

506 char *
s
 = 
	`gc_alloc_object
(
n
, 
GC_STRING
);

507 
	`memcpy
(
s
, 
src
, 
n
);

508 return 
s
;

509 
	}
}

512 
	$value_string_alloc
(int 
n
)

514 return 
	`gc_alloc_object
(
n
, 
GC_STRING
);

515 
	}
}

518 
	$_value_mark
(struct 
value
 *
v
)

520 switch (
v
->
type
) {

521 case 
VALUE_METHOD
: 
	`MARK
(
v
->
this
); 
	`value_mark
(v->this); break;

522 case 
VALUE_BUILTIN_METHOD
: 
	`MARK
(
v
->
this
); 
	`value_mark
(v->this); break;

523 case 
VALUE_ARRAY
: 
	`value_array_mark
(
v
->
array
); break;

524 case 
VALUE_DICT
: 
	`dict_mark
(
v
->
dict
); break;

525 case 
VALUE_FUNCTION
: if (
v
->
refs
 != 
NULL
) 
	`function_mark_references
(v); break;

526 case 
VALUE_STRING
: if (
v
->
gcstr
 != 
NULL
) 
	`MARK
(v->gcstr); break;

527 case 
VALUE_OBJECT
: 
	`object_mark
(
v
->
object
); break;

528 case 
VALUE_BLOB
: 
	`MARK
(
v
->
blob
); break;

531 
	}
}

533 struct 
blob
 *

534 
	$value_blob_new
(void)

536 struct 
blob
 *blob = 
	`gc_alloc_object
(sizeof *blob, 
GC_BLOB
);

537 
	`vec_init
(*
blob
);

538 return 
blob
;

539 
	}
}

541 struct 
array
 *

542 
	$value_array_new
(void)

544 struct 
array
 *
a
 = 
	`gc_alloc_object
(sizeof *a, 
GC_ARRAY
);

545 
	`vec_init
(*
a
);

546 return 
a
;

547 
	}
}

549 struct 
array
 *

550 
	$value_array_clone
(struct 
array
 const *
a
)

552 struct 
array
 *
new
 = 
	`value_array_new
();

558 if (
a
->
count
 == 0)

559 return 
new
;

561 
	`NOGC
(
new
);

563 
new
->
count
 = 
a
->count;

564 
new
->
capacity
 = 
a
->
count
;

565 
new
->
items
 = 
	`gc_alloc
(sizeof *new->items * new->
count
);

566 
	`memcpy
(
new
->
items
, 
a
->items, sizeof *new->items * new->
count
);

568 
	`OKGC
(
new
);

570 return 
new
;

571 
	}
}

574 
	$value_array_extend
(struct 
array
 *
a
, struct array const *
other
)

576 int 
n
 = 
a
->
count
 + 
other
->count;

578 if (
n
 != 0)

579 
	`vec_reserve
(*
a
, 
n
);

580 if (
other
->
count
 != 0)

581 
	`memcpy
(
a
->
items
 + a->
count
, 
other
->items, other->count * sizeof (struct 
value
));

583 
a
->
count
 = 
n
;

584 
	}
}

586 struct 
ref_vector
 *

587 
	$ref_vector_new
(int 
n
)

589 struct 
ref_vector
 *
v
 = 
	`gc_alloc_object
(sizeof *v + sizeof (struct 
reference
) * 
n
, 
GC_REF_VECTOR
);

590 
v
->
count
 = 
n
;

591 return 
v
;

592 
	}
}

594 
	$TEST
(
hash
)

596 struct 
value
 
v1
 = 
	`STRING_NOGC
("hello", 5);

597 struct 
value
 
v2
 = 
	`STRING_NOGC
("world", 5);

599 
	`claim
(
	`value_hash
(&
v1
) != value_hash(&
v2
));

600 
	}
}

602 
	$TEST
(
equality
)

604 
	`vm_init
(0, 
NULL
);

606 struct 
value
 
v1
 = 
	`BOOLEAN
(
true
);

607 struct 
value
 
v2
 = 
	`BOOLEAN
(
false
);

608 
	`claim
(!
	`value_test_equality
(&
v1
, &
v2
));

610 
v1
.
type
 = 
VALUE_INTEGER
;

611 
v2
.
type
 = 
VALUE_STRING
;

612 
	`claim
(!
	`value_test_equality
(&
v1
, &
v2
));

614 
v2
.
type
 = 
VALUE_INTEGER
;

616 
v1
.
integer
 = 
v2
.integer = 19;

617 
	`claim
(
	`value_test_equality
(&
v1
, &
v2
));

619 
	`claim
(

620 
	`value_test_equality
(

621 &
NIL
,

622 &
NIL


625 
	}
}

	@vm.c

1 #include 
	~<time.h
>

2 #include 
	~<string.h
>

3 #include 
	~<stdlib.h
>

4 #include 
	~<stdbool.h
>

5 #include 
	~<setjmp.h
>

6 #include 
	~<stdarg.h
>

7 #include 
	~<errno.h
>

8 #include 
	~<stdnoreturn.h
>

10 #include 
	~<pcre.h
>

11 #include 
	~<poll.h
>

12 #include 
	~<fcntl.h
>

13 #include 
	~<unistd.h
>

14 #include 
	~<signal.h
>

16 #include 
	~<sys/types.h
>

17 #include 
	~<sys/wait.h
>

19 #include 
	~"vm.h
"

20 #include 
	~"util.h
"

21 #include 
	~"gc.h
"

22 #include 
	~"dict.h
"

23 #include 
	~"value.h
"

24 #include 
	~"alloc.h
"

25 #include 
	~"compiler.h
"

26 #include 
	~"test.h
"

27 #include 
	~"log.h
"

28 #include 
	~"operators.h
"

29 #include 
	~"array.h
"

30 #include 
	~"str.h
"

31 #include 
	~"blob.h
"

32 #include 
	~"tags.h
"

33 #include 
	~"object.h
"

34 #include 
	~"class.h
"

35 #include 
	~"utf8.h
"

36 #include 
	~"functions.h
"

38 #define 
	#TY_LOG_VERBOSE
 1

	)

40 #define 
	#READVALUE
(
s
) (
	`memcpy
(&s, 
ip
, sizeof s), (ip += sizeof s))

	)

42 #if 
defined
(
TY_LOG_VERBOSE
) && !defined(
TY_NO_LOG
)

43 #define 
	#CASE
(
i
) case 
INSTR_
 ## i: 
loc
 = 
	`compiler_get_location
(
ip
, &
fname
); 
	`LOG
("%s:%d:%d: " #i, fname, loc.
line
 + 1, loc.
col
 + 1);

	)

45 #define 
	#CASE
(
i
) case 
INSTR_
 ## i:

	)

48 static char 
	ghalt
 = 
INSTR_HALT
;

50 static 
jmp_buf
 
	gjb
;

52 struct 
	stry
 {

53 
jmp_buf
 
	mjb
;

54 int 
	msp
;

55 int 
	mgc
;

56 int 
	mcs
;

57 int 
	mts
;

58 char *
	mcatch
;

59 char *
	mfinally
;

60 char *
	mend
;

63 static struct 
variable
 **
	gvars
;

64 static 
bool
 *
	gused
;

66 static 
	$vec
(struct 
value
) 
stack
;

67 static 
	$vec
(char *) 
calls
;

68 static 
	$vec
(
size_t
) 
sp_stack
;

69 static 
	$vec
(struct 
value
 *) 
targets
;

70 static 
	$vec
(struct 
try
) 
try_stack
;

71 static char *
ip
;

73 static int 
symbol_count
;

75 static char const *
filename
;

77 static char const *
err_msg
;

78 static char 
err_buf
[8192];

81 char const *
module
;

82 char const *
name
;

83 struct 
value
 value;

84 } 
builtins
[] = {

85 #include 
	~"builtins.h
"

86 
	}
};

88 static int 
	gbuiltin_count
 = sizeof 
builtins
 / sizeof builtins[0];

91 
vm_exec
(char *
code
);

93 
inline
 static struct 
variable
 *

94 
	$newvar
(struct 
variable
 *
next
)

96 struct 
variable
 *
v
 = 
	`gc_alloc_unregistered
(sizeof *v, 
GC_VARIABLE
);

97 
v
->
captured
 = 
false
;

98 
v
->
try
 = 
try_stack
.
count
;

99 
v
->
prev
 = 
NULL
;

100 
v
->
next
 = next;

101 return 
v
;

102 
	}
}

104 
inline
 static void

105 
	$pushvar
(int 
s
)

107 if (
vars
[
s
] == 
NULL
 || 
used
[s])

108 
vars
[
s
] = 
	`newvar
(vars[s]);

110 
vars
[
s
]->
try
 = 
try_stack
.
count
;

111 
used
[
s
] = 
true
;

112 
	}
}

120 
	$add_builtins
(int 
ac
, char **
av
)

122 
	`resize
(
vars
, sizeof *vars * (
builtin_count
 + 1));

123 
	`resize
(
used
, sizeof *used * (
builtin_count
 + 1));

125 for (int 
i
 = 0; i < 
builtin_count
; ++i) {

126 
	`compiler_introduce_symbol
(
builtins
[
i
].
module
, builtins[i].
name
);

127 
vars
[
i
] = 
	`newvar
(
NULL
);

128 
vars
[
i
]->
value
 = 
builtins
[i].value;

131 struct 
array
 *
args
 = 
	`value_array_new
();

132 
	`NOGC
(
args
);

134 for (int 
i
 = 1; i < 
ac
; ++i)

135 
	`value_array_push
(
args
, 
	`STRING_NOGC
(
av
[
i
], 
	`strlen
(av[i])));

137 
	`compiler_introduce_symbol
("os", "args");

138 
vars
[
builtin_count
] = 
	`newvar
(
NULL
);

139 
vars
[
builtin_count
]->
value
 = 
	`ARRAY
(
args
);

141 
symbol_count
 = 
builtin_count
 + 1;

142 
	}
}

144 
inline
 static struct 
value
 *

145 
	$top
(void)

147 return &
stack
.
items
[stack.
count
 - 1];

148 
	}
}

150 
inline
 static struct 
value


151 
	$pop
(void)

153 return *
	`vec_pop
(
stack
);

154 
	}
}

156 
inline
 static struct 
value


157 
	$peek
(void)

159 return 
stack
.
items
[stack.
count
 - 1];

160 
	}
}

162 
inline
 static void

163 
	$push
(struct 
value
 
v
)

165 
	`vec_push
(
stack
, 
v
);

166 
	}
}

168 
inline
 static struct 
value
 *

169 
	$poptarget
(void)

171 return *
	`vec_pop
(
targets
);

172 
	}
}

174 
inline
 static struct 
value
 *

175 
	$peektarget
(void)

177 return 
targets
.
items
[targets.
count
 - 1];

178 
	}
}

180 
inline
 static void

181 
	$pushtarget
(struct 
value
 *
v
)

183 
	`vec_push
(
targets
, 
v
);

184 
	}
}

186 
inline
 static void

187 
	$call
(struct 
value
 const *
f
, struct value const *
self
, int 
n
, 
bool
 
exec
)

189 for (int 
i
 = 0; i < 
f
->
bound
; ++i)

190 
	`pushvar
(
f
->
symbols
[
i
]);

192 
bool
 
has_self
 = (
f
->
params
 > 0) && (
self
 != 
NULL
);

194 int 
params
 = 
f
->params - 
has_self
;

197 while (
n
 > 
params
) {

198 
	`pop
(), --
n
;

202 for (int 
i
 = 
n
; i < 
params
; ++i)

203 
vars
[
f
->
symbols
[
i
 + 
has_self
]]->
value
 = 
NIL
;

206 while (
n
 --> 0) {

207 
vars
[
f
->
symbols
[
n
 + 
has_self
]]->
value
 = 
	`pop
();

211 if (
has_self
)

212 
vars
[
f
->
symbols
[0]]->
value
 = *
self
;

214 if (
f
->
refs
 != 
NULL
) for (int 
i
 = 0; i < f->refs->
count
; ++i) {

215 struct 
reference
 
ref
 = 
f
->
refs
->refs[
i
];

217 
	`memcpy
(
f
->
code
 + 
ref
.
offset
, &ref.
pointer
, sizeof ref.pointer);

220 if (
exec
) {

221 
	`vec_push
(
calls
, &
halt
);

222 
	`vm_exec
(
f
->
code
);

224 
	`vec_push
(
calls
, 
ip
);

225 
ip
 = 
f
->
code
;

227 
	}
}

230 
	$vm_exec
(char *
code
)

232 char *
save
 = 
ip
;

233 
ip
 = 
code
;

235 
uintptr_t
 
s
, 
s2
, 
off
;

236 
intmax_t
 
k
;

237 
bool
 
b
;

238 float 
f
;

239 int 
n
, 
i
, 
tag
, 
rc
 = 0;

241 struct 
value
 
left
, 
right
, 
v
, 
key
, value, 
container
, 
subscript
, *
vp
;

242 char *
str
;

244 
value_vector
 
args
;

245 
	`vec_init
(
args
);

247 struct 
	`value
 (*
func
)(struct 
value
 *, 
value_vector
 *);

249 struct 
variable
 *
next
;

251 #ifdef 
TY_LOG_VERBOSE


252 struct 
location
 
loc
;

253 char const *
fname
;

257 switch (*
ip
++) {

258 
	`CASE
(
NOP
)

260 
	`CASE
(
PUSH_VAR
)

261 
	`READVALUE
(
s
);

262 
	`pushvar
(
s
);

264 
	`CASE
(
POP_VAR
)

265 
	`READVALUE
(
s
);

266 
next
 = 
vars
[
s
]->next;

267 if (
vars
[
s
]->
captured
) {

268 
	`gc_register
(
vars
[
s
]);

269 if (
vars
[
s
]->
next
 != 
NULL
)

270 
vars
[
s
]->
next
->
prev
 = vars[s]->prev;

271 if (
vars
[
s
]->
prev
 != 
NULL
)

272 
vars
[
s
]->
prev
->
next
 = vars[s]->next;

274 if (
next
 == 
NULL
 && !
vars
[
s
]->
captured
)

275 
used
[
s
] = 
false
;

277 
vars
[
s
] = 
next
;

279 
	`CASE
(
LOAD_VAR
)

280 
	`READVALUE
(
s
);

281 
	`push
(
vars
[
s
]->
value
);

283 
	`CASE
(
CHECK_VARS
)

284 
	`READVALUE
(
n
);

285 while (
n
 --> 0) {

286 
	`READVALUE
(
s
);

287 if (
vars
[
s
]->
captured
) {

288 struct 
variable
 *
next
 = 
	`newvar
(
vars
[
s
]->next);

290 if (
vars
[
s
]->
next
 != 
NULL
)

292 
vars
[
s
]->
next
->
prev
 = next;

293 
	`gc_register
(
vars
[
s
]);

294 
next
->
value
 = 
vars
[
s
]->value;

295 
vars
[
s
] = 
next
;

299 
	`CASE
(
EXEC_CODE
)

300 
	`READVALUE
(
s
);

301 
	`vm_exec
((char *) 
s
);

303 
	`CASE
(
DUP
)

304 
	`push
(
	`peek
());

306 
	`CASE
(
JUMP
)

307 
	`READVALUE
(
n
);

308 
ip
 += 
n
;

310 
	`CASE
(
JUMP_IF
)

311 
	`READVALUE
(
n
);

312 
v
 = 
	`pop
();

313 if (
	`value_truthy
(&
v
)) {

314 
ip
 += 
n
;

317 
	`CASE
(
JUMP_IF_NOT
)

318 
	`READVALUE
(
n
);

319 
v
 = 
	`pop
();

320 if (!
	`value_truthy
(&
v
)) {

321 
ip
 += 
n
;

324 
	`CASE
(
TARGET_VAR
)

325 
	`READVALUE
(
s
);

326 
	`pushtarget
(&
vars
[
s
]->
value
);

328 
	`CASE
(
TARGET_REF
)

329 
	`READVALUE
(
s
);

330 
	`pushtarget
(&((struct 
variable
 *) 
s
)->
value
);

332 
	`CASE
(
TARGET_MEMBER
)

333 
v
 = 
	`pop
();

334 if (!(
v
.
type
 & 
VALUE_OBJECT
))

335 
	`vm_panic
("assignment to member of non-object");

336 
vp
 = 
	`table_lookup
(
v
.
object
, 
ip
);

337 if (
vp
 != 
NULL
)

338 
	`pushtarget
(
vp
);

340 
	`pushtarget
(
	`table_add
(
v
.
object
, 
ip
, 
NIL
));

341 
ip
 += 
	`strlen
(ip) + 1;

343 
	`CASE
(
TARGET_SUBSCRIPT
)

344 
subscript
 = 
	`pop
();

345 
container
 = 
	`pop
();

347 if (
container
.
type
 == 
VALUE_ARRAY
) {

348 if (
subscript
.
type
 != 
VALUE_INTEGER
)

349 
	`vm_panic
("non-integer array index used in subscript assignment");

350 if (
subscript
.
integer
 < 0)

351 
subscript
.
integer
 += 
container
.
array
->
count
;

352 if (
subscript
.
integer
 < 0 || subscript.integer >= 
container
.
array
->
count
)

353 
	`vm_panic
("array index out of range in subscript expression");

354 
	`pushtarget
(&
container
.
array
->
items
[
subscript
.
integer
]);

355 } else if (
container
.
type
 == 
VALUE_DICT
) {

356 
	`pushtarget
(
	`dict_put_key_if_not_exists
(
container
.
dict
, 
subscript
));

358 
	`vm_panic
("attempt to perform subscript assignment on something other than an object or array");

361 
	`CASE
(
ASSIGN
)

362 *
	`poptarget
() = 
	`peek
();

364 
	`CASE
(
TAG_PUSH
)

365 
	`READVALUE
(
tag
);

366 
	`top
()->
tags
 = 
	`tags_push
(top()->tags, 
tag
);

367 
	`top
()->
type
 |= 
VALUE_TAGGED
;

369 
	`CASE
(
ARRAY_REST
)

370 
	`READVALUE
(
s
);

371 
	`READVALUE
(
i
);

372 
	`READVALUE
(
n
);

373 if (
	`top
()->
type
 != 
VALUE_ARRAY
) {

374 
	`LOG
("cannot do rest: top is not an array");

375 
ip
 += 
n
;

378 
vars
[
s
]->
value
 = 
	`ARRAY
(
	`value_array_new
());

379 
	`vec_push_n
(*
vars
[
s
]->
value
.
array
, 
	`top
()->array->
items
 + 
i
, top()->array->
count
 - i);

382 
	`CASE
(
DIE_IF_NIL
)

383 if (
	`top
()->
type
 == 
VALUE_NIL
)

384 
	`vm_panic
("failed to match %s against the non-nil pattern", 
	`value_show
(
	`top
()));

386 
	`CASE
(
UNTAG_OR_DIE
)

387 
	`READVALUE
(
tag
);

388 if (!
	`tags_same
(
	`tags_first
(
	`top
()->
tags
), 
tag
)) {

389 
	`vm_panic
("failed to match %s against the tag %s", 
	`value_show
(
	`top
()), 
	`tags_name
(
tag
));

391 
	`top
()->
tags
 = 
	`tags_pop
(top()->tags);

392 
	`top
()->
type
 &= ~
VALUE_TAGGED
;

395 
	`CASE
(
BAD_MATCH
)

396 
	`vm_panic
("expression did not match any patterns in match expression");

398 
	`CASE
(
THROW
)

400 if (
try_stack
.
count
 == 0)

401 
	`vm_panic
("uncaught exception: %s", 
	`value_show
(
	`top
()));

403 struct 
try
 *
t
 = 
	`vec_last
(
try_stack
);

405 
v
 = 
	`pop
();

406 
stack
.
count
 = 
t
->
sp
;

407 
	`push
(
v
);

409 
targets
.
count
 = 
t
->
ts
;

410 
calls
.
count
 = 
t
->
cs
;

411 
ip
 = 
t
->
catch
;

413 for (
i
 = 0; i < 
symbol_count
; ++i) {

414 while (
vars
[
i
] != 
NULL
 && vars[i]->
try
 >= 
try_stack
.
count
) {

415 if (
vars
[
i
]->
captured
 && vars[i]->
next
 != 
NULL
)

416 
vars
[
i
]->
next
->
prev
 = vars[i]->prev;

417 
vars
[
i
] = vars[i]->
next
;

421 
	`gc_truncate_root_set
(
t
->
gc
);

423 
	`longjmp
(
t
->
jb
, 1);

426 
	`CASE
(
FINALLY
)

428 struct 
try
 *
t
 = 
	`vec_pop
(
try_stack
);

429 if (
t
->
finally
 == 
NULL
)

431 *
t
->
end
 = 
INSTR_HALT
;

432 
	`vm_exec
(
t
->
finally
);

433 *
t
->
end
 = 
INSTR_NOP
;

436 
	`CASE
(
POP_TRY
)

437 --
try_stack
.
count
;

439 
	`CASE
(
TRY
)

441 
	`READVALUE
(
n
);

442 struct 
try
 
t
;

443 if (
	`setjmp
(
t
.
jb
) != 0)

445 
t
.
catch
 = 
ip
 + 
n
;

446 
	`READVALUE
(
n
);

447 
t
.
finally
 = (
n
 == -1) ? 
NULL
 : 
ip
 + n;

448 
	`READVALUE
(
n
);

449 
t
.
end
 = (
n
 == -1) ? 
NULL
 : 
ip
 + n;

450 
t
.
sp
 = 
stack
.
count
;

451 
t
.
gc
 = 
	`gc_root_set_count
();

452 
t
.
cs
 = 
calls
.
count
;

453 
t
.
ts
 = 
targets
.
count
;

454 
	`vec_push
(
try_stack
, 
t
);

457 
	`CASE
(
ENSURE_LEN
)

458 
	`READVALUE
(
n
);

459 
b
 = 
	`top
()->
array
->
count
 == 
n
;

460 
	`READVALUE
(
n
);

461 if (!
b
)

462 
ip
 += 
n
;

464 
	`CASE
(
ENSURE_EQUALS_VAR
)

465 
	`READVALUE
(
s
);

466 
	`READVALUE
(
n
);

467 if (!
	`value_test_equality
(
	`top
(), &
vars
[
s
]->
value
))

468 
ip
 += 
n
;

470 
	`CASE
(
TRY_ASSIGN_NON_NIL
)

471 
	`READVALUE
(
s
);

472 
	`READVALUE
(
n
);

473 if (
	`top
()->
type
 == 
VALUE_NIL
)

474 
ip
 += 
n
;

476 
vars
[
s
]->
value
 = 
	`peek
();

478 
	`CASE
(
TRY_REGEX
)

479 
	`READVALUE
(
s
);

480 
	`READVALUE
(
s2
);

481 
	`READVALUE
(
n
);

482 
v
 = 
	`REGEX
((
pcre
 *) 
s
);

483 
v
.
extra
 = (
pcre_extra
 *) 
s2
;

484 if (!
	`value_apply_predicate
(&
v
, 
	`top
()))

485 
ip
 += 
n
;

487 
	`CASE
(
TRY_INDEX
)

488 
	`READVALUE
(
i
);

489 
	`READVALUE
(
n
);

491 if (
	`top
()->
type
 != 
VALUE_ARRAY
 || top()->
array
->
count
 <= 
i
)

492 
ip
 += 
n
;

494 
	`push
(
	`top
()->
array
->
items
[
i
]);

496 
	`CASE
(
TRY_TAG_POP
)

497 
	`READVALUE
(
tag
);

498 
	`READVALUE
(
n
);

499 if (!
	`tags_same
(
	`top
()->
tags
, 
tag
)) {

501 
ip
 += 
n
;

504 
	`top
()->
tags
 = 
	`tags_pop
(top()->tags);

505 if (
	`top
()->
tags
 == 0) {

506 
	`top
()->
type
 &= ~
VALUE_TAGGED
;

510 
	`CASE
(
POP
)

511 
	`pop
();

513 
	`CASE
(
LOAD_REF
)

514 
	`READVALUE
(
s
);

516 
	`push
(((struct 
variable
 *) 
s
)->
value
);

518 
	`CASE
(
INTEGER
)

519 
	`READVALUE
(
k
);

520 
	`push
(
	`INTEGER
(
k
));

522 
	`CASE
(
REAL
)

523 
	`READVALUE
(
f
);

524 
	`push
(
	`REAL
(
f
));

526 
	`CASE
(
BOOLEAN
)

527 
	`READVALUE
(
b
);

528 
	`push
(
	`BOOLEAN
(
b
));

530 
	`CASE
(
STRING
)

531 
n
 = 
	`strlen
(
ip
);

532 
	`push
(
	`STRING_NOGC
(
ip
, 
n
));

533 
ip
 += 
n
 + 1;

535 
	`CASE
(
CLASS
)

536 
	`READVALUE
(
tag
);

537 
	`push
(
	`CLASS
(
tag
));

539 
	`CASE
(
TAG
)

540 
	`READVALUE
(
tag
);

541 
	`push
(
	`TAG
(
tag
));

543 
	`CASE
(
REGEX
)

544 
	`READVALUE
(
s
);

545 
v
 = 
	`REGEX
((
pcre
 *) 
s
);

546 
	`READVALUE
(
s
);

547 
v
.
extra
 = (
pcre_extra
 *) 
s
;

548 
	`READVALUE
(
s
);

549 
v
.
pattern
 = (char const *) 
s
;

550 
	`push
(
v
);

552 
	`CASE
(
ARRAY
)

553 
v
 = 
	`ARRAY
(
	`value_array_new
());

555 
	`READVALUE
(
n
);

556 
	`vec_reserve
(*
v
.
array
, 
n
);

557 for (
i
 = 0; i < 
n
; ++i)

558 
	`vec_push
(*
v
.
array
, 
	`pop
());

560 
	`push
(
v
);

562 
	`CASE
(
DICT
)

563 
v
 = 
	`DICT
(
	`dict_new
());

565 
	`READVALUE
(
n
);

566 for (
i
 = 0; i < 
n
; ++i) {

567 
value
 = 
	`pop
();

568 
key
 = 
	`pop
();

569 
	`dict_put_value
(
v
.
dict
, 
key
, 
value
);

572 
	`push
(
v
);

574 
	`CASE
(
NIL
)

575 
	`push
(
NIL
);

577 
	`CASE
(
TO_STRING
)

578 
args
.
count
 = 0;

579 
	`vec_push
(
args
, *
	`top
());

580 
v
 = 
	`builtin_str
(&
args
);

581 
	`pop
();

582 
	`push
(
v
);

584 
	`CASE
(
GET_NEXT
)

585 
v
 = 
	`peek
();

586 
i
 = 
	`top
()[-1].i++;

587 switch (
v
.
type
) {

588 case 
VALUE_ARRAY
:

589 if (
i
 < 
v
.
array
->
count
) {

590 
	`push
(
v
.
array
->
items
[
i
]);

592 
	`push
(
NIL
);

595 case 
VALUE_DICT
:

596 
off
 = 
	`top
()[-1].off;

597 while (
off
 < 
v
.
dict
->
size
 && v.dict->
keys
[off].
type
 == 0) ++off;

598 if (
off
 < 
v
.
dict
->
size
) {

599 
	`top
()[-1].
off
 = off + 1;

600 
	`push
(
v
.
dict
->
keys
[
off
]);

601 if (
ip
[-2] == 
INSTR_READ_INDEX
) {

603 *
	`poptarget
() = 
v
.
dict
->
values
[
off
];

606 
	`push
(
NIL
);

609 case 
VALUE_OBJECT
:

610 if ((
vp
 = 
	`class_lookup_method
(
v
.
class
, "__next__")) != 
NULL
) {

611 
	`push
(
	`INTEGER
(
i
));

612 
	`call
(
vp
, &
v
, 1, 
false
);

613 } else if ((
vp
 = 
	`class_lookup_method
(
v
.
class
, "__iter__")) != 
NULL
) {

614 
	`pop
();

615 
	`call
(
vp
, &
v
, 0, 
false
);

617 
	`vec_last
(
calls
)[0] -= 1;

620 goto 
NoIter
;

623 case 
VALUE_BLOB
:

624 if (
i
 < 
v
.
blob
->
count
) {

625 
	`push
(
	`INTEGER
(
v
.
blob
->
items
[
i
]));

627 
	`push
(
NIL
);

630 case 
VALUE_STRING
:

631 
vp
 = 
	`top
() - 1;

632 if ((
off
 = 
vp
->off) < 
v
.
bytes
) {

633 
vp
->
off
 += (
n
 = 
	`utf8_char_len
(
v
.
string
 + off));

634 
	`push
(
	`STRING_VIEW
(
v
, 
off
, 
n
));

636 
	`push
(
NIL
);

640 
NoIter
:

641 
	`vm_panic
("for-each loop on non-iterable value");

644 
	`CASE
(
PUSH_INDEX
)

645 
	`push
(
	`INDEX
(0, 0));

647 
	`CASE
(
READ_INDEX
)

648 if (
	`top
()->
type
 != 
VALUE_DICT
)

649 *
	`poptarget
() = 
	`INTEGER
(
	`top
()[-1].
i
);

651 
	`CASE
(
SENTINEL
)

652 
	`push
(
SENTINEL
);

654 
	`CASE
(
CLEAR_RC
)

655 
rc
 = 0;

657 
	`CASE
(
GET_EXTRA
)

658 
stack
.
count
 += 
rc
;

660 
	`CASE
(
MULTI_ASSIGN
)

661 
	`READVALUE
(
n
);

662 for (
i
 = 0, 
vp
 = 
	`top
(); 
	`pop
().
type
 != 
VALUE_SENTINEL
; ++i)

664 for (int 
j
 = 
targets
.
count
 - 
n
; n > 0; --n, --targets.count) {

665 if (
i
 > 0) {

666 *
targets
.
items
[
j
++] = 
vp
[-(--
i
)];

668 *
targets
.
items
[
j
++] = 
NIL
;

671 
	`push
(
	`top
()[2]);

673 
	`CASE
(
CONCAT_STRINGS
)

674 
	`READVALUE
(
n
);

675 
k
 = 0;

676 for (
i
 = 
stack
.
count
 - 
n
; i < stack.count; ++i)

677 
k
 += 
stack
.
items
[
i
].
bytes
;

678 
str
 = 
	`value_string_alloc
(
k
);

679 
v
 = 
	`STRING
(
str
, 
k
);

680 
k
 = 0;

681 for (
i
 = 
stack
.
count
 - 
n
; i < stack.count; ++i) {

682 
	`memcpy
(
str
 + 
k
, 
stack
.
items
[
i
].
string
, stack.items[i].
bytes
);

683 
k
 += 
stack
.
items
[
i
].
bytes
;

685 
stack
.
count
 -= 
n
 - 1;

686 
stack
.
items
[stack.
count
 - 1] = 
v
;

688 
	`CASE
(
RANGE
)

689 
right
 = 
	`pop
();

690 
left
 = 
	`pop
();

691 if (
right
.
type
 != 
VALUE_INTEGER
 || 
left
.type != VALUE_INTEGER)

692 
	`vm_panic
("non-integer used as bound in range");

693 
v
 = 
	`ARRAY
(
	`value_array_new
());

694 
	`push
(
v
);

695 
	`value_array_reserve
(
v
.
array
, 
	`labs
(
right
.
integer
 - 
left
.integer) + 2);

696 if (
left
.
integer
 < 
right
.integer)

697 for (int 
i
 = 
left
.
integer
; i < 
right
.integer; ++i)

698 
v
.
array
->
items
[v.array->
count
++] = 
	`INTEGER
(
i
);

700 for (int 
i
 = 
left
.
integer
; i > 
right
.integer; --i)

701 
v
.
array
->
items
[v.array->
count
++] = 
	`INTEGER
(
i
);

703 
	`CASE
(
INCRANGE
)

704 
right
 = 
	`pop
();

705 
left
 = 
	`pop
();

706 if (
right
.
type
 != 
VALUE_INTEGER
 || 
left
.type != VALUE_INTEGER)

707 
	`vm_panic
("non-integer used as bound in range");

708 
v
 = 
	`ARRAY
(
	`value_array_new
());

709 
	`push
(
v
);

710 
	`value_array_reserve
(
v
.
array
, 
	`labs
(
right
.
integer
 - 
left
.integer) + 2);

711 if (
left
.
integer
 < 
right
.integer)

712 for (int 
i
 = 
left
.
integer
; i <= 
right
.integer; ++i)

713 
v
.
array
->
items
[v.array->
count
++] = 
	`INTEGER
(
i
);

715 for (int 
i
 = 
left
.
integer
; i >= 
right
.integer; --i)

716 
v
.
array
->
items
[v.array->
count
++] = 
	`INTEGER
(
i
);

718 
	`CASE
(
MEMBER_ACCESS
)

719 
v
 = 
	`pop
();

721 char const *
member
 = 
ip
;

722 
ip
 += 
	`strlen
(ip) + 1;

724 
vp
 = 
NULL
;

725 if (
v
.
type
 & 
VALUE_TAGGED
) for (int 
tags
 = v.tags; tags != 0; tags = 
	`tags_pop
(tags)) {

726 
vp
 = 
	`tags_lookup_method
(
	`tags_first
(
tags
), 
member
);

727 if (
vp
 != 
NULL
) {

728 struct 
value
 *
this
 = 
	`gc_alloc_object
(sizeof *this, 
GC_VALUE
);

729 *
this
 = 
v
;

730 
this
->
tags
 = tags;

731 
	`push
(
	`METHOD
(
member
, 
vp
, 
this
));

736 if (
vp
 != 
NULL
)

739 struct 
value
 *
this
;

741 switch (
v
.
type
 & ~
VALUE_TAGGED
) {

742 case 
VALUE_NIL
:

743 
	`push
(
NIL
);

745 case 
VALUE_DICT
:

746 
func
 = 
	`get_dict_method
(
member
);

747 if (
func
 == 
NULL
)

748 
	`vm_panic
("reference to non-existent method '%s' on dict", 
member
);

749 
v
.
type
 = 
VALUE_ARRAY
;

750 
v
.
tags
 = 0;

751 
this
 = 
	`gc_alloc_object
(sizeof *this, 
GC_VALUE
);

752 *
this
 = 
v
;

753 
	`push
(
	`BUILTIN_METHOD
(
member
, 
func
, 
this
));

755 case 
VALUE_ARRAY
:

756 
func
 = 
	`get_array_method
(
member
);

757 if (
func
 == 
NULL
)

758 
	`vm_panic
("reference to non-existent method '%s' on array", 
member
);

759 
v
.
type
 = 
VALUE_ARRAY
;

760 
v
.
tags
 = 0;

761 
this
 = 
	`gc_alloc_object
(sizeof *this, 
GC_VALUE
);

762 *
this
 = 
v
;

763 
	`push
(
	`BUILTIN_METHOD
(
member
, 
func
, 
this
));

765 case 
VALUE_STRING
:

766 
func
 = 
	`get_string_method
(
member
);

767 if (
func
 == 
NULL
)

768 
	`vm_panic
("reference to non-existent method '%s' on string", 
member
);

769 
v
.
type
 = 
VALUE_STRING
;

770 
v
.
tags
 = 0;

771 
this
 = 
	`gc_alloc_object
(sizeof *this, 
GC_VALUE
);

772 *
this
 = 
v
;

773 
	`push
(
	`BUILTIN_METHOD
(
member
, 
func
, 
this
));

775 case 
VALUE_BLOB
:

776 
func
 = 
	`get_blob_method
(
member
);

777 if (
func
 == 
NULL
)

778 
	`vm_panic
("reference to non-existent method '%s' on blob", 
member
);

779 
v
.
type
 = 
VALUE_BLOB
;

780 
v
.
tags
 = 0;

781 
this
 = 
	`gc_alloc_object
(sizeof *this, 
GC_VALUE
);

782 *
this
 = 
v
;

783 
	`push
(
	`BUILTIN_METHOD
(
member
, 
func
, 
this
));

785 case 
VALUE_OBJECT
:

786 
vp
 = 
	`table_lookup
(
v
.
object
, 
member
);

787 if (
vp
 != 
NULL
) {

788 
	`push
(*
vp
);

791 
vp
 = 
	`class_lookup_method
(
v
.
class
, 
member
);

792 if (
vp
 != 
NULL
) {

793 
this
 = 
	`gc_alloc_object
(sizeof *this, 
GC_VALUE
);

794 *
this
 = 
v
;

795 
	`push
(
	`METHOD
(
member
, 
vp
, 
this
));

798 
	`vm_panic
("attempt to access non-existent member '%s' of %s", 
member
, 
	`value_show
(&
v
));

800 case 
VALUE_TAG
:

801 
vp
 = 
	`tags_lookup_method
(
v
.
tag
, 
member
);

802 
	`push
(
vp
 == 
NULL
 ? 
NIL
 : *vp);

804 case 
VALUE_CLASS
:

805 
vp
 = 
	`class_lookup_method
(
v
.
class
, 
member
);

806 
	`push
(
vp
 == 
NULL
 ? 
NIL
 : *vp);

809 
	`vm_panic
("member access on value of invalid type: %s", 
	`value_show
(&
v
));

813 
	`CASE
(
SUBSCRIPT
)

814 
subscript
 = 
	`pop
();

815 
container
 = 
	`pop
();

817 switch (
container
.
type
) {

818 case 
VALUE_ARRAY
:

819 if (
subscript
.
type
 != 
VALUE_INTEGER
)

820 
	`vm_panic
("non-integer array index used in subscript expression");

821 if (
subscript
.
integer
 < 0)

822 
subscript
.
integer
 += 
container
.
array
->
count
;

823 if (
subscript
.
integer
 < 0 || subscript.integer >= 
container
.
array
->
count
)

824 
	`vm_panic
("array index out of range in subscript expression");

825 
	`push
(
container
.
array
->
items
[
subscript
.
integer
]);

827 case 
VALUE_STRING
:

828 
	`push
(
	`get_string_method
("char")(&
container
, (&(
value_vector
){ .
count
 = 1, .
items
 = &
subscript
 })));

830 case 
VALUE_BLOB
:

831 
	`push
(
	`get_blob_method
("get")(&
container
, (&(
value_vector
){ .
count
 = 1, .
items
 = &
subscript
 })));

833 case 
VALUE_DICT
:

834 
vp
 = 
	`dict_get_value
(
container
.
dict
, &
subscript
);

835 
	`push
((
vp
 == 
NULL
) ? 
NIL
 : *vp);

837 case 
VALUE_NIL
:

838 
	`push
(
NIL
);

841 
	`vm_panic
("attempt to subscript something other than an object or array");

844 
	`CASE
(
NOT
)

845 
v
 = 
	`pop
();

846 
	`push
(
	`unary_operator_not
(&
v
));

848 
	`CASE
(
NEG
)

849 
v
 = 
	`pop
();

850 
	`push
(
	`unary_operator_negate
(&
v
));

852 
	`CASE
(
ADD
)

853 
right
 = 
	`pop
();

854 
left
 = 
	`pop
();

855 
	`push
(
	`binary_operator_addition
(&
left
, &
right
));

857 
	`CASE
(
SUB
)

858 
right
 = 
	`pop
();

859 
left
 = 
	`pop
();

860 
	`push
(
	`binary_operator_subtraction
(&
left
, &
right
));

862 
	`CASE
(
MUL
)

863 
right
 = 
	`pop
();

864 
left
 = 
	`pop
();

865 
	`push
(
	`binary_operator_multiplication
(&
left
, &
right
));

867 
	`CASE
(
DIV
)

868 
right
 = 
	`pop
();

869 
left
 = 
	`pop
();

870 
	`push
(
	`binary_operator_division
(&
left
, &
right
));

872 
	`CASE
(
MOD
)

873 
right
 = 
	`pop
();

874 
left
 = 
	`pop
();

875 
	`push
(
	`binary_operator_remainder
(&
left
, &
right
));

877 
	`CASE
(
EQ
)

878 
right
 = 
	`pop
();

879 
left
 = 
	`pop
();

880 
	`push
(
	`binary_operator_equality
(&
left
, &
right
));

882 
	`CASE
(
NEQ
)

883 
right
 = 
	`pop
();

884 
left
 = 
	`pop
();

885 
	`push
(
	`binary_operator_equality
(&
left
, &
right
));

886 --
	`top
()->
boolean
;

888 
	`CASE
(
LT
)

889 
right
 = 
	`pop
();

890 
left
 = 
	`pop
();

891 
	`push
(
	`BOOLEAN
(
	`value_compare
(&
left
, &
right
) < 0));

893 
	`CASE
(
GT
)

894 
right
 = 
	`pop
();

895 
left
 = 
	`pop
();

896 
	`push
(
	`BOOLEAN
(
	`value_compare
(&
left
, &
right
) > 0));

898 
	`CASE
(
LEQ
)

899 
right
 = 
	`pop
();

900 
left
 = 
	`pop
();

901 
	`push
(
	`BOOLEAN
(
	`value_compare
(&
left
, &
right
) <= 0));

903 
	`CASE
(
GEQ
)

904 
right
 = 
	`pop
();

905 
left
 = 
	`pop
();

906 
	`push
(
	`BOOLEAN
(
	`value_compare
(&
left
, &
right
) >= 0));

908 
	`CASE
(
CMP
)

909 
right
 = 
	`pop
();

910 
left
 = 
	`pop
();

911 
	`push
(
	`INTEGER
(
	`value_compare
(&
left
, &
right
)));

913 
	`CASE
(
GET_TAG
)

914 
v
 = 
	`pop
();

915 if (
v
.
tags
 == 0)

916 
	`push
(
NIL
);

918 
	`push
(
	`TAG
(
	`tags_first
(
v
.
tags
)));

920 
	`CASE
(
LEN
)

921 
v
 = 
	`pop
();

922 
	`push
(
	`INTEGER
(
v
.
array
->
count
));

924 
	`CASE
(
PRE_INC
)

925 switch (
	`peektarget
()->
type
) {

926 case 
VALUE_INTEGER
: ++
	`peektarget
()->
integer
; break;

927 case 
VALUE_REAL
: ++
	`peektarget
()->
real
; break;

928 default: 
	`vm_panic
("pre-increment applied to invalid type");

930 
	`push
(*
	`poptarget
());

932 
	`CASE
(
POST_INC
)

933 
	`push
(*
	`peektarget
());

934 switch (
	`peektarget
()->
type
) {

935 case 
VALUE_INTEGER
: ++
	`peektarget
()->
integer
; break;

936 case 
VALUE_REAL
: ++
	`peektarget
()->
real
; break;

937 default: 
	`vm_panic
("post-increment applied to invalid type");

939 
	`poptarget
();

941 
	`CASE
(
PRE_DEC
)

942 switch (
	`peektarget
()->
type
) {

943 case 
VALUE_INTEGER
: --
	`peektarget
()->
integer
; break;

944 case 
VALUE_REAL
: --
	`peektarget
()->
real
; break;

945 default: 
	`vm_panic
("pre-decrement applied to invalid type");

947 
	`push
(*
	`poptarget
());

949 
	`CASE
(
POST_DEC
)

950 
	`push
(*
	`peektarget
());

951 switch (
	`peektarget
()->
type
) {

952 case 
VALUE_INTEGER
: --
	`peektarget
()->
integer
; break;

953 case 
VALUE_REAL
: --
	`peektarget
()->
real
; break;

954 default: 
	`vm_panic
("post-decrement applied to invalid type");

956 
	`poptarget
();

958 
	`CASE
(
MUT_ADD
)

959 
vp
 = 
	`poptarget
();

960 if (
vp
->
type
 == 
VALUE_ARRAY
) {

961 if (
	`top
()->
type
 != 
VALUE_ARRAY
)

962 
	`vm_panic
("attempt to add non-array to array");

963 
	`value_array_extend
(
vp
->
array
, 
	`pop
().array);

965 
v
 = 
	`pop
();

966 *
vp
 = 
	`binary_operator_addition
(vp, &
v
);

968 
	`push
(*
vp
);

970 
	`CASE
(
MUT_MUL
)

971 
vp
 = 
	`poptarget
();

972 
v
 = 
	`pop
();

973 *
vp
 = 
	`binary_operator_multiplication
(vp, &
v
);

974 
	`push
(*
vp
);

976 
	`CASE
(
MUT_DIV
)

977 
vp
 = 
	`poptarget
();

978 
v
 = 
	`pop
();

979 *
vp
 = 
	`binary_operator_division
(vp, &
v
);

980 
	`push
(*
vp
);

982 
	`CASE
(
MUT_SUB
)

983 
vp
 = 
	`poptarget
();

984 
v
 = 
	`pop
();

985 *
vp
 = 
	`binary_operator_subtraction
(vp, &
v
);

986 
	`push
(*
vp
);

988 
	`CASE
(
DEFINE_TAG
)

990 int 
tag
, 
super
, 
n
;

991 
	`READVALUE
(
tag
);

992 
	`READVALUE
(
super
);

993 
	`READVALUE
(
n
);

994 while (
n
 --> 0) {

995 
v
 = 
	`pop
();

996 if (
v
.
refs
 != 
NULL
)

997 
	`NOGC
(
v
.
refs
);

998 
	`tags_add_method
(
tag
, 
ip
, 
v
);

999 
ip
 += 
	`strlen
(ip) + 1;

1001 if (
super
 != -1)

1002 
	`tags_copy_methods
(
tag
, 
super
);

1005 
	`CASE
(
DEFINE_CLASS
)

1007 int 
class
, 
super
, 
n
;

1008 
	`READVALUE
(
class
);

1009 
	`READVALUE
(
super
);

1010 
	`READVALUE
(
n
);

1011 while (
n
 --> 0) {

1012 
v
 = 
	`pop
();

1013 if (
v
.
refs
 != 
NULL
)

1014 
	`NOGC
(
v
.
refs
);

1015 
	`class_add_method
(
class
, 
ip
, 
v
);

1016 
ip
 += 
	`strlen
(ip) + 1;

1018 if (
super
 != -1)

1019 
	`class_copy_methods
(
class
, 
super
);

1022 
	`CASE
(
FUNCTION
)

1024 
v
.
tags
 = 0;

1025 
v
.
type
 = 
VALUE_FUNCTION
;

1026 
v
.
this
 = 
NULL
;

1028 int 
params
;

1029 int 
bound
;

1031 
	`READVALUE
(
params
);

1032 
	`READVALUE
(
bound
);

1034 
v
.
bound
 = bound;

1035 
v
.
params
 = params;

1037 while (*
ip
 != ((char)0xFF))

1038 ++
ip
;

1039 ++
ip
;

1041 
v
.
symbols
 = (int *) 
ip
;

1042 
ip
 += 
bound
 * sizeof (int);

1044 
	`READVALUE
(
n
);

1045 
v
.
code
 = 
ip
;

1046 
ip
 += 
n
;

1048 
	`READVALUE
(
n
);

1049 
v
.
refs
 = (
n
 == 0) ? 
NULL
 : 
	`ref_vector_new
(n);

1051 for (int 
i
 = 0; i < 
n
; ++i) {

1052 
	`READVALUE
(
s
);

1053 
	`READVALUE
(
off
);

1054 
vars
[
s
]->
captured
 = 
true
;

1055 struct 
reference
 
ref
 = { .
pointer
 = (
uintptr_t
) 
vars
[
s
], .
offset
 = 
off
 };

1058 
v
.
refs
->refs[
i
] = 
ref
;

1061 
	`push
(
v
);

1064 
	`CASE
(
CALL
)

1065 
v
 = 
	`pop
();

1066 
	`READVALUE
(
n
);

1067 
Call
:

1068 
	`gc_push
(&
v
);

1069 switch (
v
.
type
) {

1070 case 
VALUE_FUNCTION
:

1071 
	`call
(&
v
, 
NULL
, 
n
, 
false
);

1073 case 
VALUE_BUILTIN_FUNCTION
:

1074 
	`vec_reserve
(
args
, 
n
);

1075 
args
.
count
 = 
n
;

1076 while (
n
 --> 0)

1077 
args
.
items
[
n
] = 
	`pop
();

1078 
	`push
(
v
.
	`builtin_function
(&
args
));

1079 
args
.
count
 = 0;

1081 case 
VALUE_TAG
:

1082 if (
n
 == 1) {

1083 
	`top
()->
tags
 = 
	`tags_push
(top()->tags, 
v
.
tag
);

1084 
	`top
()->
type
 |= 
VALUE_TAGGED
;

1086 struct 
array
 *
items
 = 
	`value_array_new
();

1087 
	`vec_reserve
(*
items
, 
n
);

1088 
items
->
count
 = 
n
;

1089 while (
n
 --> 0)

1090 
items
->items[
n
] = 
	`pop
();

1091 
value
 = 
	`ARRAY
(
items
);

1092 
value
.
type
 |= 
VALUE_TAGGED
;

1093 
value
.
tags
 = 
	`tags_push
(value.tags, 
v
.
tag
);

1094 
	`push
(
value
);

1097 case 
VALUE_CLASS
:

1098 
value
 = 
	`OBJECT
(
	`object_new
(), 
v
.
class
);

1099 
vp
 = 
	`class_lookup_method
(
v
.
class
, "init");

1100 if (
vp
 != 
NULL
) {

1101 
	`call
(
vp
, &
value
, 
n
, 
true
);

1102 
	`pop
();

1104 
stack
.
count
 -= 
n
;

1106 
	`push
(
value
);

1108 case 
VALUE_METHOD
:

1109 
	`call
(
v
.
method
, v.
this
, 
n
, 
false
);

1111 case 
VALUE_REGEX
:

1112 if (
n
 != 1)

1113 
	`vm_panic
("attempt to apply a regex to an invalid number of values");

1114 if (
	`top
()->
type
 != 
VALUE_STRING
)

1115 
	`vm_panic
("attempt to apply a regex to a non-string: %s", 
	`value_show
(
	`top
()));

1116 
stack
.
items
[stack.
count
 - 1] = 
	`get_string_method
("match!")(
	`top
(), &(
value_vector
){ .count = 1, .items = &
v
 });

1118 case 
VALUE_BUILTIN_METHOD
:

1119 
	`vec_reserve
(
args
, 
n
);

1120 
args
.
count
 = 
n
;

1121 
i
 = 0;

1123 for (struct 
value
 const *
a
 = 
stack
.
items
 + stack.
count
 - 
n
; 
i
 < n; ++i, ++a)

1124 
args
.
items
[
i
] = *
a
;

1126 
value
 = 
v
.
	`builtin_method
(v.
this
, &
args
);

1128 
stack
.
count
 -= 
n
;

1129 
	`push
(
value
);

1132 case 
VALUE_NIL
:

1133 
stack
.
count
 -= 
n
;

1134 
	`push
(
NIL
);

1137 
	`vm_panic
("attempt to call non-callable value %s", 
	`value_show
(&
v
));

1139 
	`gc_pop
();

1141 
	`CASE
(
CALL_METHOD
)

1143 
value
 = 
	`peek
();

1145 
vp
 = 
NULL
;

1146 
func
 = 
NULL
;

1147 struct 
value
 *
self
 = 
NULL
;

1149 char const *
method
 = 
ip
;

1150 
ip
 += 
	`strlen
(ip) + 1;

1152 
	`READVALUE
(
n
);

1154 for (int 
tags
 = 
value
.tags; tags != 0; tags = 
	`tags_pop
(tags)) {

1155 
vp
 = 
	`tags_lookup_method
(
	`tags_first
(
tags
), 
method
);

1156 if (
vp
 != 
NULL
) {

1157 
value
.
tags
 = 
	`tags_pop
(tags);

1158 if (
value
.
tags
 == 0)

1159 
value
.
type
 &= ~
VALUE_TAGGED
;

1160 
self
 = &
value
;

1170 if (
self
 == 
NULL
) switch (
value
.
type
 & ~
VALUE_TAGGED
) {

1171 case 
VALUE_TAG
:

1172 
vp
 = 
	`tags_lookup_method
(
value
.
tag
, 
method
);

1174 case 
VALUE_STRING
:

1175 
func
 = 
	`get_string_method
(
method
);

1177 case 
VALUE_DICT
:

1178 
func
 = 
	`get_dict_method
(
method
);

1180 case 
VALUE_ARRAY
:

1181 
func
 = 
	`get_array_method
(
method
);

1183 case 
VALUE_BLOB
:

1184 
func
 = 
	`get_blob_method
(
method
);

1186 case 
VALUE_CLASS
:

1187 
vp
 = 
	`class_lookup_method
(
value
.
class
, 
method
);

1189 case 
VALUE_OBJECT
:

1190 
vp
 = 
	`class_lookup_method
(
value
.
class
, 
method
);

1191 if (
vp
 == 
NULL
) {

1192 
vp
 = 
	`table_lookup
(
value
.
object
, 
method
);

1194 
self
 = &
value
;

1197 case 
VALUE_NIL
:

1198 
	`pop
();

1199 
stack
.
count
 -= 
n
;

1200 
	`push
(
NIL
);

1204 if (
func
 != 
NULL
) {

1205 
	`vec_reserve
(
args
, 
n
);

1206 
args
.
count
 = 
n
;

1207 
i
 = 0;

1209 for (struct 
value
 const *
a
 = 
stack
.
items
 + stack.
count
 - 
n
 - 1; 
i
 < n; ++i, ++a)

1210 
args
.
items
[
i
] = *
a
;

1212 
value
.
type
 &= ~
VALUE_TAGGED
;

1213 
value
.
tags
 = 0;

1215 
v
 = 
	`func
(&
value
, &
args
);

1217 
stack
.
count
 -= 
n
;

1218 
stack
.
items
[stack.
count
 - 1] = 
v
;

1219 } else if (
vp
 != 
NULL
) {

1220 if (
value
.
type
 == 
VALUE_CLASS
 || value.type == 
VALUE_OBJECT
) {

1221 
v
 = 
	`METHOD
(
method
, 
vp
, 
self
);

1223 
v
 = *
vp
;

1225 --
stack
.
count
;

1226 goto 
Call
;

1228 
	`vm_panic
("call to non-existent method '%s' on %s", 
method
, 
	`value_show
(&
value
));

1231 
	`CASE
(
SAVE_STACK_POS
)

1232 
	`vec_push
(
sp_stack
, 
stack
.
count
);

1234 
	`CASE
(
RESTORE_STACK_POS
)

1235 
stack
.
count
 = *
	`vec_pop
(
sp_stack
);

1238 
	`CASE
(
MULTI_RETURN
)

1239 
	`READVALUE
(
rc
);

1240 
stack
.
count
 -= 
rc
;

1241 
	`CASE
(
RETURN
)

1242 
ip
 = *
	`vec_pop
(
calls
);

1243 
	`LOG
("returning: ip = %p", 
ip
);

1245 
	`CASE
(
HALT
)

1246 
	`free
(
args
.
items
);

1247 
ip
 = 
save
;

1248 
	`LOG
("halting: ip = %p", 
ip
);

1252 
	}
}

1255 
	$vm_error
(void)

1257 return 
err_msg
;

1258 
	}
}

1260 
bool


1261 
	$vm_init
(int 
ac
, char **
av
)

1263 
	`vec_init
(
stack
);

1264 
	`vec_init
(
calls
);

1265 
	`vec_init
(
targets
);

1266 
vars
 = 
NULL
;

1267 
symbol_count
 = 0;

1269 
pcre_malloc
 = 
alloc
;

1271 
	`srand
(
	`time
(
NULL
));

1273 
	`compiler_init
();

1275 
	`add_builtins
(
ac
, 
av
);

1277 char *
prelude
 = 
	`compiler_load_prelude
();

1278 if (
prelude
 == 
NULL
) {

1279 
err_msg
 = 
	`compiler_error
();

1280 return 
false
;

1283 int 
new_symbol_count
 = 
	`compiler_symbol_count
();

1284 
	`resize
(
vars
, 
new_symbol_count
 * sizeof *vars);

1285 
	`resize
(
used
, 
new_symbol_count
 * sizeof *used);

1286 while (
symbol_count
 < 
new_symbol_count
) {

1288 
used
[
symbol_count
] = 
false
;

1289 
vars
[
symbol_count
++] = 
NULL
;

1292 if (
	`setjmp
(
jb
) != 0) {

1293 
err_msg
 = 
err_buf
;

1294 return 
false
;

1297 
	`vm_exec
(
prelude
);

1299 return 
true
;

1300 
	}
}

1302 
noreturn
 void

1303 
	$vm_panic
(char const *
fmt
, ...)

1305 
va_list
 
ap
;

1306 
	`va_start
(
ap
, 
fmt
);

1308 char const *
file
;

1309 struct 
location
 
loc
 = 
	`compiler_get_location
(
ip
, &
file
);

1311 int 
n
;

1312 if (
file
 == 
NULL
)

1313 
n
 = 
	`sprintf
(
err_buf
, "RuntimeError: %d:%d: ", 
loc
.
line
 + 1, loc.
col
 + 1);

1315 
n
 = 
	`sprintf
(
err_buf
, "RuntimeError: %s:%d:%d: ", 
file
, 
loc
.
line
 + 1, loc.
col
 + 1);

1316 
	`vsnprintf
(
err_buf
 + 
n
, sizeof err_buf - n, 
fmt
, 
ap
);

1318 
	`va_end
(
ap
);

1320 
	`LOG
("VM Error: %s", 
err_buf
);

1322 
	`longjmp
(
jb
, 1);

1323 
	}
}

1325 
bool


1326 
	$vm_execute_file
(char const *
path
)

1328 char *
source
 = 
	`slurp
(
path
);

1329 if (
source
 == 
NULL
) {

1330 
err_msg
 = "failed to read source file";

1331 return 
false
;

1334 
filename
 = 
path
;

1336 
bool
 
success
 = 
	`vm_execute
(
source
);

1337 
	`free
(
source
);

1339 
filename
 = 
NULL
;

1341 return 
success
;

1342 
	}
}

1344 
bool


1345 
	$vm_execute
(char const *
source
)

1347 if (
filename
 == 
NULL
)

1348 
filename
 = "<interactive>";

1350 char *
code
 = 
	`compiler_compile_source
(
source
, 
filename
);

1351 if (
code
 == 
NULL
) {

1352 
err_msg
 = 
	`compiler_error
();

1353 
	`LOG
("compiler error was: %s", 
err_msg
);

1354 return 
false
;

1357 int 
new_symbol_count
 = 
	`compiler_symbol_count
();

1358 
	`resize
(
vars
, 
new_symbol_count
 * sizeof *vars);

1359 
	`resize
(
used
, 
new_symbol_count
 * sizeof *used);

1360 while (
symbol_count
 < 
new_symbol_count
) {

1362 
used
[
symbol_count
] = 
false
;

1363 
vars
[
symbol_count
++] = 
NULL
;

1366 if (
	`setjmp
(
jb
) != 0) {

1367 
	`gc_clear_root_set
();

1368 
stack
.
count
 = 0;

1369 
sp_stack
.
count
 = 0;

1370 
try_stack
.
count
 = 0;

1371 
targets
.
count
 = 0;

1372 
err_msg
 = 
err_buf
;

1373 return 
false
;

1376 
	`vm_exec
(
code
);

1378 return 
true
;

1379 
	}
}

1381 struct 
value


1382 
	$vm_eval_function
(struct 
value
 const *
f
, struct value const *
v
)

1384 switch (
f
->
type
) {

1385 case 
VALUE_FUNCTION
:

1386 if (
v
 != 
NULL
)

1387 
	`push
(*
v
);

1388 
	`call
(
f
, 
NULL
, 
v
 != NULL, 
true
);

1389 return 
	`pop
();

1390 case 
VALUE_METHOD
:

1391 if (
v
 != 
NULL
)

1392 
	`push
(*
v
);

1393 
	`call
(
f
->
method
, f->
this
, 
v
 != 
NULL
, 
true
);

1394 return 
	`pop
();

1395 case 
VALUE_BUILTIN_FUNCTION
:

1396 return 
f
->
	`builtin_function
(&(
value_vector
){

1397 .
count
 = 
v
 != 
NULL
,

1398 .
items
 = (struct 
value
 *)
v


1400 case 
VALUE_BUILTIN_METHOD
:

1401 return 
f
->
	`builtin_method
(f->
this
, &(
value_vector
){

1402 .
count
 = 
v
 != 
NULL
,

1403 .
items
 = (struct 
value
 *)
v


1406 
	`abort
();

1408 
	}
}

1410 struct 
value


1411 
	$vm_eval_function2
(struct 
value
 const *
f
, struct value const *
v1
, struct value const *
v2
)

1413 
value_vector
 
args
;

1415 switch (
f
->
type
) {

1416 case 
VALUE_FUNCTION
:

1417 
	`push
(*
v1
);

1418 
	`push
(*
v2
);

1419 
	`call
(
f
, 
NULL
, 2, 
true
);

1420 return 
	`pop
();

1421 case 
VALUE_METHOD
:

1422 
	`push
(*
v1
);

1423 
	`push
(*
v2
);

1424 
	`call
(
f
->
method
, f->
this
, 2, 
true
);

1425 return 
	`pop
();

1426 case 
VALUE_BUILTIN_FUNCTION
:

1427 
	`vec_init
(
args
);

1428 
	`vec_push
(
args
, *
v1
);

1429 
	`vec_push
(
args
, *
v2
);

1430 return 
f
->
	`builtin_function
(&
args
);

1432 
	`abort
();

1434 
	}
}

1437 
	$vm_mark
(void)

1439 for (int 
i
 = 0; i < 
symbol_count
; ++i) if (
used
[i]) {

1440 for (struct 
variable
 *
v
 = 
vars
[
i
]; v != 
NULL
; v = v->
next
) {

1441 
	`value_mark
(&
v
->
value
);

1445 for (int 
i
 = 0; i < 
stack
.
count
; ++i)

1446 
	`value_mark
(&
stack
.
items
[
i
]);

1447 
	}
}

1449 
	$TEST
(
let
)

1451 char const *
source
 = "let a = 5;";

1453 
	`vm_init
(0, 
NULL
);

1455 
	`vm_execute
(
source
);

1457 
	`claim
(
vars
[0 + 
builtin_count
]->
value
.
type
 == 
VALUE_INTEGER
);

1458 
	`claim
(
vars
[0 + 
builtin_count
]->
value
.
integer
 == 5);

1459 
	}
}

1461 
	$TEST
(
loop
)

1463 char const *
source
 = "let a = 0; for (let i = 0; i < 10; i = i + 1) a = a + 2;";

1465 
	`vm_init
(0, 
NULL
);

1467 
	`vm_execute
(
source
);

1469 
	`claim
(
vars
[0 + 
builtin_count
]->
value
.
type
 == 
VALUE_INTEGER
);

1470 
	`LOG
("value is %d", (int) 
vars
[0 + 
builtin_count
]->
value
.
integer
);

1471 
	`claim
(
vars
[0 + 
builtin_count
]->
value
.
integer
 == 20);

1472 
	}
}

1474 
	$TEST
(
func
)

1476 char const *
source
 = "let a = 0; let f = function () { a = a + 1; }; f(); f();";

1478 
	`vm_init
(0, 
NULL
);

1480 
	`vm_execute
(
source
);

1482 
	`claim
(
vars
[0 + 
builtin_count
]->
value
.
type
 == 
VALUE_INTEGER
);

1483 
	`LOG
("value is %d", (int) 
vars
[0 + 
builtin_count
]->
value
.
integer
);

1484 
	`claim
(
vars
[0 + 
builtin_count
]->
value
.
integer
 == 2);

1485 
	}
}

1487 
	$TEST
(
stress
)

1489 char const *
source
 = "let n = 0; for (let i = 0; i < 1000000; i = i + 1) { n = n + 1; }";

1491 
	`vm_init
(0, 
NULL
);

1493 
	`vm_execute
(
source
);

1495 
	`claim
(
vars
[0 + 
builtin_count
]->
value
.
type
 == 
VALUE_INTEGER
);

1496 
	`LOG
("value is %d", (int) 
vars
[0 + 
builtin_count
]->
value
.
integer
);

1497 
	`claim
(
vars
[0 + 
builtin_count
]->
value
.
integer
 == 1000000);

1498 
	}
}

1500 
	$TEST
(
stress2
)

1502 char const *
source
 = "let n = 0; for (let i = 0; i < 1000000; i = i + 1) { n = n + (function () return 1;)(); }";

1504 
	`vm_init
(0, 
NULL
);

1506 
	`vm_execute
(
source
);

1508 
	`claim
(
vars
[0 + 
builtin_count
]->
value
.
type
 == 
VALUE_INTEGER
);

1509 
	`LOG
("value is %d", (int) 
vars
[0 + 
builtin_count
]->
value
.
integer
);

1510 
	`claim
(
vars
[0 + 
builtin_count
]->
value
.
integer
 == 1000000);

1511 
	}
}

1513 
	$TEST
(
array
)

1515 char const *
source
 = "let a = [1, 2 + 2, 16];";

1517 
	`vm_init
(0, 
NULL
);

1519 
	`vm_execute
(
source
);

1521 
	`claim
(
vars
[0 + 
builtin_count
]->
value
.
type
 == 
VALUE_ARRAY
);

1522 
	`claim
(
vars
[0 + 
builtin_count
]->
value
.
array
->
count
 == 3);

1523 
	`claim
(
vars
[0 + 
builtin_count
]->
value
.
array
->
items
[0].
type
 == 
VALUE_INTEGER
);

1524 
	`claim
(
vars
[0 + 
builtin_count
]->
value
.
array
->
items
[1].
type
 == 
VALUE_INTEGER
);

1525 
	`claim
(
vars
[0 + 
builtin_count
]->
value
.
array
->
items
[2].
type
 == 
VALUE_INTEGER
);

1526 
	`claim
(
vars
[0 + 
builtin_count
]->
value
.
array
->
items
[0].
integer
 == 1);

1527 
	`claim
(
vars
[0 + 
builtin_count
]->
value
.
array
->
items
[1].
integer
 == 4);

1528 
	`claim
(
vars
[0 + 
builtin_count
]->
value
.
array
->
items
[2].
integer
 == 16);

1529 
	}
}

1531 
	$TEST
(
object
)

1533 char const *
source
 = "let o = {'test': 'hello'};";

1535 
	`vm_init
(0, 
NULL
);

1537 
	`vm_execute
(
source
);

1539 
	`claim
(
vars
[0 + 
builtin_count
]->
value
.
type
 == 
VALUE_DICT
);

1540 struct 
value
 *
v
 = 
	`dict_get_member
(
vars
[0 + 
builtin_count
]->value.
dict
, "test");

1541 
	`claim
(
v
 != 
NULL
);

1542 
	`claim
(
	`strcmp
(
v
->
string
, "hello") == 0);

1543 
	}
}

1545 
	$TEST
(
member_access
)

1547 char const *
source
 = "let o = {'test': 'hello'}; let h = o.test;";

1549 
	`vm_init
(0, 
NULL
);

1551 if (!
	`vm_execute
(
source
))

1552 
	`printf
("error: %s\n", 
	`vm_error
());

1554 
	`claim
(
vars
[1 + 
builtin_count
]->
value
.
type
 == 
VALUE_STRING
);

1555 
	`claim
(
	`strcmp
(
vars
[1 + 
builtin_count
]->
value
.
string
, "hello") == 0);

1556 
	}
}

1558 
	$TEST
(
subscript
)

1560 char const *
source
 = "let o = {'test': 'hello'}; let h = o['test'];";

1562 
	`vm_init
(0, 
NULL
);

1564 
	`vm_execute
(
source
);

1566 
	`claim
(
vars
[1 + 
builtin_count
]->
value
.
type
 == 
VALUE_STRING
);

1567 
	`claim
(
	`strcmp
(
vars
[1 + 
builtin_count
]->
value
.
string
, "hello") == 0);

1568 
	}
}

1570 
	$TEST
(
array_lvalue
)

1572 char const *
source
 = "let [a, [b, c]] = [4, [10, 16]];";

1574 
	`vm_init
(0, 
NULL
);

1576 
	`vm_execute
(
source
);

1578 
	`claim
(
vars
[0 + 
builtin_count
]->
value
.
type
 == 
VALUE_INTEGER
);

1579 
	`claim
(
vars
[0 + 
builtin_count
]->
value
.
integer
 == 4);

1581 
	`claim
(
vars
[1 + 
builtin_count
]->
value
.
type
 == 
VALUE_INTEGER
);

1582 
	`claim
(
vars
[1 + 
builtin_count
]->
value
.
integer
 == 10);

1584 
	`claim
(
vars
[2 + 
builtin_count
]->
value
.
type
 == 
VALUE_INTEGER
);

1585 
	`claim
(
vars
[2 + 
builtin_count
]->
value
.
integer
 == 16);

1586 
	}
}

1588 
	$TEST
(
array_subscript
)

1590 char const *
source
 = "let a = [4, 5, 6]; a[0] = 42; let b = a[0];";

1592 
	`vm_init
(0, 
NULL
);

1594 
	`vm_execute
(
source
);

1596 
	`claim
(
vars
[1 + 
builtin_count
]->
value
.
type
 == 
VALUE_INTEGER
);

1597 
	`claim
(
vars
[1 + 
builtin_count
]->
value
.
integer
 == 42);

1598 
	}
}

1600 
	$TEST
(
func_with_args
)

1602 char const *
source
 = "let a = 0; let f = function (k) { return k + 10; }; a = f(32);";

1604 
	`vm_init
(0, 
NULL
);

1606 
	`vm_execute
(
source
);

1608 
	`claim
(
vars
[0 + 
builtin_count
]->
value
.
type
 == 
VALUE_INTEGER
);

1609 
	`claim
(
vars
[0 + 
builtin_count
]->
value
.
integer
 == 42);

1610 
	}
}

1612 
	$TEST
(
if_else
)

1614 char const *
source
 = "let [a, b] = [nil, nil]; if (false) { a = 48; } else { a = 42; } if (true) { b = 42; } else { b = 98; }";

1616 
	`vm_init
(0, 
NULL
);

1618 
	`vm_execute
(
source
);

1620 
	`claim
(
vars
[0 + 
builtin_count
]->
value
.
type
 == 
VALUE_INTEGER
);

1621 
	`claim
(
vars
[0 + 
builtin_count
]->
value
.
integer
 == 42);

1623 
	`claim
(
vars
[1 + 
builtin_count
]->
value
.
type
 == 
VALUE_INTEGER
);

1624 
	`claim
(
vars
[1 + 
builtin_count
]->
value
.
integer
 == 42);

1625 
	}
}

1627 
	$TEST
(
recursive_func
)

1629 char const *
source
 = "let a = 0; function f(k) if (k == 1) return 1; else return k * f(k - 1); a = f(5);";

1631 
	`vm_init
(0, 
NULL
);

1633 
	`vm_execute
(
source
);

1635 
	`claim
(
vars
[0 + 
builtin_count
]->
value
.
type
 == 
VALUE_INTEGER
);

1636 
	`LOG
("a = %d", (int) 
vars
[0 + 
builtin_count
]->
value
.
integer
);

1637 
	`claim
(
vars
[0 + 
builtin_count
]->
value
.
integer
 == 120);

1638 
	}
}

1640 
	$TEST
(
method_call
)

1642 char const *
source
 = "let o = nil; o = {'name': 'foobar', 'getName': function () { return o.name; }}; o = o.getName();";

1644 
	`vm_init
(0, 
NULL
);

1646 
	`vm_execute
(
source
);

1648 
	`claim
(
vars
[0 + 
builtin_count
]->
value
.
type
 == 
VALUE_STRING
);

1649 
	`claim
(
	`strcmp
(
vars
[0 + 
builtin_count
]->
value
.
string
, "foobar") == 0);

1650 
	}
}

1652 
	$TEST
(
print
)

1654 
	`vm_init
(0, 
NULL
);

1655 
	`vm_execute
("print(45);");

1656 
	}
}

1659 
	$TEST
(
each
)

1661 
	`vm_init
(0, 
NULL
);

1662 
	`claim
(
	`vm_execute
("let o = { 'name': 'Bob', 'age': 19 };"));

1663 
	`claim
(
	`vm_execute
("for (k in @o) { print(k); print(o[k]); print('---'); }"));

1664 
	}
}

1666 
	$TEST
(
bench
)

1668 
	`vm_init
(0, 
NULL
);

1669 
	`vm_execute
("for (let i = 0; i < 1000; i = i + 1) { let [a, b, c] = [{}, {}, {}]; }");

1670 
	}
}

1672 
	$TEST
(
factorial
)

1674 
	`vm_init
(0, 
NULL
);

1676 
	`vm_execute
("let f = function (k) if (k == 1) return 1; else return k * f(k - 1);;");

1677 
	`vm_execute
("f(5);");

1678 
	}
}

1680 
	$TEST
(
match
)

1682 
	`vm_init
(0, 
NULL
);

1684 
	`vm_execute
("match 4 { 4 | false => print('oh no!');, 5 => print('oh dear!');, 4 => print('Yes!'); }");

1685 
	}
}

1687 
	$TEST
(
tagmatch
)

1690 
	`vm_init
(0, 
NULL
);

1692 
	`vm_execute
("tag Add; match Add(4) { Add(k) => print(k); }");

1693 
	}
}

1695 
	$TEST
(
matchrest
)

1697 
	`vm_init
(0, 
NULL
);

1698 
	`vm_execute
("match [4, 5, 6] { [4, *xs] => print(xs); }");

1699 
	}
}

	@
1
.
0
22
173
alloc.c
array.c
blob.c
class.c
compiler.c
dict.c
functions.c
gc.c
json.c
lex.c
object.c
operators.c
panic.c
parse.c
scope.c
str.c
table.c
tags.c
token.c
util.c
value.c
vm.c
